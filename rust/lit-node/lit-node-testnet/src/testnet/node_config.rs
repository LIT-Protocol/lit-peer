use std::path::Path;

#[cfg(all(feature = "proxy_chatter", feature = "testing"))]
pub const FAULT_TEST_CHATTER_CLIENT_TIMEOUT_SECS: u64 = 30; // this forcibly speeds up tests, since the signing round timeout is also reset! 

use super::WhichTestnet;
use lit_core::utils::toml::SimpleToml;
use lit_node_common::config::config_names::{
    CFG_KEY_CHAIN_POLLING_INTERVAL_MS, CFG_KEY_CHATTER_CLIENT_TIMEOUT,
    CFG_KEY_ENABLE_EPOCH_TRANSITIONS, CFG_KEY_ENABLE_PAYMENT,
    CFG_KEY_ENABLE_PROXIED_CHATTER_CLIENT, CFG_KEY_PAYMENT_INTERVAL_MS,
};

#[cfg(all(feature = "proxy_chatter", feature = "testing"))]
use lit_node_common::config::config_names::CFG_KEY_SIGNING_ROUND_TIMEOUT;

use tracing::trace;

pub const CUSTOM_NODE_RUNTIME_CONFIG_PATH: &str = "config/test/custom_node_runtime_config.toml";

// DEFAULT VALUES
pub const ECDSA_ROUND_TIMEOUT_DEFAULT: &str = "20000";

trait SimpleTomlInsertHelper {
    fn insertstr(&mut self, section: &str, key: &str, value: &str);
}

impl SimpleTomlInsertHelper for SimpleToml {
    fn insertstr(&mut self, section: &str, key: &str, value: &str) {
        self.insert(section.to_string(), key.to_string(), value.to_string());
    }
}

#[must_use]
pub struct CustomNodeRuntimeConfigBuilder {
    enable_payment: Option<String>,
    chain_polling_interval: Option<String>,
    payment_interval_ms: Option<String>,
}

impl Default for CustomNodeRuntimeConfigBuilder {
    fn default() -> Self {
        Self::new()
    }
}

impl CustomNodeRuntimeConfigBuilder {
    pub fn new() -> Self {
        Self {
            enable_payment: Some("true".to_string()),
            chain_polling_interval: None,
            payment_interval_ms: None,
        }
    }

    pub fn enable_payment(mut self, enable_payment: Option<String>) -> Self {
        self.enable_payment = enable_payment;
        self
    }

    pub fn payment_interval_ms(mut self, payment_interval_ms: Option<String>) -> Self {
        self.payment_interval_ms = payment_interval_ms;
        self
    }

    pub fn chain_polling_interval(mut self, chain_polling_interval: Option<String>) -> Self {
        self.chain_polling_interval = chain_polling_interval;
        self
    }

    pub fn build(self) -> CustomNodeRuntimeConfig {
        CustomNodeRuntimeConfig {
            enable_payment: self.enable_payment,
            chain_polling_interval: self.chain_polling_interval,
            payment_interval_ms: self.payment_interval_ms,
        }
    }
}

#[derive(Default)]
pub struct CustomNodeRuntimeConfig {
    enable_payment: Option<String>,
    chain_polling_interval: Option<String>,
    payment_interval_ms: Option<String>,
}

impl CustomNodeRuntimeConfig {
    pub fn builder() -> CustomNodeRuntimeConfigBuilder {
        CustomNodeRuntimeConfigBuilder::new()
    }
}

/// This method is used to generate a TOML config file with custom
/// config parameters that will get merged with the rest of the node
/// config that is generated by our contract deployment tool.
pub fn generate_custom_node_runtime_config(
    is_fault_test: bool,
    which_testnet: &WhichTestnet,
    custom_config: &CustomNodeRuntimeConfig,
    node_config_path: Option<String>,
) {
    let advance_epoch = which_testnet.clone() != WhichTestnet::NoChain;

    let mut cfg = match node_config_path.clone() {
        Some(path) => SimpleToml::try_from(Path::new(&path)).unwrap(),
        None => SimpleToml::new(),
    };

    // section node
    let section = "node";
    cfg.insertstr(
        section,
        CFG_KEY_ENABLE_PROXIED_CHATTER_CLIENT,
        &is_fault_test.to_string(),
    );
    cfg.insertstr(
        section,
        CFG_KEY_ENABLE_EPOCH_TRANSITIONS,
        &advance_epoch.to_string(),
    );

    #[cfg(all(feature = "proxy_chatter", feature = "testing"))]
    {
        if is_fault_test {
            cfg.insertstr(
                section,
                CFG_KEY_CHATTER_CLIENT_TIMEOUT,
                &FAULT_TEST_CHATTER_CLIENT_TIMEOUT_SECS.to_string(),
            );
            cfg.insertstr(
                section,
                CFG_KEY_SIGNING_ROUND_TIMEOUT,
                // Multiply by 2 to account for retries.
                // Multiply by 1000 because CFG_KEY_ECDSA_ROUND_TIMEOUT should be in ms but FAULT_TEST_CHATTER_CLIENT_TIMEOUT_SECS is in seconds
                &(FAULT_TEST_CHATTER_CLIENT_TIMEOUT_SECS * 2 * 1000).to_string(),
            );
        }
    }

    #[cfg(not(all(feature = "proxy_chatter", feature = "testing")))]
    {
        // set http timeout to 10 seconds instead of the default of 30s
        cfg.insertstr(section, CFG_KEY_CHATTER_CLIENT_TIMEOUT, "10");
    }

    if let Some(chain_polling_interval) = custom_config.chain_polling_interval.clone() {
        cfg.insertstr(
            section,
            CFG_KEY_CHAIN_POLLING_INTERVAL_MS,
            &chain_polling_interval,
        );
    } else {
        cfg.insertstr(section, CFG_KEY_CHAIN_POLLING_INTERVAL_MS, "1000");
    }

    cfg.insertstr(
        section,
        CFG_KEY_ENABLE_PAYMENT,
        &custom_config
            .enable_payment
            .clone()
            .unwrap_or("false".into()),
    );

    cfg.insertstr(
        section,
        CFG_KEY_PAYMENT_INTERVAL_MS,
        &custom_config
            .payment_interval_ms
            .clone()
            .unwrap_or("1000".into()),
    );

    match node_config_path {
        Some(path) => {
            cfg.write_file(Path::new(&path))
                .expect("Failed to write custom node runtime config");
            trace!("Generated custom node runtime config at {}", path);
        }
        None => {
            cfg.write_file(Path::new(CUSTOM_NODE_RUNTIME_CONFIG_PATH))
                .expect("Failed to write custom node runtime config");
            trace!(
                "Generated custom node runtime config at {}",
                CUSTOM_NODE_RUNTIME_CONFIG_PATH
            );
        }
    }
}
