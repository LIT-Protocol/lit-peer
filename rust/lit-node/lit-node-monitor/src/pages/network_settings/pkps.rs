use crate::{
    pages::history::simple_hex,
    utils::{get_address, get_lit_config},
};
use ethers::types::U256;
use leptos::prelude::*;
use leptos_meta::*;
use leptos_struct_table::{ColumnSort, *};
use lit_blockchain_lite::contracts::pubkey_router::PubkeyRouter;
use serde::{Deserialize, Serialize};

#[derive(TableRow, Clone, Serialize, Deserialize)]
#[table(
    sortable,
    classes_provider = "BootstrapClassesPreset",
    // thead_cell_renderer = "CustomTableHeaderCellRenderer",
    impl_vec_data_provider
)]
pub struct PKP {
    pubkey: String,
    derived_id: String,
    keytype: String,
}

// #[component]
// pub fn CustomTableHeaderCellRenderer<F>(
//     /// The class attribute for the head element. Generated by the classes provider.
//     #[prop(into)]
//     class: Signal<String>,
//     /// The class attribute for the inner element. Generated by the classes provider.
//     #[prop(into)]
//     inner_class: String,
//     /// The index of the column. Starts at 0 for the first column. The order of the columns is the same as the order of the fields in the struct.
//     index: usize,
//     /// The sort priority of the column. `None` if the column is not sorted. `0` means the column is the primary sort column.
//     #[prop(into)]
//     sort_priority: Signal<Option<usize>>,
//     /// The sort direction of the column. See [`ColumnSort`].
//     #[prop(into)]
//     sort_direction: Signal<ColumnSort>,
//     /// The event handler for the click event. Has to be called with [`TableHeadEvent`].
//     on_click: F,
//     children: Children,
// ) -> impl IntoView
// where
//     F: Fn(TableHeadEvent) + 'static,
// {
//     let class = match index {
//         // 0 => "d-md-none",
//         _ => "",
//     };

//     view! { <th class={class}> { children() }</th> }
// }

#[component]
pub fn PKPs() -> impl IntoView {
    let data = LocalResource::new(|| async move { get_pkps().await });

    crate::utils::set_header("PKPs");

    view! {
        <Title text="PKPs"/>
        <div class="card" >
            <div class="card-header">
                <b class="card-title">First 10 PKPs</b>
            </div>
            <div class="card-body">

                {move || match data.get().as_deref() {
                    None => view! { <p>"Loading..."</p> }.into_any(),
                    Some(rows) => view! {
                        <table class="table">
                            <TableContent rows = rows.clone() scroll_container="html"  />
                        </table>
                        }.into_any()
                }}
            </div>
        </div>
    }
}

pub async fn get_pkps() -> Vec<PKP> {
    let pkp_nft_address = get_address(crate::contracts::PKP_NFT_CONTRACT)
        .await
        .unwrap();
    let pubkey_router_address = get_address(crate::contracts::PUB_KEY_ROUTER_CONTRACT)
        .await
        .unwrap();

    let cfg = &get_lit_config();
    let pubkey_router = PubkeyRouter::node_monitor_load(cfg, pubkey_router_address).unwrap();
    let pkp_nft =
        crate::contracts::pkpnft::PKPNFT::node_monitor_load(cfg, pkp_nft_address).unwrap();

    let total_supply = pkp_nft.total_supply().call().await.unwrap();
    let total_supply = total_supply.as_u32();
    log::info!("Total supply of PKPs {}!", total_supply);

    let mut rows: Vec<PKP> = vec![];

    for i in 0..9 {
        let index = U256::from(i);
        let token_id = pkp_nft.token_by_index(index).call().await;
        if token_id.is_ok() {
            let token_id = token_id.unwrap();
            let pkp: crate::contracts::pubkey_router::PubkeyRoutingData =
                pubkey_router.pubkeys(token_id).call().await.unwrap();

            log::info!("pkp: {:?}", pkp);
            let keytype = match pkp.key_type.as_u32() {
                1 => "BLS".to_string(),
                2 => "K256".to_string(),
                _ => "Unknown".to_string(),
            };
            let pubkey = simple_hex(hex::encode(pkp.pubkey.clone()));
            let derived_id = simple_hex(hex::encode(pkp.derived_key_id));
            rows.push(PKP {
                keytype,
                pubkey,
                derived_id,
            });
        }
    }

    rows
}
