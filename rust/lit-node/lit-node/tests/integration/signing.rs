use crate::common::ecdsa::{sign_with_hd_key, simple_single_sign_with_hd_key};
use crate::common::pkp::{generate_session_sigs_and_send_signing_requests, sign_with_pkp_request};
use ethers::signers::LocalWallet;
use ethers::signers::Signer;
use ethers::types::Address;
use ethers::types::{H160, TransactionRequest, U256};
use ethers::{providers::Middleware, signers::to_eip155_v};
use lit_blockchain::contracts::pkpnft::PKPNFT;
use lit_node_testnet::TestSetupBuilder;
use lit_node_testnet::end_user::EndUser;

use lit_node_core::SigningScheme;
use lit_node_testnet::node_collection::get_identity_pubkeys_from_node_set;
use lit_node_testnet::validator::ValidatorCollection;
use rand::Rng;
use rand_core::OsRng;
use std::str::FromStr;
use std::sync::Arc;
use std::{io::BufRead, time::Duration};
use test_case::test_case;
use tracing::{error, info};

const ALL_SIGNING_SCHEMES: [SigningScheme; 14] = [
    SigningScheme::Bls12381G1ProofOfPossession,
    SigningScheme::SchnorrEd25519Sha512,
    SigningScheme::SchnorrK256Sha256,
    SigningScheme::SchnorrP256Sha256,
    SigningScheme::SchnorrP384Sha384,
    SigningScheme::SchnorrRistretto25519Sha512,
    SigningScheme::SchnorrEd448Shake256,
    SigningScheme::SchnorrRedJubjubBlake2b512,
    SigningScheme::SchnorrK256Taproot,
    SigningScheme::SchnorrRedDecaf377Blake2b512,
    SigningScheme::SchnorrkelSubstrate,
    SigningScheme::EcdsaK256Sha256,
    SigningScheme::EcdsaP256Sha256,
    SigningScheme::EcdsaP384Sha384,
];

#[tokio::test]
#[ignore]
async fn test_pkp_permissions_get_address_registered() {
    crate::common::setup_logging();
    let (_testnet, _validator_collection, end_user) = TestSetupBuilder::default().build().await;
    let permissions_contract = end_user.actions().contracts().pkp_permissions.clone();

    let permitted_pubkey = "0x5aaeC3Bd77f1F05f7B1C36927CDc4DB24Ec95bFc";
    let permitted_pubkey_h160 =
        H160::from_str(&permitted_pubkey).expect("Could not convert pubkey string to bytes");

    let token_id = end_user.first_pkp().token_id;
    let res = end_user
        .first_pkp()
        .add_permitted_address_to_pkp(permitted_pubkey_h160, &[U256::from(1)])
        .await;

    assert!(res.is_ok());

    let res = permissions_contract
        .get_permitted_addresses(token_id)
        .call()
        .await;

    assert!(res.is_ok());

    let res = res.unwrap();
    info!("get permitted address result: {:?}", res);
    assert!(!res.is_empty());

    // check second address as first address is itself
    assert_eq!(res[1], permitted_pubkey_h160);
}

#[tokio::test]
#[doc = "Test that a signature generated by a PKP can create a valid eth txn"]
pub async fn test_pkp_hd_sign_and_submit_eth_txn() {
    crate::common::setup_logging();
    info!("Starting test: test_pkp_hd_sign_and_submit_eth_txn");

    let (testnet, validator_collection, end_user) = TestSetupBuilder::default().build().await;

    let pubkey = end_user.first_pkp().pubkey.clone();
    let token_id = end_user.first_pkp().token_id;
    let pkp_address = end_user.first_pkp().eth_address;

    let dest_wallet = LocalWallet::new(&mut OsRng).with_chain_id(testnet.chain_id);

    // get pkp address from chain
    let pkp_address_from_chain = validator_collection
        .actions()
        .contracts()
        .pkpnft
        .get_eth_address(token_id)
        .await
        .expect("Could not get pkp address from chain");

    info!("PKP Ethereum address: {:?}", pkp_address);
    assert_eq!(pkp_address, pkp_address_from_chain);
    // let signer = testnet.deploy_account.signing_provider.clone();
    let signer = end_user.signing_provider().clone();
    let pkp_balance_before = signer
        .get_balance(pkp_address, None)
        .await
        .expect("Could not get PKP balance before");
    assert_eq!(pkp_balance_before, U256::from(0));
    let tx = TransactionRequest::new()
        .to(pkp_address)
        .value(1000000000000000000_u64)
        .from(testnet.deploy_address);
    let tx_hash = signer
        .send_transaction(tx, None)
        .await
        .expect("Could not send eth txn");
    let _receipt = tx_hash.await.expect("Could not get receipt");
    let pkp_seed_balance = signer
        .get_balance(pkp_address, None)
        .await
        .expect("Could not get PKP Balance after");
    assert_eq!(pkp_seed_balance, U256::from(1000000000000000000_u64));

    // generate an eth txn to sign
    let value_to_send = 10;
    let tx = TransactionRequest::new()
        .to(dest_wallet.address())
        .value(value_to_send)
        .from(pkp_address)
        .gas(21000)
        .gas_price(1000000000_u64)
        .chain_id(31337)
        .nonce(0)
        .data(vec![]);
    let to_sign_as_sighash = tx.sighash();
    let to_sign = to_sign_as_sighash.0.to_vec();

    // 21000000000010
    let realm_id = U256::from(1);
    let node_set = validator_collection.random_threshold_nodeset().await;
    let node_set = get_identity_pubkeys_from_node_set(&node_set).await;
    let epoch = validator_collection
        .actions()
        .get_current_epoch(realm_id)
        .await
        .as_u64();

    let result = sign_with_pkp_request(
        &node_set,
        signer.signer().clone(),
        to_sign,
        pubkey.clone(),
        epoch,
        SigningScheme::EcdsaK256Sha256,
    )
    .await
    .unwrap();
    let signature: k256::ecdsa::Signature = serde_json::from_str(&result.0).unwrap();
    let recovery_id = result.3;

    // submit the signature to eth
    let user_balance_before_sending_from_pkp = signer
        .get_balance(end_user.wallet.address(), None)
        .await
        .expect("Could not get user balance before sending from PKP");

    let r_bytes = signature.r().to_bytes();
    let s_bytes = signature.s().to_bytes();
    let r = r_bytes.as_slice();
    let s = s_bytes.as_slice();
    let v = recovery_id.to_byte();
    info!("v is {}", v);
    let ethers_signature = ethers::types::Signature {
        r: U256::from_big_endian(r),
        s: U256::from_big_endian(s),
        v: to_eip155_v(v, 31337),
    };
    info!("Ethers signature: {:?}", ethers_signature);
    // check that the signature matches the pubkey
    let recovered = ethers_signature.recover(to_sign_as_sighash).unwrap();
    info!("Proper PKP address: {:?}", pkp_address);
    info!("Recovered address: {:?}", recovered);
    assert_eq!(recovered, pkp_address,);

    info!("pkp balance is {}", pkp_seed_balance);
    info!(
        "gas * price + value = {}",
        tx.gas.unwrap() * tx.gas_price.unwrap() + tx.value.unwrap()
    );

    let rlp_signed = tx.rlp_signed(&ethers_signature);
    let tx_hash = signer
        .send_raw_transaction(rlp_signed)
        .await
        .expect("Could not send txn for PKP");
    let _receipt = tx_hash.await.expect("Could not get receipt");
    let pkp_balance_after_sending_from_pkp = signer
        .get_balance(pkp_address, None)
        .await
        .expect("Could not get PKP Balance after sending from PKP");
    assert!(pkp_balance_after_sending_from_pkp <= pkp_seed_balance - value_to_send);

    info!("pkp_seed_balance: {:?}", pkp_seed_balance);
    info!("value_to_send: {:?}", value_to_send);
    info!(
        "pkp_balance_after_sending_from_pkp: {:?}",
        pkp_balance_after_sending_from_pkp
    );

    let dest_wallet_balance_post_tx = signer
        .get_balance(dest_wallet.address(), None)
        .await
        .expect("Could not get deployer balance after sending from PKP");

    info!(
        "dest_wallet_balance_post_tx: {:?}",
        dest_wallet_balance_post_tx
    );
    info!(
        "user_balance_before_sending_from_pkp: {:?}",
        user_balance_before_sending_from_pkp
    );

    info!(
        "user balance + value_to_send: {:?}",
        user_balance_before_sending_from_pkp + value_to_send
    );

    assert_eq!(dest_wallet_balance_post_tx, U256::from(value_to_send));

    // now test that if we try to sign something that's no 32 bytes, it will return an error.  this could be it's own test but then we have to set up the nodes again and i don't think we need to do that for such a small test
    let endpoint_responses = generate_session_sigs_and_send_signing_requests(
        &node_set,
        signer.signer().clone(),
        vec![1, 2, 3, 4],
        pubkey,
        epoch,
        SigningScheme::EcdsaK256Sha256,
    )
    .await;

    let mut error_counts = 0;
    for response in &endpoint_responses {
        if !response.ok {
            error_counts += 1;
        }
    }

    assert!(
        error_counts >= node_set.len(),
        "Error counts should be {} but it is {}",
        node_set.len(),
        error_counts
    );
}

#[tokio::test]
#[doc = "Primary test to ensure that the network can sign with a PKP key.  It goes through the process of spinning up the network, minting a new PKP, and then signing with it."]
#[ignore] // we can run this locally, but epoch change tests below already implement this test.
pub async fn test_pkp_hd_sign_generic_key() {
    crate::common::setup_logging();
    info!("Starting test: test_hd_pkp_sign");
    let (testnet, validator_collection, end_user) = TestSetupBuilder::default().build().await;
    let pubkey = end_user.first_pkp().pubkey.clone();

    sign_with_each_curve_type(&validator_collection, &end_user, pubkey.clone()).await;

    drop(testnet);
}

#[tokio::test]
#[doc = "Primary test to ensure that the network can sign with a PKP key.  It goes through the process of spinning up the network, minting a new PKP, and then signing with it, advancing an epoch and signing again.."]
pub async fn test_pkp_hd_sign_generic_key_with_epoch_change() {
    crate::common::setup_logging();

    info!("Starting test: test_pkp_hd_sign_generic_key_with_epoch_change");
    let (_testnet, validator_collection, end_user) = TestSetupBuilder::default().build().await;

    let actions = validator_collection.actions();
    let pubkey = end_user.first_pkp().pubkey.clone();

    let realm_id = U256::from(1);
    let current_epoch = actions.get_current_epoch(realm_id).await;

    // check to see that we can sign
    sign_with_each_curve_type(&validator_collection, &end_user, pubkey.clone()).await;

    // Wait for the new node to be active.
    actions.wait_for_active(realm_id).await;

    //in test peers refresh every 1 second, so this allows time to refresh peer data after the new node is staked and active.
    actions.sleep_millis(2000).await;

    // Fast forward the network by 300 seconds, and wait for the new node to be active - effectively waiting for the next epoch.
    actions.increase_blockchain_timestamp(300).await;

    // Wait for DKG to start and then finish, by effectively waiting for the epoch change - nodes become active once more.
    actions.wait_for_epoch(realm_id, current_epoch + 1).await;

    // check to see that we can sign
    sign_with_each_curve_type(&validator_collection, &end_user, pubkey.clone()).await;
}

#[tokio::test]
#[doc = "Primary test to ensure that the network can sign when one node has dropped."]
pub async fn test_pkp_signing_when_nodes_drop() {
    crate::common::setup_logging();
    info!("Starting test: test_pkp_signing_when_nodes_drop");
    let num_nodes = 7;
    let node_to_kill = 3;

    let (testnet, mut validator_collection, end_user) = TestSetupBuilder::default()
        .num_staked_and_joined_validators(num_nodes)
        .build()
        .await;

    let pubkey = end_user.first_pkp().pubkey.clone();

    sign_with_each_curve_type(&validator_collection, &end_user, pubkey.clone()).await;

    assert!(validator_collection.stop_node(node_to_kill).await.is_ok());
    let realm_id = U256::from(1);
    let current_epoch = validator_collection
        .actions()
        .get_current_epoch(realm_id)
        .await;

    let staker_address_to_kick = testnet.node_accounts[node_to_kill].staker_address;
    let staker_address_of_non_faulty_node = testnet.node_accounts[0].staker_address;
    let get_voting_status_res = validator_collection
        .actions()
        .wait_for_voting_status_to_kick_validator(
            realm_id,
            current_epoch,
            staker_address_to_kick,
            staker_address_of_non_faulty_node,
            3,
            true,
        )
        .await;
    info!("get_voting_status_res: {:?}", get_voting_status_res);
    assert!(get_voting_status_res.is_ok());
    info!("Faulty node is kicked");

    // wait for next epoch to start
    validator_collection
        .actions()
        .wait_for_epoch(realm_id, current_epoch + 1)
        .await;

    for scheme in ALL_SIGNING_SCHEMES {
        assert!(
            simple_single_sign_with_hd_key(
                &validator_collection,
                &end_user,
                pubkey.clone(),
                scheme,
                &vec![]
            )
            .await,
            "Failed to sign after node drops."
        );
    }
}

pub async fn sign_with_each_curve_type(
    validator_collection: &ValidatorCollection,
    end_user: &EndUser,
    pubkey: String,
) {
    for scheme in ALL_SIGNING_SCHEMES {
        info!("Signing with scheme: {:?}", scheme);
        let result = simple_single_sign_with_hd_key(
            &validator_collection,
            &end_user,
            pubkey.clone(),
            scheme,
            &vec![],
        )
        .await;
        assert!(result, "Failed to sign with all nodes up.");
    }
}

#[test_case(SigningScheme::EcdsaK256Sha256; "Secp256k1 ECDSA Sign with presignatures")]
#[test_case(SigningScheme::EcdsaP256Sha256; "P-256 ECDSA Sign with presignatures")]
#[test_case(SigningScheme::EcdsaP384Sha384; "P-384 ECDSA Sign with presignatures")]
#[tokio::test]
#[doc = "Simple presign test."]
pub async fn test_presign(signing_scheme: SigningScheme) {
    crate::common::setup_logging();
    info!("Starting test: Simple presign test");

    let messages_to_sign = 10;
    let (_testnet, validator_collection, end_user) = TestSetupBuilder::default().build().await;

    let num_nodes = validator_collection.validator_count();

    let pubkey = end_user.first_pkp().pubkey.clone();

    // open the log files
    let mut log_readers = validator_collection.log_readers();

    let start = std::time::Instant::now();
    let _ = sign_with_hd_key(
        &validator_collection,
        &end_user,
        pubkey.clone(),
        false,
        true,
        1,
        Some("First Test message".to_string()),
        signing_scheme,
        &vec![],
    )
    .await;
    info!(
        "Requiring'd Pregen Presigns: Time elapsed: {:?}",
        start.elapsed()
    );

    // give the nodes a few seconds to populate a triple or two.
    let warmup_time = Duration::from_millis(5000);
    validator_collection
        .actions()
        .sleep_millis(warmup_time.as_millis() as u64)
        .await;

    // clear the log buffer
    for reader in &mut log_readers {
        let _lines = reader
            .lines()
            .map(|line| line.unwrap_or("".to_string()))
            .collect::<Vec<String>>();
    }

    let mut ps_cache_hit = 0;
    let mut ps_cache_hit_duration: Duration = Duration::from_millis(0);
    let mut ps_cache_miss = 0;
    let mut ps_cache_miss_duration: Duration = Duration::from_millis(0);
    let mut sign_success = 0;
    let mut total_sleep = Duration::from_millis(0);
    let mut signing_time: Vec<u32> = Vec::new();
    let start = std::time::Instant::now();
    for i in 0..messages_to_sign {
        info!("Starting sig #{}", i);
        let message_to_sign = Some(format!("Test message #{}", i));
        let start_1 = std::time::Instant::now();
        let validation = sign_with_hd_key(
            &validator_collection,
            &end_user,
            pubkey.clone(),
            false,
            false,
            1,
            message_to_sign,
            signing_scheme,
            &vec![],
        )
        .await;

        if validation {
            sign_success += 1;
        } else {
            error!("Validation failed for sig #{}", i);
        }

        let completion_time = start_1.elapsed();
        let mut node_cache_hit_count = 0;
        let mut node_cache_miss_count = 0;
        for reader in &mut log_readers {
            let lines = reader
                .lines()
                .map(|line| line.unwrap_or("".to_string()))
                .collect::<Vec<String>>();
            for line in lines {
                if line.contains("Cache Hit") {
                    node_cache_hit_count += 1;
                    break;
                }
                if line.contains("Cache Miss") {
                    node_cache_miss_count += 1;
                    break;
                }
            }
        }
        info!("node_cache_hit_count: {}", node_cache_hit_count);
        info!("node_cache_miss_count: {}", node_cache_miss_count);
        let consensus = node_cache_hit_count == num_nodes || node_cache_miss_count == num_nodes;
        if !consensus {
            error!(
                "We did not get consensus among the nodes to tell if this was a hit or a miss.  node_cache_hit_count: {}, node_cache_miss_count: {}",
                node_cache_hit_count, node_cache_miss_count
            )
        }
        // assert!(consensus);
        if node_cache_hit_count >= node_cache_miss_count {
            ps_cache_hit += 1;
            ps_cache_hit_duration += completion_time;
        } else {
            ps_cache_miss += 1;
            ps_cache_miss_duration += completion_time;
        }
        signing_time.push(start_1.elapsed().as_millis() as u32);
        let sleep_time = rand::thread_rng().gen_range(0..100) * 50_u64;
        total_sleep += Duration::from_millis(sleep_time);
        validator_collection
            .actions()
            .sleep_millis(sleep_time)
            .await;
    }

    let total_elapsed = start.elapsed();
    info!(
        "
        Signing {} messages randomly in a {} node network 
        Pregen PS Warmup: {:?} 
        PS Cache Hit (qty/time): {} / {:?}  
        PS Cache Miss (qty/time): {} / {:?} 
        Cache success: {:?} 
        Total time spent sleeping: {:?} 
        Total Time elapsed: {:?} 
        Sign success: {:?} 
        Signing time: {:?} ",
        messages_to_sign,
        num_nodes,
        warmup_time,
        ps_cache_hit,
        ps_cache_hit_duration,
        ps_cache_miss,
        ps_cache_miss_duration,
        ps_cache_hit as f64 / messages_to_sign as f64,
        total_sleep,
        total_elapsed,
        sign_success,
        signing_time
    );

    assert_eq!(
        sign_success, messages_to_sign,
        "Sign success: {}, messages_to_sign: {}",
        sign_success, messages_to_sign
    );
}

#[tokio::test]
#[ignore]
#[doc = "Test to validate a number of messages signed with a single key.  This function helps test out differences in rec_id or similar issues."]
pub async fn test_pkp_hd_sign_20_messages_generic_key() {
    crate::common::setup_logging();
    info!("Starting test: test_hd_pkp_sign");
    let (_testnet, validator_collection, end_user) = TestSetupBuilder::default().build().await;
    let pubkey = end_user.first_pkp().pubkey.clone();

    let validation = sign_with_hd_key(
        &validator_collection,
        &end_user,
        pubkey.clone(),
        false,
        false,
        20,
        None,
        SigningScheme::EcdsaK256Sha256,
        &vec![],
    )
    .await;

    assert!(validation);
}

#[doc = "Permitted EOA wallet can sign with a burnt PKP"]
#[tokio::test]
pub async fn eoa_session_sig_with_mgb_pkp_signing() {
    crate::common::setup_logging();
    info!("Starting test: eoa_session_sig_with_mgb_pkp_signing");

    let (testnet, validator_collection, end_user) = TestSetupBuilder::default().build().await;

    info!("end user pkp info: {:?}", end_user.first_pkp().info());
    let (pubkey, token_id, pkp_address, _key_set_id) = end_user.first_pkp().info().clone();

    let owner_wallet = end_user.signing_provider().clone();

    // Add non-owner wallet as a permitted address of the PKP
    let non_owner_end_user = EndUser::new(&testnet);
    non_owner_end_user.fund_wallet_default_amount().await;
    non_owner_end_user.deposit_to_wallet_ledger_default().await;
    let non_owner_wallet = non_owner_end_user.wallet;

    let pkp = end_user.pkp_by_pubkey(pubkey.clone());
    pkp.add_permitted_address_to_pkp(non_owner_wallet.address(), &[U256::from(1)])
        .await
        .expect("Could not add permitted address to pkp");

    // Burn the PKP
    let pkpnft_address = validator_collection.actions().contracts().pkpnft.address();
    let pkpnft = PKPNFT::new(pkpnft_address, Arc::new(owner_wallet.clone()));
    let _receipt = pkpnft
        .burn(token_id)
        .send()
        .await
        .expect("Failed to send burn PKP transaction")
        .await
        .expect("Failed while waiting for burn PKP confirmation");

    let node_set = validator_collection.random_threshold_nodeset().await;
    let node_set = get_identity_pubkeys_from_node_set(&node_set).await;
    let realm_id = ethers::types::U256::from(1);
    let epoch = validator_collection
        .actions()
        .get_current_epoch(realm_id)
        .await
        .as_u64();

    let value_to_send = 10;
    let tx = TransactionRequest::new()
        .to("0x0000000000000000000000000000000000000000"
            .parse::<Address>()
            .unwrap())
        .value(value_to_send)
        .from(pkp_address)
        .gas(21000)
        .gas_price(1000000000_u64)
        .chain_id(31337)
        .nonce(0)
        .data(vec![]);
    let to_sign_as_sighash = tx.sighash();
    let to_sign = to_sign_as_sighash.0.to_vec();

    info!("Owner wallet should not be able to sign");
    let signing_resp = generate_session_sigs_and_send_signing_requests(
        &node_set,
        owner_wallet.signer().clone(),
        to_sign.clone(),
        pubkey.clone(),
        epoch,
        SigningScheme::EcdsaK256Sha256,
    )
    .await;

    for resp in signing_resp {
        assert!(!resp.ok);
        assert!(resp.error_object.as_ref().unwrap().contains(
            "None of the AuthMethods, AuthSig or Lit Actions meet the required scope [1]"
        ));
    }

    info!("Permitted Non-owner wallet should be able to sign");
    let result = sign_with_pkp_request(
        &node_set,
        non_owner_wallet,
        to_sign.clone(),
        pubkey.clone(),
        epoch,
        SigningScheme::EcdsaK256Sha256,
    )
    .await
    .unwrap();

    let signature: k256::ecdsa::Signature = serde_json::from_str(&result.0).unwrap();
    let recovery_id = result.3;

    let r_bytes = signature.r().to_bytes();
    let s_bytes = signature.s().to_bytes();
    let r = r_bytes.as_slice();
    let s = s_bytes.as_slice();
    let v = recovery_id.to_byte();
    debug!("recovery id: {:?}", v);
    let ethers_signature = ethers::types::Signature {
        r: U256::from_big_endian(r),
        s: U256::from_big_endian(s),
        v: to_eip155_v(v, 31337),
    };
    debug!("ethers signature: {:?}", ethers_signature);

    let recovered = ethers_signature.recover(to_sign_as_sighash).unwrap();
    // let pkp_address_h160 = Address::from_slice(&pkp_address);
    // info!("Proper PKP address: {:?}", pkp_address_h160);
    info!("Proper PKP address: {:?}", pkp_address);
    info!("Recovered address: {:?}", recovered);

    assert_eq!(recovered, pkp_address);
}
