# LIT Fast ECDSA

This algorithm is based on [Fast Threshold ECDSA with Honest Majority](https://eprint.iacr.org/2020/501.pdf) by Ivan Damgard, Thomas Pelle Jakobsen, Jesper Buus Nielsen, Jakob Illeborg Pagter, and Michael Bæksvang Østergaard.

The algorithm assumes an honest majority in order to complete the signing protocol. 
The algorithm is secure against malicious adversaries as long as the majority of the participants are honest.
This means the honest majority will abort the protocol if they detect any malicious behavior,
and the adversary will not be able to obtain a valid signature.

The algorithm is implemented as described in the paper, except for the following changes:

## Change 1 - Distinct IDs
Participants are identified by arbitrary scalar
values (thereafter called “ID”), subject only to the following constraints: all participant
identifiers must be distinct from zero and from each other. The various protocols (key
generation, key refresh/re-sharing, Beaver triple generation, pre-signature and signature), as
described in specifications, assume that the participant IDs are permanent, i.e.
that when an entity participates in several of these protocols, it assumes the same ID.
All threshold algorithms based on Shamir's secret sharing scheme assume the same ID for the key shares is the same as the other Data (beaver triples, pre-signatures, etc.)
This is not often the case in practice. This raises whether IDs can be dynamically allocated, and, in particular,
whether a private key and other data can be generated by the same subset of
participants using different IDs for the same participant, and still be used together to
generate a signature. Essentially, threshold algorithms do not include any provision for using
distinct ID sets. This is a significant limitation, as it means that the same set of participants
must always be used. Participants come and go (either from disinterest or technical reasons). 
Participant IDs change and are not permanent and can be different for key shares and other data.

We modified the algorithm to allow for distinct IDs for the key shares and the pre-signatures.
This required change means two lagrange coefficients are needed instead of just one during signing.

## Change 2 - Early Abort

The paper details how the protocol can be made *fair* with additional checks. These checks
don't necessarily increase security, but they allow the participants to detect malicious behavior
sooner and abort during the pre-signing phase.

We use Feldman VSS to verify thresholds and share correctness of `a`, `b`, `d`, `e`, and `k` during pre-signing phase 1

## Change 3 - Re-randomization

[Shoup and Groth](https://eprint.iacr.org/2021/1330) show that threshold ECDSA protocols that utilize pre-signatures
are vulnerable to a key recovery attack. The attack is based on the fact that the pre-signature is generated ahead of time
in a threshold manner. The mitigation is to re-randomize the pre-signature before generating the signature by applying a random value
commonly known to all signing participants as $\delta$. We apply the re-randomizer to the pre-signature before generating the signature
by hashing a signing nonce to a scalar. The signing nonce is sent along with the request message to sign.

**Caveat**
We also support the case where the signers generate no pre-signature and directly generate the signature.
In this case the re-randomizer is not needed.

# Pre-signature Generation

The goal of this phase is to generate a pre-signature and front load as much of the signature computation as possible.
The pre-signature can then be consumed in a semi-non-interactive manner later during signing. 
More concretely, we have a set of $P$ parties of size $N$, which want to generate a pre-signature with threshold $t$.

The minimum threshold we allow is $t_m = \frac{N - 1}{2}$

**Round 1**

A polynomial is composed of coefficients such that

$f_i(X) = s_{i0} + s_{i1}X + s_{i2}X^2 + \cdots + s_{it}X^t$

Feldman VSS describes share verifiers as commitments to the coefficients of the polynomial denoted as

$g$ denotes the base point of the elliptic curve group.

$V_i(f_i(X)) = \{g^{s_{i0}}, g^{s_{i1}}, g^{s_{i2}}, \cdots, g^{s_{it}}\}$

The notation $i,j$ denotes the sending party $P_i$ and the receiving party $P_j$ respectively.

Each $P_i$ 

1. Generate random degree $t_m$ polynomials $f_i^{A}, f_i^K \in \mathbb{Z}_q$
2. Generate random degree $t$ polynomial $f_i^D, f_i^E \in \mathbb{Z}_q$
   where $f_i^D(0) = f_i^E(0) = 0$
3. Generate random degree $2t_m$ polynomial $f_i^B \in \mathbb{Z}_q$
   where $f_i^B(0) = 0$
4. Set $a_{i,j} = f_i^{A}(j)$, $V_i^{A} = V_i(f_i^{A}(X))$
5. Set $b_{i,j} = f_i^B(j)$, $V_i^{B} = V_i(f_i^{B}(X))$
6. Set $d_{i,j} = f_i^D(j)$, $V_i^{D} = V_i(f_i^{D}(X))$
7. Set $e_{i,j} = f_i^E(j)$, $V_i^{E} = V_i(f_i^{E}(X))$
8. Set $k_{i,j} = f_i^K(j)$, $V_i^{K} = V_i(f_i^{K}(X))$
9. $\diamondsuit$ Stores $a_i', b_i', d_i', e_i', k_i', V_i^K[0]$
10. $\star$ Send $\chi_{1j} = \{a_{i,j}, b_{i,j}, d_{i,j}, e_{i,j}, k_{i,j}, V_i^{A}, V_i^{B}, V_i^{D}, V_i^{E}, V_i^{K}\}$ to all $P_j \in P$

**Round 2**

$\Gamma(V)$ denotes the length of the vector $V$.

Each $P_i$

1. $\bullet$ waits to receive $\chi_{1j}$ from all $P_j \in P$
2. $\blacktriangle$ asserts
   - $\Gamma(V_j^A) = t_m$
   - $\Gamma(V_j^B) = 2t_m$
   - $\Gamma(V_j^D) = t$
   - $\Gamma(V_j^E) = t$
   - $\Gamma(V_j^K) = t_m$
   - $A_j \neq 1_{\mathbb{G}} \in V_j^A$
   - $B_j \neq 1_{\mathbb{G}} \in V_j^{B_{1..2t}}$
   - $B_0 = 1_{\mathbb{G}}$
   - $D_j \neq 1_{\mathbb{G}} \in V_j^{D_{1..t}}$
   - $D_0 = 1_{\mathbb{G}}$
   - $E_j \neq 1_{\mathbb{G}} \in V_j^{E_{1..t}}$
   - $E_0 = 1_{\mathbb{G}}$
   - $K_j \neq 1_{\mathbb{G}} \in V_j^K$
   - $a_{j}$ is a valid sharing in $V_j^A$
   - $b_{j}$ is a valid sharing in $V_j^B$
   - $d_{j}$ is a valid sharing in $V_j^D$
   - $e_{j}$ is a valid sharing in $V_j^E$
   - $k_{j}$ is a valid sharing in $V_j^K$
3. $\diamondsuit$ Computes and stores
   - $a_i = a_i' + \sum_{j \in P} a_j$
   - $b_i = b_i' + \sum_{j \in P} b_j$
   - $d_i = d_i' + \sum_{j \in P} d_j$
   - $e_i = e_i' + \sum_{j \in P} e_j$
   - $k_i = k_i' + \sum_{j \in P} k_j$
   - $R = V_i[0] + \sum_{j \in P} V_j[0]$
   - $W_i = R^{a_i}$
   - $w_i = a_i k_i + b_i$
4. $\blacktriangle$ asserts $R \neq 1_{\mathbb{G}}$
5. $\star$ Send $\chi_{2i} = \{R, W_i, w_i\}$ to all $P_j \in P$

**Round 3**

$\lambda(P_i)$ denotes the Lagrange coefficient for $P_i \in P$.

Each $P_i$

1. $\bullet$ waits to receive $\chi_{2j}$ from all $P_j \in P$
2. $\blacktriangle$ asserts
   - $R_j \neq 1_{\mathbb{G}}$
   - $R_j = R_i$
3. Computes
   - $w = \lambda(P_i) w_i + \sum_{j \in P} \lambda(P_j) w_j$
   - $W = \lambda(P_i) W_i + \sum_{j \in P} \lambda(P_j) W_j$
   - $\omega_i = a_i w^{-1}$
4. $\blacktriangle$ asserts
   - $W \neq 1_{\mathbb{G}}$
   - $w \neq 0$
   - $g^{w} = W$
5. $\star$ Send $\chi_{3i} = \{\omega_i\}$ to all $P_j \in P$

**Round 4**

Each $P_i$

1. $\bullet$ waits to receive $\chi_{3j}$ from all $P_j \in P$
2. Computes $\omega = \lambda(P_i) \omega_i + \sum_{j \in P} \lambda(P_j) \omega_j $
3. $\blacktriangle$ asserts $g = R^{\omega}$
4. $\square$ Outputs pre-signature $\varrho_i = \{P_i, t, R, \omega, d_i, e_i\}$

# Signature Generation

The goal is to generate a signature from the pre-signature. The signature can be generated in a semi-non-interactive manner.
The only communication required by signers is

1. The request message to be signed $m$
2. The signing nonce $\nu$
3. The pre-signature itself $\varrho$
4. The participating signer set $P_S$

Let $\ell$ be the security parameter.
$\mathcal{H}$ hashes the input to a scalar in $\mathbb{Z}_q$. However, the message $m$ and $R$ hash bytes the same length
as the group order $q$ vs the $\nu$ which can be any length. To distinguish between the two, we denote the hash functions as

- $\mathcal{H}^{2\ell}$ denotes the hash function that hashes an input with length $2\ell$ and outputs $s \in \mathbb{Z}_q$.
- $\mathcal{H}^{*}$ denotes the hash function that hashes an input of any length to the scalar $s \in \mathbb{Z}_q$.

Each $P_i$

1. Inputs
   - Pre-signature $\varrho$
   - Pre-signature signer IDs $P_{\varrho}$
   - The signing nonce $\nu$
   - The request message $m$
   - The signing key share $x_i$
   - The signing key share participant ID
   - Key share signer IDs $P_{x}$
2. $\blacktriangle$ asserts
    - $P_i \in P_{\varrho}$
    - $P_i \in P_{x}$
    - $\omega \neq 0$
3. Computes re-randomizer $\delta = \mathcal{H}^{*}(\nu)$
4. $\blacktriangle$ asserts $\delta \neq 0$
5. Computes message scalar $z = \mathcal{H}^{2\ell}(m)$
6. $\blacktriangle$ asserts $z \neq 0$
7. Computes $R' = Rg^{\delta}$
8. $\blacktriangle$ asserts $R' \neq 1_{\mathbb{G}}$
9. Computes signature $r = \mathcal{H}^{2\ell}(R'.x)$
10. $\blacktriangle$ asserts $r \neq 0$
11. Computes $k = (\omega^{-1} + \delta)$
12. $\blacktriangle$ asserts $k \neq 0$
13. Computes $s_i = \lambda(P_i \in P_x) k^{-1}(z + r x_i) + \lambda(P_i \in P_{\varrho}) (z d_i + e_i)$
14. $\square$ Outputs signature share $\sigma_i = \{r, s_i\}$

$\sigma_i$ is sent to the requester. The requester can aggregate the signature shares to obtain the final signature
by computing

$s = \sum_{i \in P_S} \sigma.s_i$ 

and settings $\sigma = \{r, s\}$