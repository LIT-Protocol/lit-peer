pub use staking::*;
/// This module was auto-generated with ethers-rs Abigen.
/// More information at: <https://github.com/gakonst/ethers-rs>
#[allow(
    clippy::enum_variant_names,
    clippy::too_many_arguments,
    clippy::upper_case_acronyms,
    clippy::type_complexity,
    dead_code,
    non_camel_case_types,
)]
pub mod staking {
    const _: () = {
        ::core::include_bytes!(
            "../../abis/Staking.json",
        );
    };
    #[allow(deprecated)]
        fn __abi_functions() -> std::collections::BTreeMap<String, Vec<::ethers::core::abi::ethabi::Function>> {
        let mut abi_functions = __abi_functions_1();
abi_functions.append(&mut __abi_functions_2()); 

abi_functions.append(&mut __abi_functions_3()); 

abi_functions.append(&mut __abi_functions_4()); 

abi_functions.append(&mut __abi_functions_5()); 

        std::collections::BTreeMap::from(
        abi_functions
        )
        }
        
        #[allow(deprecated)]
        fn __abi_functions_1() -> std::collections::BTreeMap<String, Vec<::ethers::core::abi::ethabi::Function>> {
        
        std::collections::BTreeMap::from(
        [
                (
                    ::std::borrow::ToOwned::to_owned("IS_TEST"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("IS_TEST"),
                            inputs: ::std::vec![],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bool,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bool"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("_generateAddresses"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("_generateAddresses"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("numAddresses"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address[]"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::Pure,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("_generateAddressesWithOffset"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "_generateAddressesWithOffset",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("numAddresses"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("offset"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address[]"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::Pure,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("_generatePubKeys"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("_generatePubKeys"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("stakers"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Bytes,
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bytes[]"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::Pure,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("_generateUint256s"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("_generateUint256s"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("numUint256s"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256[]"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::Pure,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("_generateUint256sWithOffset"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "_generateUint256sWithOffset",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("numUint256s"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("offset"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256[]"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::Pure,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("_generateValidators"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "_generateValidators",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("numValidators"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Tuple(
                                                ::std::vec![
                                                    ::ethers::core::abi::ethabi::ParamType::Address,
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                ],
                                            ),
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "struct SetupAndUtils.TestValidator[]",
                                        ),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::Pure,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("addRealm"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("addRealm"),
                            inputs: ::std::vec![],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("realmId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("adminKickValidatorInNextEpoch"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "adminKickValidatorInNextEpoch",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "validatorStakerAddress",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("adminRejoinValidator"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "adminRejoinValidator",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("realmId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("stakerAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned(
                        "adminSetValidatorRegisterAttestedWalletDisabled",
                    ),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "adminSetValidatorRegisterAttestedWalletDisabled",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("validatorAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("disabled"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bool,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bool"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("adminSetValidatorsInCurrentEpoch"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "adminSetValidatorsInCurrentEpoch",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("realmId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "validatorsForCurrentEpoch",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address[]"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("adminSetValidatorsInNextEpoch"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "adminSetValidatorsInNextEpoch",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("realmId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "validatorsForNextEpoch",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address[]"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("adminSetupShadowSplicing"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "adminSetupShadowSplicing",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("source_realmId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("target_realmId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("target_validators"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address[]"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("adminSlashValidator"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "adminSlashValidator",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("percentage"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("stakerAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("adminStakeForUser"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("adminStakeForUser"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("userStakerAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "operatorStakerAddress",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("timeLock"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("amount"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("adminUnfreezeForUser"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "adminUnfreezeForUser",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("userStakerAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "operatorStakerAddress",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("stakeId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("advanceEpoch"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("advanceEpoch"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("realmId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("approve"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("approve"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("approved"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("tokenId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("balanceOf"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("balanceOf"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("owner"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("calculateRewardsPerDay"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "calculateRewardsPerDay",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("globalStats"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Tuple(
                                        ::std::vec![
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Array(
                                                ::std::boxed::Box::new(
                                                    ::ethers::core::abi::ethabi::ParamType::Address,
                                                ),
                                            ),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                        ],
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "struct LibStakingStorage.RewardEpochGlobalStats",
                                        ),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("calculateStakeWeight"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "calculateStakeWeight",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("timeLock"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("amount"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned(
                        "checkActiveOrUnlockedOrPausedState",
                    ),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "checkActiveOrUnlockedOrPausedState",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("state"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(8usize),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "enum LibStakingStorage.States",
                                        ),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::Pure,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("checkStakingAmounts"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "checkStakingAmounts",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("stakerAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bool,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bool"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("checkVersion"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("checkVersion"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("realmId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("version"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Tuple(
                                        ::std::vec![
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                        ],
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "struct LibStakingStorage.Version",
                                        ),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bool,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bool"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("claimFixedCostRewards"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "claimFixedCostRewards",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("realmId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "maxNumberOfEpochsToClaim",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("claimStakeRewards"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("claimStakeRewards"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("realmId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("stakerAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("stakeRecordId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "maxNumberOfEpochsToClaim",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("claimValidatorCommission"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "claimValidatorCommission",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("realmId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "maxNumberOfEpochsToClaim",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("complaintConfig"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("complaintConfig"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("reason"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Tuple(
                                        ::std::vec![
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                        ],
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "struct LibStakingStorage.ComplaintConfig",
                                        ),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("contractResolver"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("contractResolver"),
                            inputs: ::std::vec![],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned(
                        "countOfCurrentValidatorsReadyForNextEpoch",
                    ),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "countOfCurrentValidatorsReadyForNextEpoch",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("realmId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned(
                        "countOfNextValidatorsReadyForNextEpoch",
                    ),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "countOfNextValidatorsReadyForNextEpoch",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("realmId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned(
                        "currentValidatorCountForConsensus",
                    ),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "currentValidatorCountForConsensus",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("realmId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("decreaseRewardPool"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("decreaseRewardPool"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("realmId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("amount"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("deleteKeySet"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("deleteKeySet"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("identifier"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::String,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("string"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("diamondCut"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("diamondCut"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("_diamondCut"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Tuple(
                                                ::std::vec![
                                                    ::ethers::core::abi::ethabi::ParamType::Address,
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(8usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Array(
                                                        ::std::boxed::Box::new(
                                                            ::ethers::core::abi::ethabi::ParamType::FixedBytes(4usize),
                                                        ),
                                                    ),
                                                ],
                                            ),
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "struct IDiamond.FacetCut[]",
                                        ),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("_init"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("_calldata"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bytes,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bytes"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("emitClearOfflinePhaseData"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "emitClearOfflinePhaseData",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("dataType"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("emitCountOfflinePhaseData"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "emitCountOfflinePhaseData",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("dataType"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("epoch"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("epoch"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("realmId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Tuple(
                                        ::std::vec![
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                        ],
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "struct LibStakingStorage.Epoch",
                                        ),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("excludeArtifacts"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("excludeArtifacts"),
                            inputs: ::std::vec![],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "excludedArtifacts_",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::String,
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("string[]"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("excludeContracts"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("excludeContracts"),
                            inputs: ::std::vec![],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "excludedContracts_",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address[]"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("excludeSelectors"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("excludeSelectors"),
                            inputs: ::std::vec![],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "excludedSelectors_",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Tuple(
                                                ::std::vec![
                                                    ::ethers::core::abi::ethabi::ParamType::Address,
                                                    ::ethers::core::abi::ethabi::ParamType::Array(
                                                        ::std::boxed::Box::new(
                                                            ::ethers::core::abi::ethabi::ParamType::FixedBytes(4usize),
                                                        ),
                                                    ),
                                                ],
                                            ),
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "struct StdInvariant.FuzzSelector[]",
                                        ),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("excludeSenders"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("excludeSenders"),
                            inputs: ::std::vec![],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("excludedSenders_"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address[]"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("exit"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("exit"),
                            inputs: ::std::vec![],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::Pure,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("facetAddress"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("facetAddress"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("_functionSelector"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::FixedBytes(
                                        4usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bytes4"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("facetAddress_"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("facetAddresses"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("facetAddresses"),
                            inputs: ::std::vec![],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("facetAddresses_"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address[]"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("facetFunctionSelectors"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "facetFunctionSelectors",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("_facet"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "_facetFunctionSelectors",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::FixedBytes(4usize),
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bytes4[]"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("facets"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("facets"),
                            inputs: ::std::vec![],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("facets_"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Tuple(
                                                ::std::vec![
                                                    ::ethers::core::abi::ethabi::ParamType::Address,
                                                    ::ethers::core::abi::ethabi::ParamType::Array(
                                                        ::std::boxed::Box::new(
                                                            ::ethers::core::abi::ethabi::ParamType::FixedBytes(4usize),
                                                        ),
                                                    ),
                                                ],
                                            ),
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "struct IDiamondLoupe.Facet[]",
                                        ),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("failed"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("failed"),
                            inputs: ::std::vec![],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bool,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bool"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("getActiveUnkickedValidatorCount"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "getActiveUnkickedValidatorCount",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("realmId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                )
        ]
        )
        }
        
        
        
#[allow(deprecated)]
        fn __abi_functions_2() -> std::collections::BTreeMap<String, Vec<::ethers::core::abi::ethabi::Function>> {
        
        std::collections::BTreeMap::from(
        [
        (
                    ::std::borrow::ToOwned::to_owned(
                        "getActiveUnkickedValidatorStructs",
                    ),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "getActiveUnkickedValidatorStructs",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("realmId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Tuple(
                                                ::std::vec![
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(32usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(128usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(32usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Address,
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Address,
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Bool,
                                                ],
                                            ),
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "struct LibStakingStorage.Validator[]",
                                        ),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned(
                        "getActiveUnkickedValidatorStructsAndCounts",
                    ),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "getActiveUnkickedValidatorStructsAndCounts",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("realmId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Tuple(
                                        ::std::vec![
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                        ],
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "struct LibStakingStorage.Epoch",
                                        ),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Tuple(
                                                ::std::vec![
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(32usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(128usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(32usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Address,
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Address,
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Bool,
                                                ],
                                            ),
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "struct LibStakingStorage.Validator[]",
                                        ),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("getActiveUnkickedValidators"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "getActiveUnkickedValidators",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("realmId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address[]"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("getAllReserveValidators"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "getAllReserveValidators",
                            ),
                            inputs: ::std::vec![],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address[]"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("getAllUnkickedValidators"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "getAllUnkickedValidators",
                            ),
                            inputs: ::std::vec![],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address[]"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("getAllValidators"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("getAllValidators"),
                            inputs: ::std::vec![],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address[]"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("getApproved"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("getApproved"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("tokenId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("getAttestedPubKey"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("getAttestedPubKey"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("attestedAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bytes,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bytes"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned(
                        "getCurrentRealmIdForStakerAddress",
                    ),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "getCurrentRealmIdForStakerAddress",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("stakerAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned(
                        "getDelegatedStakersWithUnfreezingStakes",
                    ),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "getDelegatedStakersWithUnfreezingStakes",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("validatorAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("limit"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("offset"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address[]"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned(
                        "getDelegatedStakersWithUnfreezingStakesCount",
                    ),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "getDelegatedStakersWithUnfreezingStakesCount",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("validatorAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("getEmptyStakeRecordSlots"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "getEmptyStakeRecordSlots",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("userStakerAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "operatorStakerAddress",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("getKeySet"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("getKeySet"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("identifier"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::String,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("string"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Tuple(
                                        ::std::vec![
                                            ::ethers::core::abi::ethabi::ParamType::Uint(32usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(32usize),
                                            ::ethers::core::abi::ethabi::ParamType::Bool,
                                            ::ethers::core::abi::ethabi::ParamType::String,
                                            ::ethers::core::abi::ethabi::ParamType::String,
                                            ::ethers::core::abi::ethabi::ParamType::Array(
                                                ::std::boxed::Box::new(
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                ),
                                            ),
                                            ::ethers::core::abi::ethabi::ParamType::Array(
                                                ::std::boxed::Box::new(
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                ),
                                            ),
                                            ::ethers::core::abi::ethabi::ParamType::Array(
                                                ::std::boxed::Box::new(
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                ),
                                            ),
                                            ::ethers::core::abi::ethabi::ParamType::Array(
                                                ::std::boxed::Box::new(
                                                    ::ethers::core::abi::ethabi::ParamType::Address,
                                                ),
                                            ),
                                        ],
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "struct LibStakingStorage.KeySetConfig",
                                        ),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("getKeyTypes"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("getKeyTypes"),
                            inputs: ::std::vec![],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256[]"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("getKickedValidators"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "getKickedValidators",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("realmId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address[]"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("getLastStakeRecord"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("getLastStakeRecord"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("user"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("stakerAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Tuple(
                                        ::std::vec![
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Bool,
                                            ::ethers::core::abi::ethabi::ParamType::Bool,
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                        ],
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "struct LibStakingStorage.StakeRecord",
                                        ),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("getLitCirc"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("getLitCirc"),
                            inputs: ::std::vec![],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("getLowestRewardEpochNumber"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "getLowestRewardEpochNumber",
                            ),
                            inputs: ::std::vec![],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("getMaxVersion"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("getMaxVersion"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("realmId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Tuple(
                                        ::std::vec![
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                        ],
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "struct LibStakingStorage.Version",
                                        ),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("getMaxVersionString"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "getMaxVersionString",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("realmId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::String,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("string"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("getMaximumStake"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("getMaximumStake"),
                            inputs: ::std::vec![],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("getMinVersion"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("getMinVersion"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("realmId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Tuple(
                                        ::std::vec![
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                        ],
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "struct LibStakingStorage.Version",
                                        ),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("getMinVersionString"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "getMinVersionString",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("realmId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::String,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("string"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("getMinimumSelfStake"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "getMinimumSelfStake",
                            ),
                            inputs: ::std::vec![],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("getMinimumStake"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("getMinimumStake"),
                            inputs: ::std::vec![],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("getMostRecentStakeRecord"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "getMostRecentStakeRecord",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("userStakerAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "operatorStakerAddress",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Tuple(
                                        ::std::vec![
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Bool,
                                            ::ethers::core::abi::ethabi::ParamType::Bool,
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                        ],
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "struct LibStakingStorage.StakeRecord",
                                        ),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("getNodeAttestedPubKeyMappings"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "getNodeAttestedPubKeyMappings",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("addresses"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address[]"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Tuple(
                                                ::std::vec![
                                                    ::ethers::core::abi::ethabi::ParamType::Address,
                                                    ::ethers::core::abi::ethabi::ParamType::Tuple(
                                                        ::std::vec![
                                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                        ],
                                                    ),
                                                ],
                                            ),
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "struct LibStakingStorage.PubKeyMapping[]",
                                        ),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("getNodeDemerits"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("getNodeDemerits"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("stakerAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("getNodeStakerAddressMappings"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "getNodeStakerAddressMappings",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("addresses"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address[]"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Tuple(
                                                ::std::vec![
                                                    ::ethers::core::abi::ethabi::ParamType::Address,
                                                    ::ethers::core::abi::ethabi::ParamType::Address,
                                                ],
                                            ),
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "struct LibStakingStorage.AddressMapping[]",
                                        ),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("getNonShadowValidators"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "getNonShadowValidators",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("realmId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address[]"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned(
                        "getNonShadowValidatorsInCurrentEpochLength",
                    ),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "getNonShadowValidatorsInCurrentEpochLength",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("realmId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("getRealmIdForStakerAddress"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "getRealmIdForStakerAddress",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("stakerAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("getRewardEpoch"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("getRewardEpoch"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("stakerAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("rewardEpochNumber"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Tuple(
                                        ::std::vec![
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Bool,
                                        ],
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "struct LibStakingStorage.RewardEpoch",
                                        ),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("getRewardEpochGlobalStats"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "getRewardEpochGlobalStats",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("epochNumber"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Tuple(
                                        ::std::vec![
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Array(
                                                ::std::boxed::Box::new(
                                                    ::ethers::core::abi::ethabi::ParamType::Address,
                                                ),
                                            ),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                        ],
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "struct LibStakingStorage.RewardEpochGlobalStats",
                                        ),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("getRewardEpochNumber"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "getRewardEpochNumber",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("realmId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("getRewardEpochView"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("getRewardEpochView"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("stakerAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("rewardEpochNumber"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Tuple(
                                        ::std::vec![
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Bool,
                                        ],
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "struct LibStakingStorage.RewardEpoch",
                                        ),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("getSelfStakeRecordCount"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "getSelfStakeRecordCount",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("stakerAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("getShadowRealmIdForStakerAddress"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "getShadowRealmIdForStakerAddress",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("stakerAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("getShadowValidators"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "getShadowValidators",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("realmId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address[]"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("getStakeRecord"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("getStakeRecord"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("stakerAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("recordId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("userStakerAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Tuple(
                                        ::std::vec![
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Bool,
                                            ::ethers::core::abi::ethabi::ParamType::Bool,
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                        ],
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "struct LibStakingStorage.StakeRecord",
                                        ),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("getStakeRecordCount"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "getStakeRecordCount",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("userStakerAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "operatorStakerAddress",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("getStakeRecordsForUser"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "getStakeRecordsForUser",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("userStakerAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "operatorStakerAddress",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Tuple(
                                                ::std::vec![
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Bool,
                                                    ::ethers::core::abi::ethabi::ParamType::Bool,
                                                    ::ethers::core::abi::ethabi::ParamType::Address,
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                ],
                                            ),
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "struct LibStakingStorage.StakeRecord[]",
                                        ),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("getStakeWeightInEpoch"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "getStakeWeightInEpoch",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("stakerAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("recordId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("userStakerAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("rewardEpochNumber"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("getThreshold"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("getThreshold"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("nodeCount"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("getTimelockInEpoch"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("getTimelockInEpoch"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("stakerAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("stakeRecord"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Tuple(
                                        ::std::vec![
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Bool,
                                            ::ethers::core::abi::ethabi::ParamType::Bool,
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                        ],
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "struct LibStakingStorage.StakeRecord",
                                        ),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("rewardEpochNumber"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("getTokenContractAddress"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "getTokenContractAddress",
                            ),
                            inputs: ::std::vec![],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("getTokenPrice"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("getTokenPrice"),
                            inputs: ::std::vec![],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("getTokensStaked"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("getTokensStaked"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("stakerAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("stakeRecord"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Tuple(
                                        ::std::vec![
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Bool,
                                            ::ethers::core::abi::ethabi::ParamType::Bool,
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                        ],
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "struct LibStakingStorage.StakeRecord",
                                        ),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("rewardEpochNumber"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("getTotalStake"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("getTotalStake"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("stakerAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("getTotalStakeByUser"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "getTotalStakeByUser",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("stakerAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("user"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                )
        ]
        )
        }
        
        
        
#[allow(deprecated)]
        fn __abi_functions_3() -> std::collections::BTreeMap<String, Vec<::ethers::core::abi::ethabi::Function>> {
        
        std::collections::BTreeMap::from(
        [
        (
                    ::std::borrow::ToOwned::to_owned("getTrustedForwarder"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "getTrustedForwarder",
                            ),
                            inputs: ::std::vec![],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("getUnfrozenStakeCountForUser"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "getUnfrozenStakeCountForUser",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("userStakerAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "operatorStakerAddress",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("getValidatorsDelegated"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "getValidatorsDelegated",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("user"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256[]"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("getValidatorsInCurrentEpoch"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "getValidatorsInCurrentEpoch",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("realmId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address[]"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("getValidatorsInNextEpoch"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "getValidatorsInNextEpoch",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("realmId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address[]"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("getValidatorsStructs"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "getValidatorsStructs",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("stakerAddresses"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address[]"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Tuple(
                                                ::std::vec![
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(32usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(128usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(32usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Address,
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Address,
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Bool,
                                                ],
                                            ),
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "struct LibStakingStorage.Validator[]",
                                        ),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned(
                        "getValidatorsStructsInCurrentEpoch",
                    ),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "getValidatorsStructsInCurrentEpoch",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("realmId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Tuple(
                                                ::std::vec![
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(32usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(128usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(32usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Address,
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Address,
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Bool,
                                                ],
                                            ),
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "struct LibStakingStorage.Validator[]",
                                        ),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("getValidatorsStructsInNextEpoch"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "getValidatorsStructsInNextEpoch",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("realmId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Tuple(
                                                ::std::vec![
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(32usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(128usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(32usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Address,
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Address,
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Bool,
                                                ],
                                            ),
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "struct LibStakingStorage.Validator[]",
                                        ),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("getVotingStatusToKickValidator"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "getVotingStatusToKickValidator",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("realmId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("epochNumber"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "validatorToBeKickedStakerAddress",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "voterStakerAddress",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bool,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bool"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("globalConfig"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("globalConfig"),
                            inputs: ::std::vec![],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Tuple(
                                        ::std::vec![
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Array(
                                                ::std::boxed::Box::new(
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                ),
                                            ),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Bool,
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                        ],
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "struct LibStakingStorage.GlobalConfig",
                                        ),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("increaseRewardPool"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("increaseRewardPool"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("realmId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("amount"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("increaseStakeRecordAmount"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "increaseStakeRecordAmount",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("stakerAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("stakeRecordId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("additionalAmount"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("increaseStakeRecordTimelock"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "increaseStakeRecordTimelock",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("stakerAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("stakeRecordId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "additionalTimeLock",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("initializeRewardEpoch"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "initializeRewardEpoch",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("stakerAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("rewardEpochNumber"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("isInitial"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bool,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bool"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("isActiveShadowValidator"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "isActiveShadowValidator",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("realmId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("stakerAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bool,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bool"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("isActiveValidator"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("isActiveValidator"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("realmId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("stakerAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bool,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bool"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("isActiveValidatorByNodeAddress"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "isActiveValidatorByNodeAddress",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("realmId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("account"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bool,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bool"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned(
                        "isActiveValidatorByNodeAddressForNextEpoch",
                    ),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "isActiveValidatorByNodeAddressForNextEpoch",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("realmId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("nodeAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bool,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bool"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("isActiveValidatorForNextEpoch"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "isActiveValidatorForNextEpoch",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("realmId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("stakerAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bool,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bool"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("isApprovedForAll"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("isApprovedForAll"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("owner"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("operator"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bool,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bool"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("isReadyForNextEpoch"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "isReadyForNextEpoch",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("realmId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bool,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bool"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("isRecentValidator"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("isRecentValidator"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("nodeAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bool,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bool"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("isRecentValidator"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("realmId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("stakerAddresses"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bool,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bool"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("isValidatorBanned"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("isValidatorBanned"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("validator"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bool,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bool"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("isValidatorInCurrentEpoch"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "isValidatorInCurrentEpoch",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("stakerAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bool,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bool"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("isValidatorInCurrentOrNextEpoch"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "isValidatorInCurrentOrNextEpoch",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("stakerAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bool,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bool"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("isValidatorInNextEpoch"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "isValidatorInNextEpoch",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("stakerAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bool,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bool"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("keySets"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("keySets"),
                            inputs: ::std::vec![],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Tuple(
                                                ::std::vec![
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(32usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(32usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Bool,
                                                    ::ethers::core::abi::ethabi::ParamType::String,
                                                    ::ethers::core::abi::ethabi::ParamType::String,
                                                    ::ethers::core::abi::ethabi::ParamType::Array(
                                                        ::std::boxed::Box::new(
                                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                        ),
                                                    ),
                                                    ::ethers::core::abi::ethabi::ParamType::Array(
                                                        ::std::boxed::Box::new(
                                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                        ),
                                                    ),
                                                    ::ethers::core::abi::ethabi::ParamType::Array(
                                                        ::std::boxed::Box::new(
                                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                        ),
                                                    ),
                                                    ::ethers::core::abi::ethabi::ParamType::Array(
                                                        ::std::boxed::Box::new(
                                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                                        ),
                                                    ),
                                                ],
                                            ),
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "struct LibStakingStorage.KeySetConfig[]",
                                        ),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("kickPenaltyPercentByReason"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "kickPenaltyPercentByReason",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("reason"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("kickValidatorInNextEpoch"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "kickValidatorInNextEpoch",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "validatorToKickStakerAddress",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("reason"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("data"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bytes,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bytes"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("litActionsConfig"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("litActionsConfig"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("realmId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Tuple(
                                        ::std::vec![
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Bool,
                                        ],
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "struct LibStakingStorage.LitActionConfig",
                                        ),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("lockValidatorsForNextEpoch"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "lockValidatorsForNextEpoch",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("realmId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("maxStake"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("maxStake"),
                            inputs: ::std::vec![],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("maxTimeLock"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("maxTimeLock"),
                            inputs: ::std::vec![],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("migrateStakeRecord"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("migrateStakeRecord"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "operatorAddressToMigrateFrom",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("stakeRecordId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "operatorAddressToMigrateTo",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("minSelfStake"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("minSelfStake"),
                            inputs: ::std::vec![],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("minStake"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("minStake"),
                            inputs: ::std::vec![],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("minTimeLock"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("minTimeLock"),
                            inputs: ::std::vec![],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("nextValidatorCountForConsensus"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "nextValidatorCountForConsensus",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("realmId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("nodeAddressToStakerAddress"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "nodeAddressToStakerAddress",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("nodeAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned(
                        "nodeAddressToStakerAddressAcrossRealms",
                    ),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "nodeAddressToStakerAddressAcrossRealms",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("nodeAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("numRealms"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("numRealms"),
                            inputs: ::std::vec![],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("operatorAddressToStakerAddress"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "operatorAddressToStakerAddress",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("operatorAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("owner"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("owner"),
                            inputs: ::std::vec![],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("owner_"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("ownerOf"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("ownerOf"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("tokenId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("ownershipChange"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("ownershipChange"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("tokenId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("permittedRealmsForValidator"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "permittedRealmsForValidator",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("validator"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256[]"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("permittedValidators"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "permittedValidators",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("realmId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address[]"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("pow"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("pow"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("base"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("exponent"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::Pure,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("readyForNextEpoch"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("readyForNextEpoch"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("realmId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("stakerAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bool,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bool"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("realmConfig"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("realmConfig"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("realmId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Tuple(
                                        ::std::vec![
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Bool,
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Bool,
                                        ],
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "struct LibStakingStorage.RealmConfig",
                                        ),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                )
        ]
        )
        }
        
        
        
#[allow(deprecated)]
        fn __abi_functions_4() -> std::collections::BTreeMap<String, Vec<::ethers::core::abi::ethabi::Function>> {
        
        std::collections::BTreeMap::from(
        [
        (
                    ::std::borrow::ToOwned::to_owned("registerAttestedWallet"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "registerAttestedWallet",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("stakerAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("attestedAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("attestedPubKey"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bytes,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bytes"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("senderPubKey"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("receiverPubKey"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("removeRealm"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("removeRealm"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("realmId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("requestToJoin"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("requestToJoin"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("realmId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("requestToJoinAsAdmin"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "requestToJoinAsAdmin",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("realmId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("stakerAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("requestToJoinAsForShadowSplicing"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "requestToJoinAsForShadowSplicing",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("realmId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("stakerAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("requestToJoinAsNode"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "requestToJoinAsNode",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("realmId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("stakerAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("requestToLeave"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("requestToLeave"),
                            inputs: ::std::vec![],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("requestToLeaveAsNode"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "requestToLeaveAsNode",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("realmId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("safeTransferFrom"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("safeTransferFrom"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("from"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("to"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("tokenId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("safeTransferFrom"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("from"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("to"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("tokenId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("data"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bytes,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bytes"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("selfStakeBalanceOf"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("selfStakeBalanceOf"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("stakerAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("setApprovalForAll"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("setApprovalForAll"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("operator"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("approved"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bool,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bool"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("setComplaintConfig"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("setComplaintConfig"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("reason"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("config"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Tuple(
                                        ::std::vec![
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                        ],
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "struct LibStakingStorage.ComplaintConfig",
                                        ),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("setConfig"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("setConfig"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("newConfig"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Tuple(
                                        ::std::vec![
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Array(
                                                ::std::boxed::Box::new(
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                ),
                                            ),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Bool,
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                        ],
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "struct LibStakingStorage.GlobalConfig",
                                        ),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("setContractResolver"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "setContractResolver",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "newResolverAddress",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("setDemeritRejoinThreshold"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "setDemeritRejoinThreshold",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("newThreshold"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("setDevopsAdmin"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("setDevopsAdmin"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("newDevopsAdmin"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("setEpochEndTime"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("setEpochEndTime"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("realmId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("newEpochEndTime"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("setEpochLength"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("setEpochLength"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("realmId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("newEpochLength"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("setEpochState"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("setEpochState"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("realmId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("newState"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(8usize),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "enum LibStakingStorage.States",
                                        ),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("setEpochTimeout"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("setEpochTimeout"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("realmId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("newEpochTimeout"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("setIpPortNodeAddress"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "setIpPortNodeAddress",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("ip"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(32usize),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint32"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("ipv6"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        128usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint128"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("port"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(32usize),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint32"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("operatorAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("setKeySet"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("setKeySet"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("update"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Tuple(
                                        ::std::vec![
                                            ::ethers::core::abi::ethabi::ParamType::Uint(32usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(32usize),
                                            ::ethers::core::abi::ethabi::ParamType::Bool,
                                            ::ethers::core::abi::ethabi::ParamType::String,
                                            ::ethers::core::abi::ethabi::ParamType::String,
                                            ::ethers::core::abi::ethabi::ParamType::Array(
                                                ::std::boxed::Box::new(
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                ),
                                            ),
                                            ::ethers::core::abi::ethabi::ParamType::Array(
                                                ::std::boxed::Box::new(
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                ),
                                            ),
                                            ::ethers::core::abi::ethabi::ParamType::Array(
                                                ::std::boxed::Box::new(
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                ),
                                            ),
                                            ::ethers::core::abi::ethabi::ParamType::Array(
                                                ::std::boxed::Box::new(
                                                    ::ethers::core::abi::ethabi::ParamType::Address,
                                                ),
                                            ),
                                        ],
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "struct LibStakingStorage.KeySetConfig",
                                        ),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("setLitActionConfig"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("setLitActionConfig"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("realmId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("newConfig"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Tuple(
                                        ::std::vec![
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Bool,
                                        ],
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "struct LibStakingStorage.LitActionConfig",
                                        ),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("setMaxVersion"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("setMaxVersion"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("realmId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("version"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Tuple(
                                        ::std::vec![
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                        ],
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "struct LibStakingStorage.Version",
                                        ),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("setMinVersion"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("setMinVersion"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("realmId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("version"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Tuple(
                                        ::std::vec![
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                        ],
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "struct LibStakingStorage.Version",
                                        ),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("setPendingRejoinTimeout"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "setPendingRejoinTimeout",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("newTimeout"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("setPermittedValidators"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "setPermittedValidators",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("realmId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("validatorsToSet"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address[]"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("setPermittedValidatorsOn"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "setPermittedValidatorsOn",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("realmId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "permittedValidatorsOn",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bool,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bool"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("setRealmConfig"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("setRealmConfig"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("realmId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("newConfig"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Tuple(
                                        ::std::vec![
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Bool,
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Bool,
                                        ],
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "struct LibStakingStorage.RealmConfig",
                                        ),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("setTokenTotalSupplyStandIn"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "setTokenTotalSupplyStandIn",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("newTotalSupply"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("setTrustedForwarder"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "setTrustedForwarder",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("forwarder"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("setUp"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("setUp"),
                            inputs: ::std::vec![],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("setValidatorCommissionRate"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "setValidatorCommissionRate",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("rate"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("shouldKickValidator"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "shouldKickValidator",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("realmId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("stakerAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bool,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bool"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("signalReadyForNextEpoch"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "signalReadyForNextEpoch",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("realmId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("epochNumber"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("splitStakeRecord"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("splitStakeRecord"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("stakerAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("stakeRecordId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("ratio"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("stake"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("stake"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("amount"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("timeLock"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "operatorStakerAddress",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("stakerToValidatorsTheyStakedTo"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "stakerToValidatorsTheyStakedTo",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("staker"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address[]"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("state"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("state"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("realmId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(8usize),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "enum LibStakingStorage.States",
                                        ),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("supportsInterface"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("supportsInterface"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("_interfaceId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::FixedBytes(
                                        4usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bytes4"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bool,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bool"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("targetArtifactSelectors"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "targetArtifactSelectors",
                            ),
                            inputs: ::std::vec![],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "targetedArtifactSelectors_",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Tuple(
                                                ::std::vec![
                                                    ::ethers::core::abi::ethabi::ParamType::String,
                                                    ::ethers::core::abi::ethabi::ParamType::Array(
                                                        ::std::boxed::Box::new(
                                                            ::ethers::core::abi::ethabi::ParamType::FixedBytes(4usize),
                                                        ),
                                                    ),
                                                ],
                                            ),
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "struct StdInvariant.FuzzArtifactSelector[]",
                                        ),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("targetArtifacts"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("targetArtifacts"),
                            inputs: ::std::vec![],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "targetedArtifacts_",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::String,
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("string[]"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("targetContracts"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("targetContracts"),
                            inputs: ::std::vec![],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "targetedContracts_",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address[]"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("targetInterfaces"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("targetInterfaces"),
                            inputs: ::std::vec![],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "targetedInterfaces_",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Tuple(
                                                ::std::vec![
                                                    ::ethers::core::abi::ethabi::ParamType::Address,
                                                    ::ethers::core::abi::ethabi::ParamType::Array(
                                                        ::std::boxed::Box::new(
                                                            ::ethers::core::abi::ethabi::ParamType::String,
                                                        ),
                                                    ),
                                                ],
                                            ),
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "struct StdInvariant.FuzzInterface[]",
                                        ),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("targetSelectors"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("targetSelectors"),
                            inputs: ::std::vec![],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "targetedSelectors_",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Tuple(
                                                ::std::vec![
                                                    ::ethers::core::abi::ethabi::ParamType::Address,
                                                    ::ethers::core::abi::ethabi::ParamType::Array(
                                                        ::std::boxed::Box::new(
                                                            ::ethers::core::abi::ethabi::ParamType::FixedBytes(4usize),
                                                        ),
                                                    ),
                                                ],
                                            ),
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "struct StdInvariant.FuzzSelector[]",
                                        ),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("targetSenders"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("targetSenders"),
                            inputs: ::std::vec![],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("targetedSenders_"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address[]"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("test_Stake"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("test_Stake"),
                            inputs: ::std::vec![],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("test_StakeAndTransfer"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "test_StakeAndTransfer",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("isSafeTransfer"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bool,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bool"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned(
                        "test_StakeAndTransfer_ClaimRewards",
                    ),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "test_StakeAndTransfer_ClaimRewards",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("isSafeTransfer"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bool,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bool"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned(
                        "test_StakeAndTransfer_ReceiverMutatesStakeRecord",
                    ),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "test_StakeAndTransfer_ReceiverMutatesStakeRecord",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("isSafeTransfer"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bool,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bool"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("operation"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                )
        ]
        )
        }
        
        
        
#[allow(deprecated)]
        fn __abi_functions_5() -> std::collections::BTreeMap<String, Vec<::ethers::core::abi::ethabi::Function>> {
        
        std::collections::BTreeMap::from(
        [
        (
                    ::std::borrow::ToOwned::to_owned(
                        "test_StakeAndTransfer_RevertNotOwner",
                    ),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "test_StakeAndTransfer_RevertNotOwner",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("isSafeTransfer"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bool,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bool"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned(
                        "test_StakeAndTransfer_TokenOwnerByIndex",
                    ),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "test_StakeAndTransfer_TokenOwnerByIndex",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("isSafeTransfer"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bool,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bool"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("test_StakeAndTransfer_Withdraw"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "test_StakeAndTransfer_Withdraw",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("isSafeTransfer"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bool,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bool"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "isUnfreezeBeforeTransfer",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bool,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bool"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("test_StakeApproveAndTransfer"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "test_StakeApproveAndTransfer",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("isSafeTransfer"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bool,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bool"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned(
                        "test_StakeApproveForAllAndTransfer",
                    ),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "test_StakeApproveForAllAndTransfer",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("isSafeTransfer"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bool,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bool"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("test_StakeMax_TransferShouldFail"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "test_StakeMax_TransferShouldFail",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("isSafeTransfer"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bool,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bool"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("test_Stake_MutateStakeRecord"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "test_Stake_MutateStakeRecord",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("operation"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("tokenOfOwnerByIndex"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "tokenOfOwnerByIndex",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("owner"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("index"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("tokenToStakeRecord"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("tokenToStakeRecord"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("tokenId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Tuple(
                                        ::std::vec![
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                        ],
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "struct LibStakingStorage.MappedStakeRecord",
                                        ),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("totalSupply"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("totalSupply"),
                            inputs: ::std::vec![],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("transferFrom"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("transferFrom"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("from"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("to"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("tokenId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("transferOwnership"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("transferOwnership"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("_newOwner"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("unfreezeStake"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("unfreezeStake"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "operatorStakerAddress",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("stakeId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("validatorSelfStakeWillExpire"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "validatorSelfStakeWillExpire",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("realmId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("stakerAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "stakerInCurrentValidatorSet",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bool,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bool"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bool,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bool"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("validator_by_staker_address"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "validator_by_staker_address",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("stakerAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Tuple(
                                        ::std::vec![
                                            ::ethers::core::abi::ethabi::ParamType::Uint(32usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(128usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(32usize),
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Bool,
                                        ],
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "struct LibStakingStorage.Validator",
                                        ),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("validators"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("validators"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("stakerAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Tuple(
                                        ::std::vec![
                                            ::ethers::core::abi::ethabi::ParamType::Uint(32usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(128usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(32usize),
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Bool,
                                        ],
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "struct LibStakingStorage.Validator",
                                        ),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("verifyKeySetCounts"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("verifyKeySetCounts"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("identifier"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::String,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("string"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("newRootKeys"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Tuple(
                                                ::std::vec![
                                                    ::ethers::core::abi::ethabi::ParamType::Bytes,
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                ],
                                            ),
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "struct IPubkeyRouter.RootKey[]",
                                        ),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("withdraw"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("withdraw"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "operatorStakerAddress",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("stakeRecordId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
            ]
        )
        }
        
        
        
#[allow(deprecated)]
        fn __abi_events() -> std::collections::BTreeMap<String, Vec<::ethers::core::abi::ethabi::Event>> {
        let mut abi_events = __abi_events_1();
abi_events.append(&mut __abi_events_2()); 

        std::collections::BTreeMap::from(
        abi_events
        )
        }
        
        #[allow(deprecated)]
        fn __abi_events_1() -> std::collections::BTreeMap<String, Vec<::ethers::core::abi::ethabi::Event>> {
        
        std::collections::BTreeMap::from(
        [
                (
                    ::std::borrow::ToOwned::to_owned("AdvancedEpoch"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned("AdvancedEpoch"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("realmId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: false,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("epochNumber"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("Approval"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned("Approval"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("owner"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("approved"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("tokenId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: true,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("ApprovalForAll"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned("ApprovalForAll"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("owner"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("operator"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("approved"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bool,
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("AttestedWalletRegistered"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned(
                                "AttestedWalletRegistered",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("staker"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("attestedAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("attestedPubKey"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Tuple(
                                        ::std::vec![
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                        ],
                                    ),
                                    indexed: true,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("ClearOfflinePhaseData"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned(
                                "ClearOfflinePhaseData",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("dataType"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("ComplaintConfigSet"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned("ComplaintConfigSet"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("reason"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: false,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("config"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Tuple(
                                        ::std::vec![
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                        ],
                                    ),
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("ConfigSet"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned("ConfigSet"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "newTokenRewardPerTokenPerEpoch",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: false,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("newKeyTypes"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                        ),
                                    ),
                                    indexed: false,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "newMinimumValidatorCount",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: false,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "newMaxConcurrentRequests",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: false,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "newMaxPresignCount",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: false,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "newMinPresignCount",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: false,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "newPeerCheckingIntervalSecs",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: false,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "newMaxPresignConcurrency",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: false,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "newRpcHealthcheckEnabled",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bool,
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("CountOfflinePhaseData"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned(
                                "CountOfflinePhaseData",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("dataType"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("DebugEvent"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned("DebugEvent"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("message"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::String,
                                    indexed: false,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("sender"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: false,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("value"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("DevopsAdminSet"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned("DevopsAdminSet"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("newDevopsAdmin"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("DiamondCut"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned("DiamondCut"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("_diamondCut"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Tuple(
                                                ::std::vec![
                                                    ::ethers::core::abi::ethabi::ParamType::Address,
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(8usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Array(
                                                        ::std::boxed::Box::new(
                                                            ::ethers::core::abi::ethabi::ParamType::FixedBytes(4usize),
                                                        ),
                                                    ),
                                                ],
                                            ),
                                        ),
                                    ),
                                    indexed: false,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("_init"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: false,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("_calldata"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bytes,
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("EpochEndTimeSet"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned("EpochEndTimeSet"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("realmId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: false,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("newEpochEndTime"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("EpochLengthSet"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned("EpochLengthSet"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("realmId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: false,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("newEpochLength"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("EpochTimeoutSet"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned("EpochTimeoutSet"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("realmId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: false,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("newEpochTimeout"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("FixedCostRewardsClaimed"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned(
                                "FixedCostRewardsClaimed",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("stakerAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: false,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("rewards"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: false,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("fromEpoch"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: false,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("toEpoch"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("KeySetConfigSet"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned("KeySetConfigSet"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("exists"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bool,
                                    indexed: false,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("identifier"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::String,
                                    indexed: false,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("hashed"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::FixedBytes(
                                        32usize,
                                    ),
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("KeySetConfigUpdated"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned(
                                "KeySetConfigUpdated",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("identifier"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::String,
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("KickPenaltyPercentSet"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned(
                                "KickPenaltyPercentSet",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("reason"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: false,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "newKickPenaltyPercent",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("OwnershipTransferred"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned(
                                "OwnershipTransferred",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("previousOwner"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("newOwner"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("ReadyForNextEpoch"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned("ReadyForNextEpoch"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("staker"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("epochNumber"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("Recovered"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned("Recovered"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("token"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: false,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("amount"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("RequestToJoin"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned("RequestToJoin"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("validatorId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: true,
                                },
                            ],
                            anonymous: false,
                        },
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned("RequestToJoin"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("staker"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("RequestToLeave"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned("RequestToLeave"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("staker"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("ResolverContractAddressSet"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned(
                                "ResolverContractAddressSet",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "newResolverContractAddress",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("RewardsDurationUpdated"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned(
                                "RewardsDurationUpdated",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("newDuration"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("StakeRecordCreated"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned("StakeRecordCreated"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("stakerAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: false,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("recordId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: false,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("amount"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: false,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "stakerAddressClient",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("StakeRecordRemoved"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned("StakeRecordRemoved"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("userStakerAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: false,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("recordId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("StakeRecordUpdated"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned("StakeRecordUpdated"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("stakerAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: false,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("recordId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("StakeRewardsClaimed"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned(
                                "StakeRewardsClaimed",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("stakerAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: false,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("recordId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: false,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("rewards"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: false,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("fromEpoch"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: false,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("toEpoch"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned(
                                "StakeRewardsClaimed",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("validatorId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: false,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("recordId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: false,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("rewards"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("Staked"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned("Staked"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("staker"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("amount"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("StakingTokenSet"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned("StakingTokenSet"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "newStakingTokenAddress",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("StateChanged"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned("StateChanged"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("newState"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(8usize),
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("Transfer"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned("Transfer"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("from"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("to"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("tokenId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: true,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("TrustedForwarderSet"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned(
                                "TrustedForwarderSet",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "newTrustedForwarder",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("ValidatorBanned"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned("ValidatorBanned"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("staker"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("ValidatorCommissionClaimed"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned(
                                "ValidatorCommissionClaimed",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("stakerAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: false,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("rewards"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: false,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("fromEpoch"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: false,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("toEpoch"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("ValidatorKickedFromNextEpoch"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned(
                                "ValidatorKickedFromNextEpoch",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("staker"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("ValidatorRegistered"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned(
                                "ValidatorRegistered",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("stakerAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("ValidatorRejoinedNextEpoch"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned(
                                "ValidatorRejoinedNextEpoch",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("staker"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("VersionRequirementsUpdated"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned(
                                "VersionRequirementsUpdated",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("index"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: false,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("realmId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: false,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("version"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Tuple(
                                        ::std::vec![
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                        ],
                                    ),
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("VoteToAdvanceTimeOutElapsed"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned(
                                "VoteToAdvanceTimeOutElapsed",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("realmId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("VotedToKickValidatorInNextEpoch"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned(
                                "VotedToKickValidatorInNextEpoch",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("reporter"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "validatorToKickStakerAddress",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("reason"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("data"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bytes,
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("Withdrawn"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned("Withdrawn"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("staker"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("amount"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("log"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned("log"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::String,
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("log_address"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned("log_address"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("log_array"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned("log_array"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("val"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                        ),
                                    ),
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned("log_array"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("val"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Int(256usize),
                                        ),
                                    ),
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned("log_array"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("val"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                        ),
                                    ),
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("log_bytes"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned("log_bytes"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bytes,
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("log_bytes32"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned("log_bytes32"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::FixedBytes(
                                        32usize,
                                    ),
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("log_int"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned("log_int"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Int(256usize),
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("log_named_address"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned("log_named_address"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("key"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::String,
                                    indexed: false,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("val"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                )
        ]
        )
        }
        
        
        
#[allow(deprecated)]
        fn __abi_events_2() -> std::collections::BTreeMap<String, Vec<::ethers::core::abi::ethabi::Event>> {
        
        std::collections::BTreeMap::from(
        [
        (
                    ::std::borrow::ToOwned::to_owned("log_named_array"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned("log_named_array"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("key"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::String,
                                    indexed: false,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("val"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                        ),
                                    ),
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned("log_named_array"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("key"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::String,
                                    indexed: false,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("val"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Int(256usize),
                                        ),
                                    ),
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned("log_named_array"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("key"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::String,
                                    indexed: false,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("val"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                        ),
                                    ),
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("log_named_bytes"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned("log_named_bytes"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("key"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::String,
                                    indexed: false,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("val"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bytes,
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("log_named_bytes32"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned("log_named_bytes32"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("key"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::String,
                                    indexed: false,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("val"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::FixedBytes(
                                        32usize,
                                    ),
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("log_named_decimal_int"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned(
                                "log_named_decimal_int",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("key"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::String,
                                    indexed: false,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("val"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Int(256usize),
                                    indexed: false,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("decimals"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("log_named_decimal_uint"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned(
                                "log_named_decimal_uint",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("key"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::String,
                                    indexed: false,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("val"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: false,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("decimals"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("log_named_int"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned("log_named_int"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("key"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::String,
                                    indexed: false,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("val"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Int(256usize),
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("log_named_string"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned("log_named_string"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("key"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::String,
                                    indexed: false,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("val"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::String,
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("log_named_uint"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned("log_named_uint"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("key"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::String,
                                    indexed: false,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("val"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("log_string"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned("log_string"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::String,
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("log_uint"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned("log_uint"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("logs"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned("logs"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bytes,
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
            ]
        )
        }
        
        
        
#[allow(deprecated)]
        fn __abi_errors() -> std::collections::BTreeMap<String, Vec<::ethers::core::abi::ethabi::AbiError>> {
        let mut abi_errors = __abi_errors_1();
abi_errors.append(&mut __abi_errors_2()); 

        std::collections::BTreeMap::from(
        abi_errors
        )
        }
        
        #[allow(deprecated)]
        fn __abi_errors_1() -> std::collections::BTreeMap<String, Vec<::ethers::core::abi::ethabi::AbiError>> {
        
        std::collections::BTreeMap::from(
        [
                (
                    ::std::borrow::ToOwned::to_owned("ActiveValidatorsCannotLeave"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "ActiveValidatorsCannotLeave",
                            ),
                            inputs: ::std::vec![],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("CallerNotContract"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned("CallerNotContract"),
                            inputs: ::std::vec![],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("CallerNotOwner"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned("CallerNotOwner"),
                            inputs: ::std::vec![],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("CallerNotOwnerOrDevopsAdmin"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "CallerNotOwnerOrDevopsAdmin",
                            ),
                            inputs: ::std::vec![],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned(
                        "CannotAddFunctionToDiamondThatAlreadyExists",
                    ),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "CannotAddFunctionToDiamondThatAlreadyExists",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("_selector"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::FixedBytes(
                                        4usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bytes4"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("CannotAddSelectorsToZeroAddress"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "CannotAddSelectorsToZeroAddress",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("_selectors"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::FixedBytes(4usize),
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bytes4[]"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned(
                        "CannotKickBelowCurrentValidatorThreshold",
                    ),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "CannotKickBelowCurrentValidatorThreshold",
                            ),
                            inputs: ::std::vec![],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("CannotMigrateFromValidator"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "CannotMigrateFromValidator",
                            ),
                            inputs: ::std::vec![],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("CannotModifyUnfrozen"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "CannotModifyUnfrozen",
                            ),
                            inputs: ::std::vec![],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned(
                        "CannotMoveToLockedValidatorStateBeforeEpochEnds",
                    ),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "CannotMoveToLockedValidatorStateBeforeEpochEnds",
                            ),
                            inputs: ::std::vec![],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("CannotRejoinBecauseBanned"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "CannotRejoinBecauseBanned",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("stakingAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned(
                        "CannotRejoinUntilNextEpochBecauseKicked",
                    ),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "CannotRejoinUntilNextEpochBecauseKicked",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("stakingAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned(
                        "CannotRemoveFunctionThatDoesNotExist",
                    ),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "CannotRemoveFunctionThatDoesNotExist",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("_selector"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::FixedBytes(
                                        4usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bytes4"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("CannotRemoveImmutableFunction"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "CannotRemoveImmutableFunction",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("_selector"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::FixedBytes(
                                        4usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bytes4"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned(
                        "CannotReplaceFunctionThatDoesNotExists",
                    ),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "CannotReplaceFunctionThatDoesNotExists",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("_selector"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::FixedBytes(
                                        4usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bytes4"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned(
                        "CannotReplaceFunctionWithTheSameFunctionFromTheSameFacet",
                    ),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "CannotReplaceFunctionWithTheSameFunctionFromTheSameFacet",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("_selector"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::FixedBytes(
                                        4usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bytes4"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned(
                        "CannotReplaceFunctionsFromFacetWithZeroAddress",
                    ),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "CannotReplaceFunctionsFromFacetWithZeroAddress",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("_selectors"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::FixedBytes(4usize),
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bytes4[]"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("CannotReplaceImmutableFunction"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "CannotReplaceImmutableFunction",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("_selector"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::FixedBytes(
                                        4usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bytes4"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("CannotReuseCommsKeys"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "CannotReuseCommsKeys",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("senderPubKey"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("receiverPubKey"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("CannotStakeZero"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned("CannotStakeZero"),
                            inputs: ::std::vec![],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("CannotVoteTwice"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned("CannotVoteTwice"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("stakerAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("CannotWithdrawFrozen"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "CannotWithdrawFrozen",
                            ),
                            inputs: ::std::vec![],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("CannotWithdrawZero"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned("CannotWithdrawZero"),
                            inputs: ::std::vec![],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("CheckpointAheadOfCurrentEpoch"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "CheckpointAheadOfCurrentEpoch",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("checkpoint"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("currentEpoch"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned(
                        "CouldNotMapNodeAddressToStakerAddress",
                    ),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "CouldNotMapNodeAddressToStakerAddress",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("nodeAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("ERC721ReceiverRejectedTokens"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "ERC721ReceiverRejectedTokens",
                            ),
                            inputs: ::std::vec![],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned(
                        "ERC721TransferToNonERC721ReceiverImplementer",
                    ),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "ERC721TransferToNonERC721ReceiverImplementer",
                            ),
                            inputs: ::std::vec![],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("IncorrectFacetCutAction"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "IncorrectFacetCutAction",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("_action"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(8usize),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint8"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("InitializationFunctionReverted"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "InitializationFunctionReverted",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "_initializationContractAddress",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("_calldata"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bytes,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bytes"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("InsufficientSelfStake"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "InsufficientSelfStake",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("stakerAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("InvalidAttestedAddress"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "InvalidAttestedAddress",
                            ),
                            inputs: ::std::vec![],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("InvalidNewSharePrice"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "InvalidNewSharePrice",
                            ),
                            inputs: ::std::vec![],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("InvalidRatio"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned("InvalidRatio"),
                            inputs: ::std::vec![],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("InvalidSlashPercentage"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "InvalidSlashPercentage",
                            ),
                            inputs: ::std::vec![],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("InvalidTimeLock"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned("InvalidTimeLock"),
                            inputs: ::std::vec![],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("MinTimeLockNotMet"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned("MinTimeLockNotMet"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("timeLock"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("minTimeLock"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned(
                        "MustBeInActiveOrUnlockedOrPausedState",
                    ),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "MustBeInActiveOrUnlockedOrPausedState",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("state"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(8usize),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "enum LibStakingStorage.States",
                                        ),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("MustBeInActiveOrUnlockedState"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "MustBeInActiveOrUnlockedState",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("state"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(8usize),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "enum LibStakingStorage.States",
                                        ),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned(
                        "MustBeInNextValidatorSetLockedOrReadyForNextEpochOrRestoreState",
                    ),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "MustBeInNextValidatorSetLockedOrReadyForNextEpochOrRestoreState",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("state"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(8usize),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "enum LibStakingStorage.States",
                                        ),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned(
                        "MustBeInNextValidatorSetLockedOrReadyForNextEpochState",
                    ),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "MustBeInNextValidatorSetLockedOrReadyForNextEpochState",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("state"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(8usize),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "enum LibStakingStorage.States",
                                        ),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned(
                        "MustBeInNextValidatorSetLockedState",
                    ),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "MustBeInNextValidatorSetLockedState",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("state"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(8usize),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "enum LibStakingStorage.States",
                                        ),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("MustBeInReadyForNextEpochState"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "MustBeInReadyForNextEpochState",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("state"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(8usize),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "enum LibStakingStorage.States",
                                        ),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("MustBeValidatorInNextEpochToKick"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "MustBeValidatorInNextEpochToKick",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("stakerAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned(
                        "NewTimeLockMustBeGreaterThanCurrent",
                    ),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "NewTimeLockMustBeGreaterThanCurrent",
                            ),
                            inputs: ::std::vec![],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("NoBytecodeAtAddress"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "NoBytecodeAtAddress",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("_contractAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("_message"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::String,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("string"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("NoEmptyStakeRecordSlots"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "NoEmptyStakeRecordSlots",
                            ),
                            inputs: ::std::vec![],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("NoEmptyStakingSlot"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned("NoEmptyStakingSlot"),
                            inputs: ::std::vec![],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned(
                        "NoSelectorsProvidedForFacetForCut",
                    ),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "NoSelectorsProvidedForFacetForCut",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("_facetAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("NodeAddressNotFoundForStaker"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "NodeAddressNotFoundForStaker",
                            ),
                            inputs: ::std::vec![],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("NotApprovedOrOwner"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned("NotApprovedOrOwner"),
                            inputs: ::std::vec![],
                        },
                    ],
                )
        ]
        )
        }
        
        
        
#[allow(deprecated)]
        fn __abi_errors_2() -> std::collections::BTreeMap<String, Vec<::ethers::core::abi::ethabi::AbiError>> {
        
        std::collections::BTreeMap::from(
        [
        (
                    ::std::borrow::ToOwned::to_owned("NotContractOwner"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned("NotContractOwner"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("_user"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("_contractOwner"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned(
                        "NotEnoughTimeElapsedForTimeoutSinceLastEpoch",
                    ),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "NotEnoughTimeElapsedForTimeoutSinceLastEpoch",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("currentTimestamp"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("epochEndTime"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("timeout"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned(
                        "NotEnoughTimeElapsedSinceLastEpoch",
                    ),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "NotEnoughTimeElapsedSinceLastEpoch",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("currentTimestamp"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("epochEndTime"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("NotEnoughValidatorsInNextEpoch"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "NotEnoughValidatorsInNextEpoch",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("validatorCount"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "minimumValidatorCount",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned(
                        "NotEnoughValidatorsReadyForNextEpoch",
                    ),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "NotEnoughValidatorsReadyForNextEpoch",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "currentReadyValidatorCount",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "nextReadyValidatorCount",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "minimumValidatorCountToBeReady",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("NotOwner"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned("NotOwner"),
                            inputs: ::std::vec![],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("RealmIdNotFound"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned("RealmIdNotFound"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("stakerAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned(
                        "RemoveFacetAddressMustBeZeroAddress",
                    ),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "RemoveFacetAddressMustBeZeroAddress",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("_facetAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("RewardsMustBeClaimed"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "RewardsMustBeClaimed",
                            ),
                            inputs: ::std::vec![],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("SameAddress"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned("SameAddress"),
                            inputs: ::std::vec![],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("SignaledReadyForWrongEpochNumber"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "SignaledReadyForWrongEpochNumber",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "currentEpochNumber",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "receivedEpochNumber",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("SlashingMustOccurInSameRealm"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "SlashingMustOccurInSameRealm",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("slahedAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("slashedRealmId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("senderAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("senderRealmId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("StakeAmountNotMet"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned("StakeAmountNotMet"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("amount"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned(
                        "StakeMustBeGreaterThanMinimumStake",
                    ),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "StakeMustBeGreaterThanMinimumStake",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("stakerAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("stakedAmount"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("minimumStake"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("StakeRecordNotFound"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "StakeRecordNotFound",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("stakeRecordId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("StakerAddressMismatch"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "StakerAddressMismatch",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("senderAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("operatorAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("stakerAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("TimeLockNotMet"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned("TimeLockNotMet"),
                            inputs: ::std::vec![],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("TooSoonToWithdraw"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned("TooSoonToWithdraw"),
                            inputs: ::std::vec![],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("TryingToWithdrawMoreThanStaked"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "TryingToWithdrawMoreThanStaked",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("yourBalance"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "requestedWithdrawlAmount",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned(
                        "ValidatorAlreadyInNextValidatorSet",
                    ),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "ValidatorAlreadyInNextValidatorSet",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("staker"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("ValidatorAlreadyInRealm"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "ValidatorAlreadyInRealm",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("staker"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("existingRealmId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("ValidatorIsNotInNextEpoch"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "ValidatorIsNotInNextEpoch",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("validator"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "validatorsInNextEpoch",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address[]"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("ValidatorNotInNextEpoch"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "ValidatorNotInNextEpoch",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("staker"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("ValidatorNotPermitted"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "ValidatorNotPermitted",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("validatorAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("realmId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("ValidatorNotRegistered"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "ValidatorNotRegistered",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("validatorAddress"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned(
                        "ValidatorRegisterAttestedWalletDisabled",
                    ),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "ValidatorRegisterAttestedWalletDisabled",
                            ),
                            inputs: ::std::vec![],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("ValueMustBeNonzero"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned("ValueMustBeNonzero"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("valueName"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::String,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("string"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("ZeroAddress"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned("ZeroAddress"),
                            inputs: ::std::vec![],
                        },
                    ],
                ),
            ]
        )
        }
        
        
        
#[allow(deprecated)]
    fn __abi() -> ::ethers::core::abi::Abi {
        
        
        
        ::ethers::core::abi::ethabi::Contract {
            constructor: ::core::option::Option::None,
            functions: ::core::convert::From::from(__abi_functions()),
            events: ::core::convert::From::from(__abi_events()),
            errors: ::core::convert::From::from(__abi_errors()),
            receive: false,
            fallback: false,
        }
    }
    ///The parsed JSON ABI of the contract.
    pub static STAKING_ABI: ::ethers::contract::Lazy<::ethers::core::abi::Abi> = ::ethers::contract::Lazy::new(
        __abi,
    );
    pub struct Staking<M>(::ethers::contract::Contract<M>);
    impl<M> ::core::clone::Clone for Staking<M> {
        fn clone(&self) -> Self {
            Self(::core::clone::Clone::clone(&self.0))
        }
    }
    impl<M> ::core::ops::Deref for Staking<M> {
        type Target = ::ethers::contract::Contract<M>;
        fn deref(&self) -> &Self::Target {
            &self.0
        }
    }
    impl<M> ::core::ops::DerefMut for Staking<M> {
        fn deref_mut(&mut self) -> &mut Self::Target {
            &mut self.0
        }
    }
    impl<M> ::core::fmt::Debug for Staking<M> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple(::core::stringify!(Staking)).field(&self.address()).finish()
        }
    }
    impl<M: ::ethers::providers::Middleware> Staking<M> {
        /// Creates a new contract instance with the specified `ethers` client at
        /// `address`. The contract derefs to a `ethers::Contract` object.
        pub fn new<T: Into<::ethers::core::types::Address>>(
            address: T,
            client: ::std::sync::Arc<M>,
        ) -> Self {
            Self(
                ::ethers::contract::Contract::new(
                    address.into(),
                    STAKING_ABI.clone(),
                    client,
                ),
            )
        }
        ///Calls the contract's `IS_TEST` (0xfa7626d4) function
        pub fn is_test(&self) -> ::ethers::contract::builders::ContractCall<M, bool> {
            self.0
                .method_hash([250, 118, 38, 212], ())
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `_generateAddresses` (0x678ac78a) function
        pub fn generate_addresses(
            &self,
            num_addresses: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<
            M,
            ::std::vec::Vec<::ethers::core::types::Address>,
        > {
            self.0
                .method_hash([103, 138, 199, 138], num_addresses)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `_generateAddressesWithOffset` (0xa5187b2b) function
        pub fn generate_addresses_with_offset(
            &self,
            num_addresses: ::ethers::core::types::U256,
            offset: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<
            M,
            ::std::vec::Vec<::ethers::core::types::Address>,
        > {
            self.0
                .method_hash([165, 24, 123, 43], (num_addresses, offset))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `_generatePubKeys` (0xfed0a77b) function
        pub fn generate_pub_keys(
            &self,
            stakers: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<
            M,
            ::std::vec::Vec<::ethers::core::types::Bytes>,
        > {
            self.0
                .method_hash([254, 208, 167, 123], stakers)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `_generateUint256s` (0xae517f4d) function
        pub fn generate_uint_25_6s(
            &self,
            num_uint_25_6s: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<
            M,
            ::std::vec::Vec<::ethers::core::types::U256>,
        > {
            self.0
                .method_hash([174, 81, 127, 77], num_uint_25_6s)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `_generateUint256sWithOffset` (0xfb9d55b8) function
        pub fn generate_uint_25_6s_with_offset(
            &self,
            num_uint_25_6s: ::ethers::core::types::U256,
            offset: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<
            M,
            ::std::vec::Vec<::ethers::core::types::U256>,
        > {
            self.0
                .method_hash([251, 157, 85, 184], (num_uint_25_6s, offset))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `_generateValidators` (0xc5344d40) function
        pub fn generate_validators(
            &self,
            num_validators: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<
            M,
            ::std::vec::Vec<TestValidator>,
        > {
            self.0
                .method_hash([197, 52, 77, 64], num_validators)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `addRealm` (0x472a7d89) function
        pub fn add_realm(
            &self,
        ) -> ::ethers::contract::builders::ContractCall<M, ::ethers::core::types::U256> {
            self.0
                .method_hash([71, 42, 125, 137], ())
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `adminKickValidatorInNextEpoch` (0x7aa086e7) function
        pub fn admin_kick_validator_in_next_epoch(
            &self,
            validator_staker_address: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([122, 160, 134, 231], validator_staker_address)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `adminRejoinValidator` (0x4cd938ce) function
        pub fn admin_rejoin_validator(
            &self,
            realm_id: ::ethers::core::types::U256,
            staker_address: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([76, 217, 56, 206], (realm_id, staker_address))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `adminSetValidatorRegisterAttestedWalletDisabled` (0x15319384) function
        pub fn admin_set_validator_register_attested_wallet_disabled(
            &self,
            validator_address: ::ethers::core::types::Address,
            disabled: bool,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([21, 49, 147, 132], (validator_address, disabled))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `adminSetValidatorsInCurrentEpoch` (0x7db39fb4) function
        pub fn admin_set_validators_in_current_epoch(
            &self,
            realm_id: ::ethers::core::types::U256,
            validators_for_current_epoch: ::std::vec::Vec<::ethers::core::types::Address>,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash(
                    [125, 179, 159, 180],
                    (realm_id, validators_for_current_epoch),
                )
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `adminSetValidatorsInNextEpoch` (0x2d5e1361) function
        pub fn admin_set_validators_in_next_epoch(
            &self,
            realm_id: ::ethers::core::types::U256,
            validators_for_next_epoch: ::std::vec::Vec<::ethers::core::types::Address>,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([45, 94, 19, 97], (realm_id, validators_for_next_epoch))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `adminSetupShadowSplicing` (0x684d8bd9) function
        pub fn admin_setup_shadow_splicing(
            &self,
            source_realm_id: ::ethers::core::types::U256,
            target_realm_id: ::ethers::core::types::U256,
            target_validators: ::std::vec::Vec<::ethers::core::types::Address>,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash(
                    [104, 77, 139, 217],
                    (source_realm_id, target_realm_id, target_validators),
                )
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `adminSlashValidator` (0x1f1c50cb) function
        pub fn admin_slash_validator(
            &self,
            percentage: ::ethers::core::types::U256,
            staker_address: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([31, 28, 80, 203], (percentage, staker_address))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `adminStakeForUser` (0xf5008ed2) function
        pub fn admin_stake_for_user(
            &self,
            user_staker_address: ::ethers::core::types::Address,
            operator_staker_address: ::ethers::core::types::Address,
            time_lock: ::ethers::core::types::U256,
            amount: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash(
                    [245, 0, 142, 210],
                    (user_staker_address, operator_staker_address, time_lock, amount),
                )
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `adminUnfreezeForUser` (0x06732018) function
        pub fn admin_unfreeze_for_user(
            &self,
            user_staker_address: ::ethers::core::types::Address,
            operator_staker_address: ::ethers::core::types::Address,
            stake_id: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash(
                    [6, 115, 32, 24],
                    (user_staker_address, operator_staker_address, stake_id),
                )
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `advanceEpoch` (0xf3b87779) function
        pub fn advance_epoch(
            &self,
            realm_id: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([243, 184, 119, 121], realm_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `approve` (0x095ea7b3) function
        pub fn approve(
            &self,
            approved: ::ethers::core::types::Address,
            token_id: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([9, 94, 167, 179], (approved, token_id))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `balanceOf` (0x70a08231) function
        pub fn balance_of(
            &self,
            owner: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, ::ethers::core::types::U256> {
            self.0
                .method_hash([112, 160, 130, 49], owner)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `calculateRewardsPerDay` (0x9be372e0) function
        pub fn calculate_rewards_per_day(
            &self,
            global_stats: RewardEpochGlobalStats,
        ) -> ::ethers::contract::builders::ContractCall<M, ::ethers::core::types::U256> {
            self.0
                .method_hash([155, 227, 114, 224], (global_stats,))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `calculateStakeWeight` (0x2b7c29e3) function
        pub fn calculate_stake_weight(
            &self,
            time_lock: ::ethers::core::types::U256,
            amount: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, ::ethers::core::types::U256> {
            self.0
                .method_hash([43, 124, 41, 227], (time_lock, amount))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `checkActiveOrUnlockedOrPausedState` (0xb6e184c0) function
        pub fn check_active_or_unlocked_or_paused_state(
            &self,
            state: u8,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([182, 225, 132, 192], state)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `checkStakingAmounts` (0x49919966) function
        pub fn check_staking_amounts(
            &self,
            staker_address: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, bool> {
            self.0
                .method_hash([73, 145, 153, 102], staker_address)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `checkVersion` (0xcffbfc20) function
        pub fn check_version(
            &self,
            realm_id: ::ethers::core::types::U256,
            version: Version,
        ) -> ::ethers::contract::builders::ContractCall<M, bool> {
            self.0
                .method_hash([207, 251, 252, 32], (realm_id, version))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `claimFixedCostRewards` (0xcc5e546b) function
        pub fn claim_fixed_cost_rewards(
            &self,
            realm_id: ::ethers::core::types::U256,
            max_number_of_epochs_to_claim: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash(
                    [204, 94, 84, 107],
                    (realm_id, max_number_of_epochs_to_claim),
                )
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `claimStakeRewards` (0x0ffb0d94) function
        pub fn claim_stake_rewards(
            &self,
            realm_id: ::ethers::core::types::U256,
            staker_address: ::ethers::core::types::Address,
            stake_record_id: ::ethers::core::types::U256,
            max_number_of_epochs_to_claim: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash(
                    [15, 251, 13, 148],
                    (
                        realm_id,
                        staker_address,
                        stake_record_id,
                        max_number_of_epochs_to_claim,
                    ),
                )
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `claimValidatorCommission` (0x123eab4b) function
        pub fn claim_validator_commission(
            &self,
            realm_id: ::ethers::core::types::U256,
            max_number_of_epochs_to_claim: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash(
                    [18, 62, 171, 75],
                    (realm_id, max_number_of_epochs_to_claim),
                )
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `complaintConfig` (0x02f6da56) function
        pub fn complaint_config(
            &self,
            reason: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, ComplaintConfig> {
            self.0
                .method_hash([2, 246, 218, 86], reason)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `contractResolver` (0x50d17b5e) function
        pub fn contract_resolver(
            &self,
        ) -> ::ethers::contract::builders::ContractCall<
            M,
            ::ethers::core::types::Address,
        > {
            self.0
                .method_hash([80, 209, 123, 94], ())
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `countOfCurrentValidatorsReadyForNextEpoch` (0x31232f31) function
        pub fn count_of_current_validators_ready_for_next_epoch(
            &self,
            realm_id: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, ::ethers::core::types::U256> {
            self.0
                .method_hash([49, 35, 47, 49], realm_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `countOfNextValidatorsReadyForNextEpoch` (0xdce6f078) function
        pub fn count_of_next_validators_ready_for_next_epoch(
            &self,
            realm_id: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, ::ethers::core::types::U256> {
            self.0
                .method_hash([220, 230, 240, 120], realm_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `currentValidatorCountForConsensus` (0x9423f589) function
        pub fn current_validator_count_for_consensus(
            &self,
            realm_id: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, ::ethers::core::types::U256> {
            self.0
                .method_hash([148, 35, 245, 137], realm_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `decreaseRewardPool` (0xfc36f915) function
        pub fn decrease_reward_pool(
            &self,
            realm_id: ::ethers::core::types::U256,
            amount: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([252, 54, 249, 21], (realm_id, amount))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `deleteKeySet` (0x0815b188) function
        pub fn delete_key_set(
            &self,
            identifier: ::std::string::String,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([8, 21, 177, 136], identifier)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `diamondCut` (0x1f931c1c) function
        pub fn diamond_cut(
            &self,
            diamond_cut: ::std::vec::Vec<FacetCut>,
            init: ::ethers::core::types::Address,
            calldata: ::ethers::core::types::Bytes,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([31, 147, 28, 28], (diamond_cut, init, calldata))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `emitClearOfflinePhaseData` (0x00a52713) function
        pub fn emit_clear_offline_phase_data(
            &self,
            data_type: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([0, 165, 39, 19], data_type)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `emitCountOfflinePhaseData` (0x9a74745d) function
        pub fn emit_count_offline_phase_data(
            &self,
            data_type: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([154, 116, 116, 93], data_type)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `epoch` (0x5487c577) function
        pub fn epoch(
            &self,
            realm_id: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, Epoch> {
            self.0
                .method_hash([84, 135, 197, 119], realm_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `excludeArtifacts` (0xb5508aa9) function
        pub fn exclude_artifacts(
            &self,
        ) -> ::ethers::contract::builders::ContractCall<
            M,
            ::std::vec::Vec<::std::string::String>,
        > {
            self.0
                .method_hash([181, 80, 138, 169], ())
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `excludeContracts` (0xe20c9f71) function
        pub fn exclude_contracts(
            &self,
        ) -> ::ethers::contract::builders::ContractCall<
            M,
            ::std::vec::Vec<::ethers::core::types::Address>,
        > {
            self.0
                .method_hash([226, 12, 159, 113], ())
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `excludeSelectors` (0xb0464fdc) function
        pub fn exclude_selectors(
            &self,
        ) -> ::ethers::contract::builders::ContractCall<
            M,
            ::std::vec::Vec<FuzzSelector>,
        > {
            self.0
                .method_hash([176, 70, 79, 220], ())
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `excludeSenders` (0x1ed7831c) function
        pub fn exclude_senders(
            &self,
        ) -> ::ethers::contract::builders::ContractCall<
            M,
            ::std::vec::Vec<::ethers::core::types::Address>,
        > {
            self.0
                .method_hash([30, 215, 131, 28], ())
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `exit` (0xe9fad8ee) function
        pub fn exit(&self) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([233, 250, 216, 238], ())
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `facetAddress` (0xcdffacc6) function
        pub fn facet_address(
            &self,
            function_selector: [u8; 4],
        ) -> ::ethers::contract::builders::ContractCall<
            M,
            ::ethers::core::types::Address,
        > {
            self.0
                .method_hash([205, 255, 172, 198], function_selector)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `facetAddresses` (0x52ef6b2c) function
        pub fn facet_addresses(
            &self,
        ) -> ::ethers::contract::builders::ContractCall<
            M,
            ::std::vec::Vec<::ethers::core::types::Address>,
        > {
            self.0
                .method_hash([82, 239, 107, 44], ())
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `facetFunctionSelectors` (0xadfca15e) function
        pub fn facet_function_selectors(
            &self,
            facet: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, ::std::vec::Vec<[u8; 4]>> {
            self.0
                .method_hash([173, 252, 161, 94], facet)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `facets` (0x7a0ed627) function
        pub fn facets(
            &self,
        ) -> ::ethers::contract::builders::ContractCall<M, ::std::vec::Vec<Facet>> {
            self.0
                .method_hash([122, 14, 214, 39], ())
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `failed` (0xba414fa6) function
        pub fn failed(&self) -> ::ethers::contract::builders::ContractCall<M, bool> {
            self.0
                .method_hash([186, 65, 79, 166], ())
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getActiveUnkickedValidatorCount` (0x7a808c0d) function
        pub fn get_active_unkicked_validator_count(
            &self,
            realm_id: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, ::ethers::core::types::U256> {
            self.0
                .method_hash([122, 128, 140, 13], realm_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getActiveUnkickedValidatorStructs` (0xe4ccc020) function
        pub fn get_active_unkicked_validator_structs(
            &self,
            realm_id: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, ::std::vec::Vec<Validator>> {
            self.0
                .method_hash([228, 204, 192, 32], realm_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getActiveUnkickedValidatorStructsAndCounts` (0xd09cd5a8) function
        pub fn get_active_unkicked_validator_structs_and_counts(
            &self,
            realm_id: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<
            M,
            (Epoch, ::ethers::core::types::U256, ::std::vec::Vec<Validator>),
        > {
            self.0
                .method_hash([208, 156, 213, 168], realm_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getActiveUnkickedValidators` (0x8b6de0d1) function
        pub fn get_active_unkicked_validators(
            &self,
            realm_id: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<
            M,
            ::std::vec::Vec<::ethers::core::types::Address>,
        > {
            self.0
                .method_hash([139, 109, 224, 209], realm_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getAllReserveValidators` (0xbd8578d6) function
        pub fn get_all_reserve_validators(
            &self,
        ) -> ::ethers::contract::builders::ContractCall<
            M,
            ::std::vec::Vec<::ethers::core::types::Address>,
        > {
            self.0
                .method_hash([189, 133, 120, 214], ())
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getAllUnkickedValidators` (0x0df47a24) function
        pub fn get_all_unkicked_validators(
            &self,
        ) -> ::ethers::contract::builders::ContractCall<
            M,
            ::std::vec::Vec<::ethers::core::types::Address>,
        > {
            self.0
                .method_hash([13, 244, 122, 36], ())
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getAllValidators` (0xf3513a37) function
        pub fn get_all_validators(
            &self,
        ) -> ::ethers::contract::builders::ContractCall<
            M,
            ::std::vec::Vec<::ethers::core::types::Address>,
        > {
            self.0
                .method_hash([243, 81, 58, 55], ())
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getApproved` (0x081812fc) function
        pub fn get_approved(
            &self,
            token_id: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<
            M,
            ::ethers::core::types::Address,
        > {
            self.0
                .method_hash([8, 24, 18, 252], token_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getAttestedPubKey` (0xe9332ea7) function
        pub fn get_attested_pub_key(
            &self,
            attested_address: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<
            M,
            ::ethers::core::types::Bytes,
        > {
            self.0
                .method_hash([233, 51, 46, 167], attested_address)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getCurrentRealmIdForStakerAddress` (0x88de4e25) function
        pub fn get_current_realm_id_for_staker_address(
            &self,
            staker_address: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, ::ethers::core::types::U256> {
            self.0
                .method_hash([136, 222, 78, 37], staker_address)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getDelegatedStakersWithUnfreezingStakes` (0x9fe51529) function
        pub fn get_delegated_stakers_with_unfreezing_stakes(
            &self,
            validator_address: ::ethers::core::types::Address,
            limit: ::ethers::core::types::U256,
            offset: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<
            M,
            ::std::vec::Vec<::ethers::core::types::Address>,
        > {
            self.0
                .method_hash([159, 229, 21, 41], (validator_address, limit, offset))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getDelegatedStakersWithUnfreezingStakesCount` (0x8c3ccf4c) function
        pub fn get_delegated_stakers_with_unfreezing_stakes_count(
            &self,
            validator_address: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, ::ethers::core::types::U256> {
            self.0
                .method_hash([140, 60, 207, 76], validator_address)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getEmptyStakeRecordSlots` (0xa6f67c51) function
        pub fn get_empty_stake_record_slots(
            &self,
            user_staker_address: ::ethers::core::types::Address,
            operator_staker_address: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, ::ethers::core::types::U256> {
            self.0
                .method_hash(
                    [166, 246, 124, 81],
                    (user_staker_address, operator_staker_address),
                )
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getKeySet` (0xa305e5fe) function
        pub fn get_key_set(
            &self,
            identifier: ::std::string::String,
        ) -> ::ethers::contract::builders::ContractCall<M, KeySetConfig> {
            self.0
                .method_hash([163, 5, 229, 254], identifier)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getKeyTypes` (0xf1b877a8) function
        pub fn get_key_types(
            &self,
        ) -> ::ethers::contract::builders::ContractCall<
            M,
            ::std::vec::Vec<::ethers::core::types::U256>,
        > {
            self.0
                .method_hash([241, 184, 119, 168], ())
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getKickedValidators` (0x4b6afbbb) function
        pub fn get_kicked_validators(
            &self,
            realm_id: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<
            M,
            ::std::vec::Vec<::ethers::core::types::Address>,
        > {
            self.0
                .method_hash([75, 106, 251, 187], realm_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getLastStakeRecord` (0xfc73fb85) function
        pub fn get_last_stake_record(
            &self,
            user: ::ethers::core::types::Address,
            staker_address: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, StakeRecord> {
            self.0
                .method_hash([252, 115, 251, 133], (user, staker_address))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getLitCirc` (0xebc17602) function
        pub fn get_lit_circ(
            &self,
        ) -> ::ethers::contract::builders::ContractCall<M, ::ethers::core::types::U256> {
            self.0
                .method_hash([235, 193, 118, 2], ())
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getLowestRewardEpochNumber` (0x3866c0ef) function
        pub fn get_lowest_reward_epoch_number(
            &self,
        ) -> ::ethers::contract::builders::ContractCall<
            M,
            (::ethers::core::types::U256, ::ethers::core::types::U256),
        > {
            self.0
                .method_hash([56, 102, 192, 239], ())
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getMaxVersion` (0x73dd15ac) function
        pub fn get_max_version(
            &self,
            realm_id: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, Version> {
            self.0
                .method_hash([115, 221, 21, 172], realm_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getMaxVersionString` (0x64a481f5) function
        pub fn get_max_version_string(
            &self,
            realm_id: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, ::std::string::String> {
            self.0
                .method_hash([100, 164, 129, 245], realm_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getMaximumStake` (0x468a4883) function
        pub fn get_maximum_stake(
            &self,
        ) -> ::ethers::contract::builders::ContractCall<M, ::ethers::core::types::U256> {
            self.0
                .method_hash([70, 138, 72, 131], ())
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getMinVersion` (0x18443e59) function
        pub fn get_min_version(
            &self,
            realm_id: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, Version> {
            self.0
                .method_hash([24, 68, 62, 89], realm_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getMinVersionString` (0xf57610e3) function
        pub fn get_min_version_string(
            &self,
            realm_id: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, ::std::string::String> {
            self.0
                .method_hash([245, 118, 16, 227], realm_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getMinimumSelfStake` (0x8bc97a37) function
        pub fn get_minimum_self_stake(
            &self,
        ) -> ::ethers::contract::builders::ContractCall<M, ::ethers::core::types::U256> {
            self.0
                .method_hash([139, 201, 122, 55], ())
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getMinimumStake` (0xd9bbd278) function
        pub fn get_minimum_stake(
            &self,
        ) -> ::ethers::contract::builders::ContractCall<M, ::ethers::core::types::U256> {
            self.0
                .method_hash([217, 187, 210, 120], ())
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getMostRecentStakeRecord` (0x7d0f412f) function
        pub fn get_most_recent_stake_record(
            &self,
            user_staker_address: ::ethers::core::types::Address,
            operator_staker_address: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, StakeRecord> {
            self.0
                .method_hash(
                    [125, 15, 65, 47],
                    (user_staker_address, operator_staker_address),
                )
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getNodeAttestedPubKeyMappings` (0x88790aee) function
        pub fn get_node_attested_pub_key_mappings(
            &self,
            addresses: ::std::vec::Vec<::ethers::core::types::Address>,
        ) -> ::ethers::contract::builders::ContractCall<
            M,
            ::std::vec::Vec<PubKeyMapping>,
        > {
            self.0
                .method_hash([136, 121, 10, 238], addresses)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getNodeDemerits` (0xa8d6cedd) function
        pub fn get_node_demerits(
            &self,
            staker_address: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, ::ethers::core::types::U256> {
            self.0
                .method_hash([168, 214, 206, 221], staker_address)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getNodeStakerAddressMappings` (0x90fba112) function
        pub fn get_node_staker_address_mappings(
            &self,
            addresses: ::std::vec::Vec<::ethers::core::types::Address>,
        ) -> ::ethers::contract::builders::ContractCall<
            M,
            ::std::vec::Vec<AddressMapping>,
        > {
            self.0
                .method_hash([144, 251, 161, 18], addresses)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getNonShadowValidators` (0x65e3dcf6) function
        pub fn get_non_shadow_validators(
            &self,
            realm_id: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<
            M,
            ::std::vec::Vec<::ethers::core::types::Address>,
        > {
            self.0
                .method_hash([101, 227, 220, 246], realm_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getNonShadowValidatorsInCurrentEpochLength` (0x399ebc13) function
        pub fn get_non_shadow_validators_in_current_epoch_length(
            &self,
            realm_id: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, ::ethers::core::types::U256> {
            self.0
                .method_hash([57, 158, 188, 19], realm_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getRealmIdForStakerAddress` (0xaa3bed0b) function
        pub fn get_realm_id_for_staker_address(
            &self,
            staker_address: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, ::ethers::core::types::U256> {
            self.0
                .method_hash([170, 59, 237, 11], staker_address)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getRewardEpoch` (0x7e867f87) function
        pub fn get_reward_epoch(
            &self,
            staker_address: ::ethers::core::types::Address,
            reward_epoch_number: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, RewardEpoch> {
            self.0
                .method_hash([126, 134, 127, 135], (staker_address, reward_epoch_number))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getRewardEpochGlobalStats` (0x2c9d1844) function
        pub fn get_reward_epoch_global_stats(
            &self,
            epoch_number: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, RewardEpochGlobalStats> {
            self.0
                .method_hash([44, 157, 24, 68], epoch_number)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getRewardEpochNumber` (0xba1d8fef) function
        pub fn get_reward_epoch_number(
            &self,
            realm_id: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, ::ethers::core::types::U256> {
            self.0
                .method_hash([186, 29, 143, 239], realm_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getRewardEpochView` (0x709fe8a3) function
        pub fn get_reward_epoch_view(
            &self,
            staker_address: ::ethers::core::types::Address,
            reward_epoch_number: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, RewardEpoch> {
            self.0
                .method_hash([112, 159, 232, 163], (staker_address, reward_epoch_number))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getSelfStakeRecordCount` (0x01362dc3) function
        pub fn get_self_stake_record_count(
            &self,
            staker_address: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, ::ethers::core::types::U256> {
            self.0
                .method_hash([1, 54, 45, 195], staker_address)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getShadowRealmIdForStakerAddress` (0x455636de) function
        pub fn get_shadow_realm_id_for_staker_address(
            &self,
            staker_address: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, ::ethers::core::types::U256> {
            self.0
                .method_hash([69, 86, 54, 222], staker_address)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getShadowValidators` (0xcc090c8a) function
        pub fn get_shadow_validators(
            &self,
            realm_id: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<
            M,
            ::std::vec::Vec<::ethers::core::types::Address>,
        > {
            self.0
                .method_hash([204, 9, 12, 138], realm_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getStakeRecord` (0x114ed11d) function
        pub fn get_stake_record(
            &self,
            staker_address: ::ethers::core::types::Address,
            record_id: ::ethers::core::types::U256,
            user_staker_address: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, StakeRecord> {
            self.0
                .method_hash(
                    [17, 78, 209, 29],
                    (staker_address, record_id, user_staker_address),
                )
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getStakeRecordCount` (0x125fc3d4) function
        pub fn get_stake_record_count(
            &self,
            user_staker_address: ::ethers::core::types::Address,
            operator_staker_address: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, ::ethers::core::types::U256> {
            self.0
                .method_hash(
                    [18, 95, 195, 212],
                    (user_staker_address, operator_staker_address),
                )
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getStakeRecordsForUser` (0xdc1fab7f) function
        pub fn get_stake_records_for_user(
            &self,
            user_staker_address: ::ethers::core::types::Address,
            operator_staker_address: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<
            M,
            ::std::vec::Vec<StakeRecord>,
        > {
            self.0
                .method_hash(
                    [220, 31, 171, 127],
                    (user_staker_address, operator_staker_address),
                )
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getStakeWeightInEpoch` (0x580f68db) function
        pub fn get_stake_weight_in_epoch(
            &self,
            staker_address: ::ethers::core::types::Address,
            record_id: ::ethers::core::types::U256,
            user_staker_address: ::ethers::core::types::Address,
            reward_epoch_number: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, ::ethers::core::types::U256> {
            self.0
                .method_hash(
                    [88, 15, 104, 219],
                    (staker_address, record_id, user_staker_address, reward_epoch_number),
                )
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getThreshold` (0x4615d5e9) function
        pub fn get_threshold(
            &self,
            node_count: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, ::ethers::core::types::U256> {
            self.0
                .method_hash([70, 21, 213, 233], node_count)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getTimelockInEpoch` (0x2db912e4) function
        pub fn get_timelock_in_epoch(
            &self,
            staker_address: ::ethers::core::types::Address,
            stake_record: StakeRecord,
            reward_epoch_number: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, ::ethers::core::types::U256> {
            self.0
                .method_hash(
                    [45, 185, 18, 228],
                    (staker_address, stake_record, reward_epoch_number),
                )
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getTokenContractAddress` (0x22e45584) function
        pub fn get_token_contract_address(
            &self,
        ) -> ::ethers::contract::builders::ContractCall<
            M,
            ::ethers::core::types::Address,
        > {
            self.0
                .method_hash([34, 228, 85, 132], ())
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getTokenPrice` (0x4b94f50e) function
        pub fn get_token_price(
            &self,
        ) -> ::ethers::contract::builders::ContractCall<M, ::ethers::core::types::U256> {
            self.0
                .method_hash([75, 148, 245, 14], ())
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getTokensStaked` (0x0fd78304) function
        pub fn get_tokens_staked(
            &self,
            staker_address: ::ethers::core::types::Address,
            stake_record: StakeRecord,
            reward_epoch_number: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, ::ethers::core::types::U256> {
            self.0
                .method_hash(
                    [15, 215, 131, 4],
                    (staker_address, stake_record, reward_epoch_number),
                )
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getTotalStake` (0x1e7ff8f6) function
        pub fn get_total_stake(
            &self,
            staker_address: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<
            M,
            (::ethers::core::types::U256, ::ethers::core::types::U256),
        > {
            self.0
                .method_hash([30, 127, 248, 246], staker_address)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getTotalStakeByUser` (0xd349660a) function
        pub fn get_total_stake_by_user(
            &self,
            staker_address: ::ethers::core::types::Address,
            user: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<
            M,
            (::ethers::core::types::U256, ::ethers::core::types::U256),
        > {
            self.0
                .method_hash([211, 73, 102, 10], (staker_address, user))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getTrustedForwarder` (0xce1b815f) function
        pub fn get_trusted_forwarder(
            &self,
        ) -> ::ethers::contract::builders::ContractCall<
            M,
            ::ethers::core::types::Address,
        > {
            self.0
                .method_hash([206, 27, 129, 95], ())
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getUnfrozenStakeCountForUser` (0x5a0909fa) function
        pub fn get_unfrozen_stake_count_for_user(
            &self,
            user_staker_address: ::ethers::core::types::Address,
            operator_staker_address: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, ::ethers::core::types::U256> {
            self.0
                .method_hash(
                    [90, 9, 9, 250],
                    (user_staker_address, operator_staker_address),
                )
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getValidatorsDelegated` (0x5b2fcdcf) function
        pub fn get_validators_delegated(
            &self,
            user: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<
            M,
            ::std::vec::Vec<::ethers::core::types::U256>,
        > {
            self.0
                .method_hash([91, 47, 205, 207], user)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getValidatorsInCurrentEpoch` (0xeccd9e0e) function
        pub fn get_validators_in_current_epoch(
            &self,
            realm_id: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<
            M,
            ::std::vec::Vec<::ethers::core::types::Address>,
        > {
            self.0
                .method_hash([236, 205, 158, 14], realm_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getValidatorsInNextEpoch` (0x84bc5324) function
        pub fn get_validators_in_next_epoch(
            &self,
            realm_id: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<
            M,
            ::std::vec::Vec<::ethers::core::types::Address>,
        > {
            self.0
                .method_hash([132, 188, 83, 36], realm_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getValidatorsStructs` (0x533d463e) function
        pub fn get_validators_structs(
            &self,
            staker_addresses: ::std::vec::Vec<::ethers::core::types::Address>,
        ) -> ::ethers::contract::builders::ContractCall<M, ::std::vec::Vec<Validator>> {
            self.0
                .method_hash([83, 61, 70, 62], staker_addresses)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getValidatorsStructsInCurrentEpoch` (0xb0dee6c6) function
        pub fn get_validators_structs_in_current_epoch(
            &self,
            realm_id: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, ::std::vec::Vec<Validator>> {
            self.0
                .method_hash([176, 222, 230, 198], realm_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getValidatorsStructsInNextEpoch` (0x183c5ff0) function
        pub fn get_validators_structs_in_next_epoch(
            &self,
            realm_id: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, ::std::vec::Vec<Validator>> {
            self.0
                .method_hash([24, 60, 95, 240], realm_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getVotingStatusToKickValidator` (0x3e1c3693) function
        pub fn get_voting_status_to_kick_validator(
            &self,
            realm_id: ::ethers::core::types::U256,
            epoch_number: ::ethers::core::types::U256,
            validator_to_be_kicked_staker_address: ::ethers::core::types::Address,
            voter_staker_address: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<
            M,
            (::ethers::core::types::U256, bool),
        > {
            self.0
                .method_hash(
                    [62, 28, 54, 147],
                    (
                        realm_id,
                        epoch_number,
                        validator_to_be_kicked_staker_address,
                        voter_staker_address,
                    ),
                )
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `globalConfig` (0xa7c1abe0) function
        pub fn global_config(
            &self,
        ) -> ::ethers::contract::builders::ContractCall<M, GlobalConfig> {
            self.0
                .method_hash([167, 193, 171, 224], ())
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `increaseRewardPool` (0x0c1ea985) function
        pub fn increase_reward_pool(
            &self,
            realm_id: ::ethers::core::types::U256,
            amount: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([12, 30, 169, 133], (realm_id, amount))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `increaseStakeRecordAmount` (0x61967297) function
        pub fn increase_stake_record_amount(
            &self,
            staker_address: ::ethers::core::types::Address,
            stake_record_id: ::ethers::core::types::U256,
            additional_amount: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash(
                    [97, 150, 114, 151],
                    (staker_address, stake_record_id, additional_amount),
                )
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `increaseStakeRecordTimelock` (0xc5427758) function
        pub fn increase_stake_record_timelock(
            &self,
            staker_address: ::ethers::core::types::Address,
            stake_record_id: ::ethers::core::types::U256,
            additional_time_lock: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash(
                    [197, 66, 119, 88],
                    (staker_address, stake_record_id, additional_time_lock),
                )
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `initializeRewardEpoch` (0x9654c473) function
        pub fn initialize_reward_epoch(
            &self,
            staker_address: ::ethers::core::types::Address,
            reward_epoch_number: ::ethers::core::types::U256,
            is_initial: bool,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash(
                    [150, 84, 196, 115],
                    (staker_address, reward_epoch_number, is_initial),
                )
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `isActiveShadowValidator` (0x7e7ae34c) function
        pub fn is_active_shadow_validator(
            &self,
            realm_id: ::ethers::core::types::U256,
            staker_address: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, bool> {
            self.0
                .method_hash([126, 122, 227, 76], (realm_id, staker_address))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `isActiveValidator` (0xff347ae8) function
        pub fn is_active_validator(
            &self,
            realm_id: ::ethers::core::types::U256,
            staker_address: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, bool> {
            self.0
                .method_hash([255, 52, 122, 232], (realm_id, staker_address))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `isActiveValidatorByNodeAddress` (0x5064c127) function
        pub fn is_active_validator_by_node_address(
            &self,
            realm_id: ::ethers::core::types::U256,
            account: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, bool> {
            self.0
                .method_hash([80, 100, 193, 39], (realm_id, account))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `isActiveValidatorByNodeAddressForNextEpoch` (0xeb8f2f27) function
        pub fn is_active_validator_by_node_address_for_next_epoch(
            &self,
            realm_id: ::ethers::core::types::U256,
            node_address: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, bool> {
            self.0
                .method_hash([235, 143, 47, 39], (realm_id, node_address))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `isActiveValidatorForNextEpoch` (0x26fc6f9b) function
        pub fn is_active_validator_for_next_epoch(
            &self,
            realm_id: ::ethers::core::types::U256,
            staker_address: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, bool> {
            self.0
                .method_hash([38, 252, 111, 155], (realm_id, staker_address))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `isApprovedForAll` (0xe985e9c5) function
        pub fn is_approved_for_all(
            &self,
            owner: ::ethers::core::types::Address,
            operator: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, bool> {
            self.0
                .method_hash([233, 133, 233, 197], (owner, operator))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `isReadyForNextEpoch` (0x7fecc451) function
        pub fn is_ready_for_next_epoch(
            &self,
            realm_id: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, bool> {
            self.0
                .method_hash([127, 236, 196, 81], realm_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `isRecentValidator` (0x3c2ef732) function
        pub fn is_recent_validator(
            &self,
            node_address: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, bool> {
            self.0
                .method_hash([60, 46, 247, 50], node_address)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `isRecentValidator` (0xc974c355) function
        pub fn is_recent_validator_with_realm_id(
            &self,
            realm_id: ::ethers::core::types::U256,
            staker_addresses: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, bool> {
            self.0
                .method_hash([201, 116, 195, 85], (realm_id, staker_addresses))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `isValidatorBanned` (0xa92252ae) function
        pub fn is_validator_banned(
            &self,
            validator: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, bool> {
            self.0
                .method_hash([169, 34, 82, 174], validator)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `isValidatorInCurrentEpoch` (0xdf8a171f) function
        pub fn is_validator_in_current_epoch(
            &self,
            staker_address: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, bool> {
            self.0
                .method_hash([223, 138, 23, 31], staker_address)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `isValidatorInCurrentOrNextEpoch` (0x81b9beb7) function
        pub fn is_validator_in_current_or_next_epoch(
            &self,
            staker_address: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, bool> {
            self.0
                .method_hash([129, 185, 190, 183], staker_address)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `isValidatorInNextEpoch` (0xad0466a6) function
        pub fn is_validator_in_next_epoch(
            &self,
            staker_address: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, bool> {
            self.0
                .method_hash([173, 4, 102, 166], staker_address)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `keySets` (0xdce90405) function
        pub fn key_sets(
            &self,
        ) -> ::ethers::contract::builders::ContractCall<
            M,
            ::std::vec::Vec<KeySetConfig>,
        > {
            self.0
                .method_hash([220, 233, 4, 5], ())
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `kickPenaltyPercentByReason` (0x3e685266) function
        pub fn kick_penalty_percent_by_reason(
            &self,
            reason: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, ::ethers::core::types::U256> {
            self.0
                .method_hash([62, 104, 82, 102], reason)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `kickValidatorInNextEpoch` (0x865419e9) function
        pub fn kick_validator_in_next_epoch(
            &self,
            validator_to_kick_staker_address: ::ethers::core::types::Address,
            reason: ::ethers::core::types::U256,
            data: ::ethers::core::types::Bytes,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash(
                    [134, 84, 25, 233],
                    (validator_to_kick_staker_address, reason, data),
                )
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `litActionsConfig` (0xe3dfd1f5) function
        pub fn lit_actions_config(
            &self,
            realm_id: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, LitActionConfig> {
            self.0
                .method_hash([227, 223, 209, 245], realm_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `lockValidatorsForNextEpoch` (0x45c1b1fb) function
        pub fn lock_validators_for_next_epoch(
            &self,
            realm_id: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([69, 193, 177, 251], realm_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `maxStake` (0xea1b28e0) function
        pub fn max_stake(
            &self,
        ) -> ::ethers::contract::builders::ContractCall<M, ::ethers::core::types::U256> {
            self.0
                .method_hash([234, 27, 40, 224], ())
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `maxTimeLock` (0xe1cf73b9) function
        pub fn max_time_lock(
            &self,
        ) -> ::ethers::contract::builders::ContractCall<M, ::ethers::core::types::U256> {
            self.0
                .method_hash([225, 207, 115, 185], ())
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `migrateStakeRecord` (0x4048b256) function
        pub fn migrate_stake_record(
            &self,
            operator_address_to_migrate_from: ::ethers::core::types::Address,
            stake_record_id: ::ethers::core::types::U256,
            operator_address_to_migrate_to: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash(
                    [64, 72, 178, 86],
                    (
                        operator_address_to_migrate_from,
                        stake_record_id,
                        operator_address_to_migrate_to,
                    ),
                )
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `minSelfStake` (0xc5f530af) function
        pub fn min_self_stake(
            &self,
        ) -> ::ethers::contract::builders::ContractCall<M, ::ethers::core::types::U256> {
            self.0
                .method_hash([197, 245, 48, 175], ())
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `minStake` (0x375b3c0a) function
        pub fn min_stake(
            &self,
        ) -> ::ethers::contract::builders::ContractCall<M, ::ethers::core::types::U256> {
            self.0
                .method_hash([55, 91, 60, 10], ())
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `minTimeLock` (0xd00a818f) function
        pub fn min_time_lock(
            &self,
        ) -> ::ethers::contract::builders::ContractCall<M, ::ethers::core::types::U256> {
            self.0
                .method_hash([208, 10, 129, 143], ())
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `nextValidatorCountForConsensus` (0xa8b89564) function
        pub fn next_validator_count_for_consensus(
            &self,
            realm_id: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, ::ethers::core::types::U256> {
            self.0
                .method_hash([168, 184, 149, 100], realm_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `nodeAddressToStakerAddress` (0x5081f66f) function
        pub fn node_address_to_staker_address(
            &self,
            node_address: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<
            M,
            ::ethers::core::types::Address,
        > {
            self.0
                .method_hash([80, 129, 246, 111], node_address)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `nodeAddressToStakerAddressAcrossRealms` (0x86b01dd6) function
        pub fn node_address_to_staker_address_across_realms(
            &self,
            node_address: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<
            M,
            ::ethers::core::types::Address,
        > {
            self.0
                .method_hash([134, 176, 29, 214], node_address)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `numRealms` (0xfc14e3b9) function
        pub fn num_realms(
            &self,
        ) -> ::ethers::contract::builders::ContractCall<M, ::ethers::core::types::U256> {
            self.0
                .method_hash([252, 20, 227, 185], ())
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `operatorAddressToStakerAddress` (0xab8ccfbe) function
        pub fn operator_address_to_staker_address(
            &self,
            operator_address: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<
            M,
            ::ethers::core::types::Address,
        > {
            self.0
                .method_hash([171, 140, 207, 190], operator_address)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `owner` (0x8da5cb5b) function
        pub fn owner(
            &self,
        ) -> ::ethers::contract::builders::ContractCall<
            M,
            ::ethers::core::types::Address,
        > {
            self.0
                .method_hash([141, 165, 203, 91], ())
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `ownerOf` (0x6352211e) function
        pub fn owner_of(
            &self,
            token_id: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<
            M,
            ::ethers::core::types::Address,
        > {
            self.0
                .method_hash([99, 82, 33, 30], token_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `ownershipChange` (0x23857d51) function
        pub fn ownership_change(
            &self,
            token_id: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, ::ethers::core::types::U256> {
            self.0
                .method_hash([35, 133, 125, 81], token_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `permittedRealmsForValidator` (0xe718ff4c) function
        pub fn permitted_realms_for_validator(
            &self,
            validator: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<
            M,
            ::std::vec::Vec<::ethers::core::types::U256>,
        > {
            self.0
                .method_hash([231, 24, 255, 76], validator)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `permittedValidators` (0x58488c31) function
        pub fn permitted_validators(
            &self,
            realm_id: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<
            M,
            ::std::vec::Vec<::ethers::core::types::Address>,
        > {
            self.0
                .method_hash([88, 72, 140, 49], realm_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `pow` (0x2e4c697f) function
        pub fn pow(
            &self,
            base: ::ethers::core::types::U256,
            exponent: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, ::ethers::core::types::U256> {
            self.0
                .method_hash([46, 76, 105, 127], (base, exponent))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `readyForNextEpoch` (0xf2c5b908) function
        pub fn ready_for_next_epoch(
            &self,
            realm_id: ::ethers::core::types::U256,
            staker_address: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, bool> {
            self.0
                .method_hash([242, 197, 185, 8], (realm_id, staker_address))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `realmConfig` (0xe56cfb79) function
        pub fn realm_config(
            &self,
            realm_id: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, RealmConfig> {
            self.0
                .method_hash([229, 108, 251, 121], realm_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `registerAttestedWallet` (0x4aea5542) function
        pub fn register_attested_wallet(
            &self,
            staker_address: ::ethers::core::types::Address,
            attested_address: ::ethers::core::types::Address,
            attested_pub_key: ::ethers::core::types::Bytes,
            sender_pub_key: ::ethers::core::types::U256,
            receiver_pub_key: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash(
                    [74, 234, 85, 66],
                    (
                        staker_address,
                        attested_address,
                        attested_pub_key,
                        sender_pub_key,
                        receiver_pub_key,
                    ),
                )
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `removeRealm` (0xd2baca55) function
        pub fn remove_realm(
            &self,
            realm_id: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([210, 186, 202, 85], realm_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `requestToJoin` (0x84022767) function
        pub fn request_to_join(
            &self,
            realm_id: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([132, 2, 39, 103], realm_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `requestToJoinAsAdmin` (0xca005066) function
        pub fn request_to_join_as_admin(
            &self,
            realm_id: ::ethers::core::types::U256,
            staker_address: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([202, 0, 80, 102], (realm_id, staker_address))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `requestToJoinAsForShadowSplicing` (0x9a1dc1b5) function
        pub fn request_to_join_as_for_shadow_splicing(
            &self,
            realm_id: ::ethers::core::types::U256,
            staker_address: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([154, 29, 193, 181], (realm_id, staker_address))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `requestToJoinAsNode` (0x5b7204fa) function
        pub fn request_to_join_as_node(
            &self,
            realm_id: ::ethers::core::types::U256,
            staker_address: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([91, 114, 4, 250], (realm_id, staker_address))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `requestToLeave` (0xac2f8afe) function
        pub fn request_to_leave(
            &self,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([172, 47, 138, 254], ())
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `requestToLeaveAsNode` (0xc6f04cbb) function
        pub fn request_to_leave_as_node(
            &self,
            realm_id: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([198, 240, 76, 187], realm_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `safeTransferFrom` (0x42842e0e) function
        pub fn safe_transfer_from(
            &self,
            from: ::ethers::core::types::Address,
            to: ::ethers::core::types::Address,
            token_id: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([66, 132, 46, 14], (from, to, token_id))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `safeTransferFrom` (0xb88d4fde) function
        pub fn safe_transfer_from_with_from_and_to_and_data(
            &self,
            from: ::ethers::core::types::Address,
            to: ::ethers::core::types::Address,
            token_id: ::ethers::core::types::U256,
            data: ::ethers::core::types::Bytes,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([184, 141, 79, 222], (from, to, token_id, data))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `selfStakeBalanceOf` (0xeddf837a) function
        pub fn self_stake_balance_of(
            &self,
            staker_address: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, ::ethers::core::types::U256> {
            self.0
                .method_hash([237, 223, 131, 122], staker_address)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `setApprovalForAll` (0xa22cb465) function
        pub fn set_approval_for_all(
            &self,
            operator: ::ethers::core::types::Address,
            approved: bool,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([162, 44, 180, 101], (operator, approved))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `setComplaintConfig` (0x440e8d22) function
        pub fn set_complaint_config(
            &self,
            reason: ::ethers::core::types::U256,
            config: ComplaintConfig,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([68, 14, 141, 34], (reason, config))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `setConfig` (0x077b0d40) function
        pub fn set_config(
            &self,
            new_config: GlobalConfig,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([7, 123, 13, 64], (new_config,))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `setContractResolver` (0xf95d71b1) function
        pub fn set_contract_resolver(
            &self,
            new_resolver_address: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([249, 93, 113, 177], new_resolver_address)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `setDemeritRejoinThreshold` (0x2531431b) function
        pub fn set_demerit_rejoin_threshold(
            &self,
            new_threshold: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([37, 49, 67, 27], new_threshold)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `setDevopsAdmin` (0xcf7d1e87) function
        pub fn set_devops_admin(
            &self,
            new_devops_admin: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([207, 125, 30, 135], new_devops_admin)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `setEpochEndTime` (0x5a7e6c22) function
        pub fn set_epoch_end_time(
            &self,
            realm_id: ::ethers::core::types::U256,
            new_epoch_end_time: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([90, 126, 108, 34], (realm_id, new_epoch_end_time))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `setEpochLength` (0xeb57bafb) function
        pub fn set_epoch_length(
            &self,
            realm_id: ::ethers::core::types::U256,
            new_epoch_length: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([235, 87, 186, 251], (realm_id, new_epoch_length))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `setEpochState` (0x7a802454) function
        pub fn set_epoch_state(
            &self,
            realm_id: ::ethers::core::types::U256,
            new_state: u8,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([122, 128, 36, 84], (realm_id, new_state))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `setEpochTimeout` (0x0c9d5399) function
        pub fn set_epoch_timeout(
            &self,
            realm_id: ::ethers::core::types::U256,
            new_epoch_timeout: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([12, 157, 83, 153], (realm_id, new_epoch_timeout))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `setIpPortNodeAddress` (0x2c80b549) function
        pub fn set_ip_port_node_address(
            &self,
            ip: u32,
            ipv_6: u128,
            port: u32,
            operator_address: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([44, 128, 181, 73], (ip, ipv_6, port, operator_address))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `setKeySet` (0x74d0be87) function
        pub fn set_key_set(
            &self,
            update: KeySetConfig,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([116, 208, 190, 135], (update,))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `setLitActionConfig` (0xe7d1f9a1) function
        pub fn set_lit_action_config(
            &self,
            realm_id: ::ethers::core::types::U256,
            new_config: LitActionConfig,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([231, 209, 249, 161], (realm_id, new_config))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `setMaxVersion` (0xb34b251d) function
        pub fn set_max_version(
            &self,
            realm_id: ::ethers::core::types::U256,
            version: Version,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([179, 75, 37, 29], (realm_id, version))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `setMinVersion` (0x0c26c77b) function
        pub fn set_min_version(
            &self,
            realm_id: ::ethers::core::types::U256,
            version: Version,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([12, 38, 199, 123], (realm_id, version))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `setPendingRejoinTimeout` (0x2b156e7d) function
        pub fn set_pending_rejoin_timeout(
            &self,
            new_timeout: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([43, 21, 110, 125], new_timeout)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `setPermittedValidators` (0x8354ae59) function
        pub fn set_permitted_validators(
            &self,
            realm_id: ::ethers::core::types::U256,
            validators_to_set: ::std::vec::Vec<::ethers::core::types::Address>,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([131, 84, 174, 89], (realm_id, validators_to_set))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `setPermittedValidatorsOn` (0x74a22c51) function
        pub fn set_permitted_validators_on(
            &self,
            realm_id: ::ethers::core::types::U256,
            permitted_validators_on: bool,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([116, 162, 44, 81], (realm_id, permitted_validators_on))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `setRealmConfig` (0x7d35690f) function
        pub fn set_realm_config(
            &self,
            realm_id: ::ethers::core::types::U256,
            new_config: RealmConfig,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([125, 53, 105, 15], (realm_id, new_config))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `setTokenTotalSupplyStandIn` (0xe941a733) function
        pub fn set_token_total_supply_stand_in(
            &self,
            new_total_supply: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([233, 65, 167, 51], new_total_supply)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `setTrustedForwarder` (0xda742228) function
        pub fn set_trusted_forwarder(
            &self,
            forwarder: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([218, 116, 34, 40], forwarder)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `setUp` (0x0a9254e4) function
        pub fn set_up(&self) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([10, 146, 84, 228], ())
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `setValidatorCommissionRate` (0x7149ab58) function
        pub fn set_validator_commission_rate(
            &self,
            rate: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([113, 73, 171, 88], rate)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `shouldKickValidator` (0x1e966b97) function
        pub fn should_kick_validator(
            &self,
            realm_id: ::ethers::core::types::U256,
            staker_address: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, bool> {
            self.0
                .method_hash([30, 150, 107, 151], (realm_id, staker_address))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `signalReadyForNextEpoch` (0x9a25bdee) function
        pub fn signal_ready_for_next_epoch(
            &self,
            realm_id: ::ethers::core::types::U256,
            epoch_number: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([154, 37, 189, 238], (realm_id, epoch_number))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `splitStakeRecord` (0xf69ccb92) function
        pub fn split_stake_record(
            &self,
            staker_address: ::ethers::core::types::Address,
            stake_record_id: ::ethers::core::types::U256,
            ratio: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash(
                    [246, 156, 203, 146],
                    (staker_address, stake_record_id, ratio),
                )
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `stake` (0x7628a37d) function
        pub fn stake(
            &self,
            amount: ::ethers::core::types::U256,
            time_lock: ::ethers::core::types::U256,
            operator_staker_address: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash(
                    [118, 40, 163, 125],
                    (amount, time_lock, operator_staker_address),
                )
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `stakerToValidatorsTheyStakedTo` (0x6817d36e) function
        pub fn staker_to_validators_they_staked_to(
            &self,
            staker: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<
            M,
            ::std::vec::Vec<::ethers::core::types::Address>,
        > {
            self.0
                .method_hash([104, 23, 211, 110], staker)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `state` (0x3e4f49e6) function
        pub fn state(
            &self,
            realm_id: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, u8> {
            self.0
                .method_hash([62, 79, 73, 230], realm_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `supportsInterface` (0x01ffc9a7) function
        pub fn supports_interface(
            &self,
            interface_id: [u8; 4],
        ) -> ::ethers::contract::builders::ContractCall<M, bool> {
            self.0
                .method_hash([1, 255, 201, 167], interface_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `targetArtifactSelectors` (0x66d9a9a0) function
        pub fn target_artifact_selectors(
            &self,
        ) -> ::ethers::contract::builders::ContractCall<
            M,
            ::std::vec::Vec<FuzzArtifactSelector>,
        > {
            self.0
                .method_hash([102, 217, 169, 160], ())
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `targetArtifacts` (0x85226c81) function
        pub fn target_artifacts(
            &self,
        ) -> ::ethers::contract::builders::ContractCall<
            M,
            ::std::vec::Vec<::std::string::String>,
        > {
            self.0
                .method_hash([133, 34, 108, 129], ())
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `targetContracts` (0x3f7286f4) function
        pub fn target_contracts(
            &self,
        ) -> ::ethers::contract::builders::ContractCall<
            M,
            ::std::vec::Vec<::ethers::core::types::Address>,
        > {
            self.0
                .method_hash([63, 114, 134, 244], ())
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `targetInterfaces` (0x2ade3880) function
        pub fn target_interfaces(
            &self,
        ) -> ::ethers::contract::builders::ContractCall<
            M,
            ::std::vec::Vec<FuzzInterface>,
        > {
            self.0
                .method_hash([42, 222, 56, 128], ())
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `targetSelectors` (0x916a17c6) function
        pub fn target_selectors(
            &self,
        ) -> ::ethers::contract::builders::ContractCall<
            M,
            ::std::vec::Vec<FuzzSelector>,
        > {
            self.0
                .method_hash([145, 106, 23, 198], ())
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `targetSenders` (0x3e5e3c23) function
        pub fn target_senders(
            &self,
        ) -> ::ethers::contract::builders::ContractCall<
            M,
            ::std::vec::Vec<::ethers::core::types::Address>,
        > {
            self.0
                .method_hash([62, 94, 60, 35], ())
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `test_Stake` (0xdbab1cd7) function
        pub fn test_stake(&self) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([219, 171, 28, 215], ())
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `test_StakeAndTransfer` (0xaaedca62) function
        pub fn test_stake_and_transfer(
            &self,
            is_safe_transfer: bool,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([170, 237, 202, 98], is_safe_transfer)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `test_StakeAndTransfer_ClaimRewards` (0x96007d44) function
        pub fn test_stake_and_transfer_claim_rewards(
            &self,
            is_safe_transfer: bool,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([150, 0, 125, 68], is_safe_transfer)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `test_StakeAndTransfer_ReceiverMutatesStakeRecord` (0x6239b4f7) function
        pub fn test_stake_and_transfer_receiver_mutates_stake_record(
            &self,
            is_safe_transfer: bool,
            operation: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([98, 57, 180, 247], (is_safe_transfer, operation))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `test_StakeAndTransfer_RevertNotOwner` (0x5ad8b9a9) function
        pub fn test_stake_and_transfer_revert_not_owner(
            &self,
            is_safe_transfer: bool,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([90, 216, 185, 169], is_safe_transfer)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `test_StakeAndTransfer_TokenOwnerByIndex` (0xa7319b44) function
        pub fn test_stake_and_transfer_token_owner_by_index(
            &self,
            is_safe_transfer: bool,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([167, 49, 155, 68], is_safe_transfer)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `test_StakeAndTransfer_Withdraw` (0x86ef1d4d) function
        pub fn test_stake_and_transfer_withdraw(
            &self,
            is_safe_transfer: bool,
            is_unfreeze_before_transfer: bool,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash(
                    [134, 239, 29, 77],
                    (is_safe_transfer, is_unfreeze_before_transfer),
                )
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `test_StakeApproveAndTransfer` (0x22e7a7ac) function
        pub fn test_stake_approve_and_transfer(
            &self,
            is_safe_transfer: bool,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([34, 231, 167, 172], is_safe_transfer)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `test_StakeApproveForAllAndTransfer` (0x78854e37) function
        pub fn test_stake_approve_for_all_and_transfer(
            &self,
            is_safe_transfer: bool,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([120, 133, 78, 55], is_safe_transfer)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `test_StakeMax_TransferShouldFail` (0xb29fabc7) function
        pub fn test_stake_max_transfer_should_fail(
            &self,
            is_safe_transfer: bool,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([178, 159, 171, 199], is_safe_transfer)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `test_Stake_MutateStakeRecord` (0xa90bb850) function
        pub fn test_stake_mutate_stake_record(
            &self,
            operation: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([169, 11, 184, 80], operation)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `tokenOfOwnerByIndex` (0x2f745c59) function
        pub fn token_of_owner_by_index(
            &self,
            owner: ::ethers::core::types::Address,
            index: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, ::ethers::core::types::U256> {
            self.0
                .method_hash([47, 116, 92, 89], (owner, index))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `tokenToStakeRecord` (0xf0e2d9b5) function
        pub fn token_to_stake_record(
            &self,
            token_id: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, MappedStakeRecord> {
            self.0
                .method_hash([240, 226, 217, 181], token_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `totalSupply` (0x18160ddd) function
        pub fn total_supply(
            &self,
        ) -> ::ethers::contract::builders::ContractCall<M, ::ethers::core::types::U256> {
            self.0
                .method_hash([24, 22, 13, 221], ())
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `transferFrom` (0x23b872dd) function
        pub fn transfer_from(
            &self,
            from: ::ethers::core::types::Address,
            to: ::ethers::core::types::Address,
            token_id: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([35, 184, 114, 221], (from, to, token_id))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `transferOwnership` (0xf2fde38b) function
        pub fn transfer_ownership(
            &self,
            new_owner: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([242, 253, 227, 139], new_owner)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `unfreezeStake` (0xb626a4b5) function
        pub fn unfreeze_stake(
            &self,
            operator_staker_address: ::ethers::core::types::Address,
            stake_id: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([182, 38, 164, 181], (operator_staker_address, stake_id))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `validatorSelfStakeWillExpire` (0xbb8b437f) function
        pub fn validator_self_stake_will_expire(
            &self,
            realm_id: ::ethers::core::types::U256,
            staker_address: ::ethers::core::types::Address,
            staker_in_current_validator_set: bool,
        ) -> ::ethers::contract::builders::ContractCall<M, bool> {
            self.0
                .method_hash(
                    [187, 139, 67, 127],
                    (realm_id, staker_address, staker_in_current_validator_set),
                )
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `validator_by_staker_address` (0x794de9b5) function
        pub fn validator_by_staker_address(
            &self,
            staker_address: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, Validator> {
            self.0
                .method_hash([121, 77, 233, 181], staker_address)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `validators` (0xfa52c7d8) function
        pub fn validators(
            &self,
            staker_address: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, Validator> {
            self.0
                .method_hash([250, 82, 199, 216], staker_address)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `verifyKeySetCounts` (0xf14baa40) function
        pub fn verify_key_set_counts(
            &self,
            identifier: ::std::string::String,
            new_root_keys: ::std::vec::Vec<RootKey>,
        ) -> ::ethers::contract::builders::ContractCall<
            M,
            (::ethers::core::types::U256, ::ethers::core::types::U256),
        > {
            self.0
                .method_hash([241, 75, 170, 64], (identifier, new_root_keys))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `withdraw` (0xf3fef3a3) function
        pub fn withdraw(
            &self,
            operator_staker_address: ::ethers::core::types::Address,
            stake_record_id: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash(
                    [243, 254, 243, 163],
                    (operator_staker_address, stake_record_id),
                )
                .expect("method not found (this should never happen)")
        }
        ///Gets the contract's `AdvancedEpoch` event
        pub fn advanced_epoch_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<
            ::std::sync::Arc<M>,
            M,
            AdvancedEpochFilter,
        > {
            self.0.event()
        }
        ///Gets the contract's `Approval` event
        pub fn approval_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<
            ::std::sync::Arc<M>,
            M,
            ApprovalFilter,
        > {
            self.0.event()
        }
        ///Gets the contract's `ApprovalForAll` event
        pub fn approval_for_all_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<
            ::std::sync::Arc<M>,
            M,
            ApprovalForAllFilter,
        > {
            self.0.event()
        }
        ///Gets the contract's `AttestedWalletRegistered` event
        pub fn attested_wallet_registered_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<
            ::std::sync::Arc<M>,
            M,
            AttestedWalletRegisteredFilter,
        > {
            self.0.event()
        }
        ///Gets the contract's `ClearOfflinePhaseData` event
        pub fn clear_offline_phase_data_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<
            ::std::sync::Arc<M>,
            M,
            ClearOfflinePhaseDataFilter,
        > {
            self.0.event()
        }
        ///Gets the contract's `ComplaintConfigSet` event
        pub fn complaint_config_set_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<
            ::std::sync::Arc<M>,
            M,
            ComplaintConfigSetFilter,
        > {
            self.0.event()
        }
        ///Gets the contract's `ConfigSet` event
        pub fn config_set_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<
            ::std::sync::Arc<M>,
            M,
            ConfigSetFilter,
        > {
            self.0.event()
        }
        ///Gets the contract's `CountOfflinePhaseData` event
        pub fn count_offline_phase_data_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<
            ::std::sync::Arc<M>,
            M,
            CountOfflinePhaseDataFilter,
        > {
            self.0.event()
        }
        ///Gets the contract's `DebugEvent` event
        pub fn debug_event_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<
            ::std::sync::Arc<M>,
            M,
            DebugEventFilter,
        > {
            self.0.event()
        }
        ///Gets the contract's `DevopsAdminSet` event
        pub fn devops_admin_set_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<
            ::std::sync::Arc<M>,
            M,
            DevopsAdminSetFilter,
        > {
            self.0.event()
        }
        ///Gets the contract's `DiamondCut` event
        pub fn diamond_cut_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<
            ::std::sync::Arc<M>,
            M,
            DiamondCutFilter,
        > {
            self.0.event()
        }
        ///Gets the contract's `EpochEndTimeSet` event
        pub fn epoch_end_time_set_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<
            ::std::sync::Arc<M>,
            M,
            EpochEndTimeSetFilter,
        > {
            self.0.event()
        }
        ///Gets the contract's `EpochLengthSet` event
        pub fn epoch_length_set_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<
            ::std::sync::Arc<M>,
            M,
            EpochLengthSetFilter,
        > {
            self.0.event()
        }
        ///Gets the contract's `EpochTimeoutSet` event
        pub fn epoch_timeout_set_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<
            ::std::sync::Arc<M>,
            M,
            EpochTimeoutSetFilter,
        > {
            self.0.event()
        }
        ///Gets the contract's `FixedCostRewardsClaimed` event
        pub fn fixed_cost_rewards_claimed_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<
            ::std::sync::Arc<M>,
            M,
            FixedCostRewardsClaimedFilter,
        > {
            self.0.event()
        }
        ///Gets the contract's `KeySetConfigSet` event
        pub fn key_set_config_set_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<
            ::std::sync::Arc<M>,
            M,
            KeySetConfigSetFilter,
        > {
            self.0.event()
        }
        ///Gets the contract's `KeySetConfigUpdated` event
        pub fn key_set_config_updated_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<
            ::std::sync::Arc<M>,
            M,
            KeySetConfigUpdatedFilter,
        > {
            self.0.event()
        }
        ///Gets the contract's `KickPenaltyPercentSet` event
        pub fn kick_penalty_percent_set_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<
            ::std::sync::Arc<M>,
            M,
            KickPenaltyPercentSetFilter,
        > {
            self.0.event()
        }
        ///Gets the contract's `OwnershipTransferred` event
        pub fn ownership_transferred_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<
            ::std::sync::Arc<M>,
            M,
            OwnershipTransferredFilter,
        > {
            self.0.event()
        }
        ///Gets the contract's `ReadyForNextEpoch` event
        pub fn ready_for_next_epoch_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<
            ::std::sync::Arc<M>,
            M,
            ReadyForNextEpochFilter,
        > {
            self.0.event()
        }
        ///Gets the contract's `Recovered` event
        pub fn recovered_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<
            ::std::sync::Arc<M>,
            M,
            RecoveredFilter,
        > {
            self.0.event()
        }
        ///Gets the contract's `RequestToJoin` event
        pub fn request_to_join_1_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<
            ::std::sync::Arc<M>,
            M,
            RequestToJoin1Filter,
        > {
            self.0.event()
        }
        ///Gets the contract's `RequestToJoin` event
        pub fn request_to_join_2_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<
            ::std::sync::Arc<M>,
            M,
            RequestToJoin2Filter,
        > {
            self.0.event()
        }
        ///Gets the contract's `RequestToLeave` event
        pub fn request_to_leave_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<
            ::std::sync::Arc<M>,
            M,
            RequestToLeaveFilter,
        > {
            self.0.event()
        }
        ///Gets the contract's `ResolverContractAddressSet` event
        pub fn resolver_contract_address_set_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<
            ::std::sync::Arc<M>,
            M,
            ResolverContractAddressSetFilter,
        > {
            self.0.event()
        }
        ///Gets the contract's `RewardsDurationUpdated` event
        pub fn rewards_duration_updated_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<
            ::std::sync::Arc<M>,
            M,
            RewardsDurationUpdatedFilter,
        > {
            self.0.event()
        }
        ///Gets the contract's `StakeRecordCreated` event
        pub fn stake_record_created_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<
            ::std::sync::Arc<M>,
            M,
            StakeRecordCreatedFilter,
        > {
            self.0.event()
        }
        ///Gets the contract's `StakeRecordRemoved` event
        pub fn stake_record_removed_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<
            ::std::sync::Arc<M>,
            M,
            StakeRecordRemovedFilter,
        > {
            self.0.event()
        }
        ///Gets the contract's `StakeRecordUpdated` event
        pub fn stake_record_updated_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<
            ::std::sync::Arc<M>,
            M,
            StakeRecordUpdatedFilter,
        > {
            self.0.event()
        }
        ///Gets the contract's `StakeRewardsClaimed` event
        pub fn stake_rewards_claimed_1_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<
            ::std::sync::Arc<M>,
            M,
            StakeRewardsClaimed1Filter,
        > {
            self.0.event()
        }
        ///Gets the contract's `StakeRewardsClaimed` event
        pub fn stake_rewards_claimed_2_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<
            ::std::sync::Arc<M>,
            M,
            StakeRewardsClaimed2Filter,
        > {
            self.0.event()
        }
        ///Gets the contract's `Staked` event
        pub fn staked_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<::std::sync::Arc<M>, M, StakedFilter> {
            self.0.event()
        }
        ///Gets the contract's `StakingTokenSet` event
        pub fn staking_token_set_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<
            ::std::sync::Arc<M>,
            M,
            StakingTokenSetFilter,
        > {
            self.0.event()
        }
        ///Gets the contract's `StateChanged` event
        pub fn state_changed_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<
            ::std::sync::Arc<M>,
            M,
            StateChangedFilter,
        > {
            self.0.event()
        }
        ///Gets the contract's `Transfer` event
        pub fn transfer_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<
            ::std::sync::Arc<M>,
            M,
            TransferFilter,
        > {
            self.0.event()
        }
        ///Gets the contract's `TrustedForwarderSet` event
        pub fn trusted_forwarder_set_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<
            ::std::sync::Arc<M>,
            M,
            TrustedForwarderSetFilter,
        > {
            self.0.event()
        }
        ///Gets the contract's `ValidatorBanned` event
        pub fn validator_banned_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<
            ::std::sync::Arc<M>,
            M,
            ValidatorBannedFilter,
        > {
            self.0.event()
        }
        ///Gets the contract's `ValidatorCommissionClaimed` event
        pub fn validator_commission_claimed_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<
            ::std::sync::Arc<M>,
            M,
            ValidatorCommissionClaimedFilter,
        > {
            self.0.event()
        }
        ///Gets the contract's `ValidatorKickedFromNextEpoch` event
        pub fn validator_kicked_from_next_epoch_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<
            ::std::sync::Arc<M>,
            M,
            ValidatorKickedFromNextEpochFilter,
        > {
            self.0.event()
        }
        ///Gets the contract's `ValidatorRegistered` event
        pub fn validator_registered_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<
            ::std::sync::Arc<M>,
            M,
            ValidatorRegisteredFilter,
        > {
            self.0.event()
        }
        ///Gets the contract's `ValidatorRejoinedNextEpoch` event
        pub fn validator_rejoined_next_epoch_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<
            ::std::sync::Arc<M>,
            M,
            ValidatorRejoinedNextEpochFilter,
        > {
            self.0.event()
        }
        ///Gets the contract's `VersionRequirementsUpdated` event
        pub fn version_requirements_updated_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<
            ::std::sync::Arc<M>,
            M,
            VersionRequirementsUpdatedFilter,
        > {
            self.0.event()
        }
        ///Gets the contract's `VoteToAdvanceTimeOutElapsed` event
        pub fn vote_to_advance_time_out_elapsed_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<
            ::std::sync::Arc<M>,
            M,
            VoteToAdvanceTimeOutElapsedFilter,
        > {
            self.0.event()
        }
        ///Gets the contract's `VotedToKickValidatorInNextEpoch` event
        pub fn voted_to_kick_validator_in_next_epoch_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<
            ::std::sync::Arc<M>,
            M,
            VotedToKickValidatorInNextEpochFilter,
        > {
            self.0.event()
        }
        ///Gets the contract's `Withdrawn` event
        pub fn withdrawn_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<
            ::std::sync::Arc<M>,
            M,
            WithdrawnFilter,
        > {
            self.0.event()
        }
        ///Gets the contract's `log` event
        pub fn log_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<::std::sync::Arc<M>, M, LogFilter> {
            self.0.event()
        }
        ///Gets the contract's `log_address` event
        pub fn log_address_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<
            ::std::sync::Arc<M>,
            M,
            LogAddressFilter,
        > {
            self.0.event()
        }
        ///Gets the contract's `log_array` event
        pub fn log_array_1_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<
            ::std::sync::Arc<M>,
            M,
            LogArray1Filter,
        > {
            self.0.event()
        }
        ///Gets the contract's `log_array` event
        pub fn log_array_2_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<
            ::std::sync::Arc<M>,
            M,
            LogArray2Filter,
        > {
            self.0.event()
        }
        ///Gets the contract's `log_array` event
        pub fn log_array_3_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<
            ::std::sync::Arc<M>,
            M,
            LogArray3Filter,
        > {
            self.0.event()
        }
        ///Gets the contract's `log_bytes` event
        pub fn log_bytes_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<
            ::std::sync::Arc<M>,
            M,
            LogBytesFilter,
        > {
            self.0.event()
        }
        ///Gets the contract's `log_bytes32` event
        pub fn log_bytes_32_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<
            ::std::sync::Arc<M>,
            M,
            LogBytes32Filter,
        > {
            self.0.event()
        }
        ///Gets the contract's `log_int` event
        pub fn log_int_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<::std::sync::Arc<M>, M, LogIntFilter> {
            self.0.event()
        }
        ///Gets the contract's `log_named_address` event
        pub fn log_named_address_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<
            ::std::sync::Arc<M>,
            M,
            LogNamedAddressFilter,
        > {
            self.0.event()
        }
        ///Gets the contract's `log_named_array` event
        pub fn log_named_array_1_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<
            ::std::sync::Arc<M>,
            M,
            LogNamedArray1Filter,
        > {
            self.0.event()
        }
        ///Gets the contract's `log_named_array` event
        pub fn log_named_array_2_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<
            ::std::sync::Arc<M>,
            M,
            LogNamedArray2Filter,
        > {
            self.0.event()
        }
        ///Gets the contract's `log_named_array` event
        pub fn log_named_array_3_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<
            ::std::sync::Arc<M>,
            M,
            LogNamedArray3Filter,
        > {
            self.0.event()
        }
        ///Gets the contract's `log_named_bytes` event
        pub fn log_named_bytes_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<
            ::std::sync::Arc<M>,
            M,
            LogNamedBytesFilter,
        > {
            self.0.event()
        }
        ///Gets the contract's `log_named_bytes32` event
        pub fn log_named_bytes_32_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<
            ::std::sync::Arc<M>,
            M,
            LogNamedBytes32Filter,
        > {
            self.0.event()
        }
        ///Gets the contract's `log_named_decimal_int` event
        pub fn log_named_decimal_int_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<
            ::std::sync::Arc<M>,
            M,
            LogNamedDecimalIntFilter,
        > {
            self.0.event()
        }
        ///Gets the contract's `log_named_decimal_uint` event
        pub fn log_named_decimal_uint_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<
            ::std::sync::Arc<M>,
            M,
            LogNamedDecimalUintFilter,
        > {
            self.0.event()
        }
        ///Gets the contract's `log_named_int` event
        pub fn log_named_int_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<
            ::std::sync::Arc<M>,
            M,
            LogNamedIntFilter,
        > {
            self.0.event()
        }
        ///Gets the contract's `log_named_string` event
        pub fn log_named_string_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<
            ::std::sync::Arc<M>,
            M,
            LogNamedStringFilter,
        > {
            self.0.event()
        }
        ///Gets the contract's `log_named_uint` event
        pub fn log_named_uint_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<
            ::std::sync::Arc<M>,
            M,
            LogNamedUintFilter,
        > {
            self.0.event()
        }
        ///Gets the contract's `log_string` event
        pub fn log_string_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<
            ::std::sync::Arc<M>,
            M,
            LogStringFilter,
        > {
            self.0.event()
        }
        ///Gets the contract's `log_uint` event
        pub fn log_uint_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<::std::sync::Arc<M>, M, LogUintFilter> {
            self.0.event()
        }
        ///Gets the contract's `logs` event
        pub fn logs_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<::std::sync::Arc<M>, M, LogsFilter> {
            self.0.event()
        }
        /// Returns an `Event` builder for all the events of this contract.
        pub fn events(
            &self,
        ) -> ::ethers::contract::builders::Event<::std::sync::Arc<M>, M, StakingEvents> {
            self.0.event_with_filter(::core::default::Default::default())
        }
    }
    impl<M: ::ethers::providers::Middleware> From<::ethers::contract::Contract<M>>
    for Staking<M> {
        fn from(contract: ::ethers::contract::Contract<M>) -> Self {
            Self::new(contract.address(), contract.client())
        }
    }
    ///Custom Error type `ActiveValidatorsCannotLeave` with signature `ActiveValidatorsCannotLeave()` and selector `0x74fc692a`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[etherror(
        name = "ActiveValidatorsCannotLeave",
        abi = "ActiveValidatorsCannotLeave()"
    )]
    pub struct ActiveValidatorsCannotLeave;
    ///Custom Error type `CallerNotContract` with signature `CallerNotContract()` and selector `0xa85366a7`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[etherror(name = "CallerNotContract", abi = "CallerNotContract()")]
    pub struct CallerNotContract;
    ///Custom Error type `CallerNotOwner` with signature `CallerNotOwner()` and selector `0x5cd83192`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[etherror(name = "CallerNotOwner", abi = "CallerNotOwner()")]
    pub struct CallerNotOwner;
    ///Custom Error type `CallerNotOwnerOrDevopsAdmin` with signature `CallerNotOwnerOrDevopsAdmin()` and selector `0xedbb9143`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[etherror(
        name = "CallerNotOwnerOrDevopsAdmin",
        abi = "CallerNotOwnerOrDevopsAdmin()"
    )]
    pub struct CallerNotOwnerOrDevopsAdmin;
    ///Custom Error type `CannotAddFunctionToDiamondThatAlreadyExists` with signature `CannotAddFunctionToDiamondThatAlreadyExists(bytes4)` and selector `0xebbf5d07`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[etherror(
        name = "CannotAddFunctionToDiamondThatAlreadyExists",
        abi = "CannotAddFunctionToDiamondThatAlreadyExists(bytes4)"
    )]
    pub struct CannotAddFunctionToDiamondThatAlreadyExists {
        pub selector: [u8; 4],
    }
    ///Custom Error type `CannotAddSelectorsToZeroAddress` with signature `CannotAddSelectorsToZeroAddress(bytes4[])` and selector `0x0ae3681c`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[etherror(
        name = "CannotAddSelectorsToZeroAddress",
        abi = "CannotAddSelectorsToZeroAddress(bytes4[])"
    )]
    pub struct CannotAddSelectorsToZeroAddress {
        pub selectors: ::std::vec::Vec<[u8; 4]>,
    }
    ///Custom Error type `CannotKickBelowCurrentValidatorThreshold` with signature `CannotKickBelowCurrentValidatorThreshold()` and selector `0xe81f2804`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[etherror(
        name = "CannotKickBelowCurrentValidatorThreshold",
        abi = "CannotKickBelowCurrentValidatorThreshold()"
    )]
    pub struct CannotKickBelowCurrentValidatorThreshold;
    ///Custom Error type `CannotMigrateFromValidator` with signature `CannotMigrateFromValidator()` and selector `0x4ffa7973`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[etherror(
        name = "CannotMigrateFromValidator",
        abi = "CannotMigrateFromValidator()"
    )]
    pub struct CannotMigrateFromValidator;
    ///Custom Error type `CannotModifyUnfrozen` with signature `CannotModifyUnfrozen()` and selector `0x3b4e0e23`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[etherror(name = "CannotModifyUnfrozen", abi = "CannotModifyUnfrozen()")]
    pub struct CannotModifyUnfrozen;
    ///Custom Error type `CannotMoveToLockedValidatorStateBeforeEpochEnds` with signature `CannotMoveToLockedValidatorStateBeforeEpochEnds()` and selector `0x8efdbc05`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[etherror(
        name = "CannotMoveToLockedValidatorStateBeforeEpochEnds",
        abi = "CannotMoveToLockedValidatorStateBeforeEpochEnds()"
    )]
    pub struct CannotMoveToLockedValidatorStateBeforeEpochEnds;
    ///Custom Error type `CannotRejoinBecauseBanned` with signature `CannotRejoinBecauseBanned(address)` and selector `0x7b91b5c1`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[etherror(
        name = "CannotRejoinBecauseBanned",
        abi = "CannotRejoinBecauseBanned(address)"
    )]
    pub struct CannotRejoinBecauseBanned {
        pub staking_address: ::ethers::core::types::Address,
    }
    ///Custom Error type `CannotRejoinUntilNextEpochBecauseKicked` with signature `CannotRejoinUntilNextEpochBecauseKicked(address)` and selector `0x7c6d6c6b`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[etherror(
        name = "CannotRejoinUntilNextEpochBecauseKicked",
        abi = "CannotRejoinUntilNextEpochBecauseKicked(address)"
    )]
    pub struct CannotRejoinUntilNextEpochBecauseKicked {
        pub staking_address: ::ethers::core::types::Address,
    }
    ///Custom Error type `CannotRemoveFunctionThatDoesNotExist` with signature `CannotRemoveFunctionThatDoesNotExist(bytes4)` and selector `0x7a08a22d`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[etherror(
        name = "CannotRemoveFunctionThatDoesNotExist",
        abi = "CannotRemoveFunctionThatDoesNotExist(bytes4)"
    )]
    pub struct CannotRemoveFunctionThatDoesNotExist {
        pub selector: [u8; 4],
    }
    ///Custom Error type `CannotRemoveImmutableFunction` with signature `CannotRemoveImmutableFunction(bytes4)` and selector `0x6fafeb08`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[etherror(
        name = "CannotRemoveImmutableFunction",
        abi = "CannotRemoveImmutableFunction(bytes4)"
    )]
    pub struct CannotRemoveImmutableFunction {
        pub selector: [u8; 4],
    }
    ///Custom Error type `CannotReplaceFunctionThatDoesNotExists` with signature `CannotReplaceFunctionThatDoesNotExists(bytes4)` and selector `0x7479f939`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[etherror(
        name = "CannotReplaceFunctionThatDoesNotExists",
        abi = "CannotReplaceFunctionThatDoesNotExists(bytes4)"
    )]
    pub struct CannotReplaceFunctionThatDoesNotExists {
        pub selector: [u8; 4],
    }
    ///Custom Error type `CannotReplaceFunctionWithTheSameFunctionFromTheSameFacet` with signature `CannotReplaceFunctionWithTheSameFunctionFromTheSameFacet(bytes4)` and selector `0x358d9d1a`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[etherror(
        name = "CannotReplaceFunctionWithTheSameFunctionFromTheSameFacet",
        abi = "CannotReplaceFunctionWithTheSameFunctionFromTheSameFacet(bytes4)"
    )]
    pub struct CannotReplaceFunctionWithTheSameFunctionFromTheSameFacet {
        pub selector: [u8; 4],
    }
    ///Custom Error type `CannotReplaceFunctionsFromFacetWithZeroAddress` with signature `CannotReplaceFunctionsFromFacetWithZeroAddress(bytes4[])` and selector `0xcd98a96f`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[etherror(
        name = "CannotReplaceFunctionsFromFacetWithZeroAddress",
        abi = "CannotReplaceFunctionsFromFacetWithZeroAddress(bytes4[])"
    )]
    pub struct CannotReplaceFunctionsFromFacetWithZeroAddress {
        pub selectors: ::std::vec::Vec<[u8; 4]>,
    }
    ///Custom Error type `CannotReplaceImmutableFunction` with signature `CannotReplaceImmutableFunction(bytes4)` and selector `0x520300da`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[etherror(
        name = "CannotReplaceImmutableFunction",
        abi = "CannotReplaceImmutableFunction(bytes4)"
    )]
    pub struct CannotReplaceImmutableFunction {
        pub selector: [u8; 4],
    }
    ///Custom Error type `CannotReuseCommsKeys` with signature `CannotReuseCommsKeys(uint256,uint256)` and selector `0x1179010e`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[etherror(
        name = "CannotReuseCommsKeys",
        abi = "CannotReuseCommsKeys(uint256,uint256)"
    )]
    pub struct CannotReuseCommsKeys {
        pub sender_pub_key: ::ethers::core::types::U256,
        pub receiver_pub_key: ::ethers::core::types::U256,
    }
    ///Custom Error type `CannotStakeZero` with signature `CannotStakeZero()` and selector `0x6a76ff9f`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[etherror(name = "CannotStakeZero", abi = "CannotStakeZero()")]
    pub struct CannotStakeZero;
    ///Custom Error type `CannotVoteTwice` with signature `CannotVoteTwice(address)` and selector `0x384ce38a`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[etherror(name = "CannotVoteTwice", abi = "CannotVoteTwice(address)")]
    pub struct CannotVoteTwice {
        pub staker_address: ::ethers::core::types::Address,
    }
    ///Custom Error type `CannotWithdrawFrozen` with signature `CannotWithdrawFrozen()` and selector `0x36d90d81`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[etherror(name = "CannotWithdrawFrozen", abi = "CannotWithdrawFrozen()")]
    pub struct CannotWithdrawFrozen;
    ///Custom Error type `CannotWithdrawZero` with signature `CannotWithdrawZero()` and selector `0xc3771360`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[etherror(name = "CannotWithdrawZero", abi = "CannotWithdrawZero()")]
    pub struct CannotWithdrawZero;
    ///Custom Error type `CheckpointAheadOfCurrentEpoch` with signature `CheckpointAheadOfCurrentEpoch(uint256,uint256)` and selector `0x98a10d73`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[etherror(
        name = "CheckpointAheadOfCurrentEpoch",
        abi = "CheckpointAheadOfCurrentEpoch(uint256,uint256)"
    )]
    pub struct CheckpointAheadOfCurrentEpoch {
        pub checkpoint: ::ethers::core::types::U256,
        pub current_epoch: ::ethers::core::types::U256,
    }
    ///Custom Error type `CouldNotMapNodeAddressToStakerAddress` with signature `CouldNotMapNodeAddressToStakerAddress(address)` and selector `0x64ffeb3d`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[etherror(
        name = "CouldNotMapNodeAddressToStakerAddress",
        abi = "CouldNotMapNodeAddressToStakerAddress(address)"
    )]
    pub struct CouldNotMapNodeAddressToStakerAddress {
        pub node_address: ::ethers::core::types::Address,
    }
    ///Custom Error type `ERC721ReceiverRejectedTokens` with signature `ERC721ReceiverRejectedTokens()` and selector `0x9e64a6c4`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[etherror(
        name = "ERC721ReceiverRejectedTokens",
        abi = "ERC721ReceiverRejectedTokens()"
    )]
    pub struct ERC721ReceiverRejectedTokens;
    ///Custom Error type `ERC721TransferToNonERC721ReceiverImplementer` with signature `ERC721TransferToNonERC721ReceiverImplementer()` and selector `0x1ad78a40`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[etherror(
        name = "ERC721TransferToNonERC721ReceiverImplementer",
        abi = "ERC721TransferToNonERC721ReceiverImplementer()"
    )]
    pub struct ERC721TransferToNonERC721ReceiverImplementer;
    ///Custom Error type `IncorrectFacetCutAction` with signature `IncorrectFacetCutAction(uint8)` and selector `0x7fe9a41e`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[etherror(name = "IncorrectFacetCutAction", abi = "IncorrectFacetCutAction(uint8)")]
    pub struct IncorrectFacetCutAction {
        pub action: u8,
    }
    ///Custom Error type `InitializationFunctionReverted` with signature `InitializationFunctionReverted(address,bytes)` and selector `0x192105d7`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[etherror(
        name = "InitializationFunctionReverted",
        abi = "InitializationFunctionReverted(address,bytes)"
    )]
    pub struct InitializationFunctionReverted {
        pub initialization_contract_address: ::ethers::core::types::Address,
        pub calldata: ::ethers::core::types::Bytes,
    }
    ///Custom Error type `InsufficientSelfStake` with signature `InsufficientSelfStake(address)` and selector `0x04f12ded`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[etherror(name = "InsufficientSelfStake", abi = "InsufficientSelfStake(address)")]
    pub struct InsufficientSelfStake {
        pub staker_address: ::ethers::core::types::Address,
    }
    ///Custom Error type `InvalidAttestedAddress` with signature `InvalidAttestedAddress()` and selector `0x59f66137`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[etherror(name = "InvalidAttestedAddress", abi = "InvalidAttestedAddress()")]
    pub struct InvalidAttestedAddress;
    ///Custom Error type `InvalidNewSharePrice` with signature `InvalidNewSharePrice()` and selector `0x6039f2d8`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[etherror(name = "InvalidNewSharePrice", abi = "InvalidNewSharePrice()")]
    pub struct InvalidNewSharePrice;
    ///Custom Error type `InvalidRatio` with signature `InvalidRatio()` and selector `0x648564d3`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[etherror(name = "InvalidRatio", abi = "InvalidRatio()")]
    pub struct InvalidRatio;
    ///Custom Error type `InvalidSlashPercentage` with signature `InvalidSlashPercentage()` and selector `0x37814740`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[etherror(name = "InvalidSlashPercentage", abi = "InvalidSlashPercentage()")]
    pub struct InvalidSlashPercentage;
    ///Custom Error type `InvalidTimeLock` with signature `InvalidTimeLock()` and selector `0xe77d7d57`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[etherror(name = "InvalidTimeLock", abi = "InvalidTimeLock()")]
    pub struct InvalidTimeLock;
    ///Custom Error type `MinTimeLockNotMet` with signature `MinTimeLockNotMet(uint256,uint256)` and selector `0x9bcaa089`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[etherror(name = "MinTimeLockNotMet", abi = "MinTimeLockNotMet(uint256,uint256)")]
    pub struct MinTimeLockNotMet {
        pub time_lock: ::ethers::core::types::U256,
        pub min_time_lock: ::ethers::core::types::U256,
    }
    ///Custom Error type `MustBeInActiveOrUnlockedOrPausedState` with signature `MustBeInActiveOrUnlockedOrPausedState(uint8)` and selector `0xc1f8741d`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[etherror(
        name = "MustBeInActiveOrUnlockedOrPausedState",
        abi = "MustBeInActiveOrUnlockedOrPausedState(uint8)"
    )]
    pub struct MustBeInActiveOrUnlockedOrPausedState {
        pub state: u8,
    }
    ///Custom Error type `MustBeInActiveOrUnlockedState` with signature `MustBeInActiveOrUnlockedState(uint8)` and selector `0x9ef5b6f5`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[etherror(
        name = "MustBeInActiveOrUnlockedState",
        abi = "MustBeInActiveOrUnlockedState(uint8)"
    )]
    pub struct MustBeInActiveOrUnlockedState {
        pub state: u8,
    }
    ///Custom Error type `MustBeInNextValidatorSetLockedOrReadyForNextEpochOrRestoreState` with signature `MustBeInNextValidatorSetLockedOrReadyForNextEpochOrRestoreState(uint8)` and selector `0xf928cb7b`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[etherror(
        name = "MustBeInNextValidatorSetLockedOrReadyForNextEpochOrRestoreState",
        abi = "MustBeInNextValidatorSetLockedOrReadyForNextEpochOrRestoreState(uint8)"
    )]
    pub struct MustBeInNextValidatorSetLockedOrReadyForNextEpochOrRestoreState {
        pub state: u8,
    }
    ///Custom Error type `MustBeInNextValidatorSetLockedOrReadyForNextEpochState` with signature `MustBeInNextValidatorSetLockedOrReadyForNextEpochState(uint8)` and selector `0xe1b4c12e`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[etherror(
        name = "MustBeInNextValidatorSetLockedOrReadyForNextEpochState",
        abi = "MustBeInNextValidatorSetLockedOrReadyForNextEpochState(uint8)"
    )]
    pub struct MustBeInNextValidatorSetLockedOrReadyForNextEpochState {
        pub state: u8,
    }
    ///Custom Error type `MustBeInNextValidatorSetLockedState` with signature `MustBeInNextValidatorSetLockedState(uint8)` and selector `0x7203d9de`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[etherror(
        name = "MustBeInNextValidatorSetLockedState",
        abi = "MustBeInNextValidatorSetLockedState(uint8)"
    )]
    pub struct MustBeInNextValidatorSetLockedState {
        pub state: u8,
    }
    ///Custom Error type `MustBeInReadyForNextEpochState` with signature `MustBeInReadyForNextEpochState(uint8)` and selector `0x17ce3ae1`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[etherror(
        name = "MustBeInReadyForNextEpochState",
        abi = "MustBeInReadyForNextEpochState(uint8)"
    )]
    pub struct MustBeInReadyForNextEpochState {
        pub state: u8,
    }
    ///Custom Error type `MustBeValidatorInNextEpochToKick` with signature `MustBeValidatorInNextEpochToKick(address)` and selector `0x5f543082`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[etherror(
        name = "MustBeValidatorInNextEpochToKick",
        abi = "MustBeValidatorInNextEpochToKick(address)"
    )]
    pub struct MustBeValidatorInNextEpochToKick {
        pub staker_address: ::ethers::core::types::Address,
    }
    ///Custom Error type `NewTimeLockMustBeGreaterThanCurrent` with signature `NewTimeLockMustBeGreaterThanCurrent()` and selector `0x802d236d`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[etherror(
        name = "NewTimeLockMustBeGreaterThanCurrent",
        abi = "NewTimeLockMustBeGreaterThanCurrent()"
    )]
    pub struct NewTimeLockMustBeGreaterThanCurrent;
    ///Custom Error type `NoBytecodeAtAddress` with signature `NoBytecodeAtAddress(address,string)` and selector `0x919834b9`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[etherror(
        name = "NoBytecodeAtAddress",
        abi = "NoBytecodeAtAddress(address,string)"
    )]
    pub struct NoBytecodeAtAddress {
        pub contract_address: ::ethers::core::types::Address,
        pub message: ::std::string::String,
    }
    ///Custom Error type `NoEmptyStakeRecordSlots` with signature `NoEmptyStakeRecordSlots()` and selector `0x6330eb87`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[etherror(name = "NoEmptyStakeRecordSlots", abi = "NoEmptyStakeRecordSlots()")]
    pub struct NoEmptyStakeRecordSlots;
    ///Custom Error type `NoEmptyStakingSlot` with signature `NoEmptyStakingSlot()` and selector `0xc3b03baa`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[etherror(name = "NoEmptyStakingSlot", abi = "NoEmptyStakingSlot()")]
    pub struct NoEmptyStakingSlot;
    ///Custom Error type `NoSelectorsProvidedForFacetForCut` with signature `NoSelectorsProvidedForFacetForCut(address)` and selector `0xe767f91f`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[etherror(
        name = "NoSelectorsProvidedForFacetForCut",
        abi = "NoSelectorsProvidedForFacetForCut(address)"
    )]
    pub struct NoSelectorsProvidedForFacetForCut {
        pub facet_address: ::ethers::core::types::Address,
    }
    ///Custom Error type `NodeAddressNotFoundForStaker` with signature `NodeAddressNotFoundForStaker()` and selector `0x0722622c`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[etherror(
        name = "NodeAddressNotFoundForStaker",
        abi = "NodeAddressNotFoundForStaker()"
    )]
    pub struct NodeAddressNotFoundForStaker;
    ///Custom Error type `NotApprovedOrOwner` with signature `NotApprovedOrOwner()` and selector `0xe433766c`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[etherror(name = "NotApprovedOrOwner", abi = "NotApprovedOrOwner()")]
    pub struct NotApprovedOrOwner;
    ///Custom Error type `NotContractOwner` with signature `NotContractOwner(address,address)` and selector `0xff4127cb`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[etherror(name = "NotContractOwner", abi = "NotContractOwner(address,address)")]
    pub struct NotContractOwner {
        pub user: ::ethers::core::types::Address,
        pub contract_owner: ::ethers::core::types::Address,
    }
    ///Custom Error type `NotEnoughTimeElapsedForTimeoutSinceLastEpoch` with signature `NotEnoughTimeElapsedForTimeoutSinceLastEpoch(uint256,uint256,uint256)` and selector `0x9312e856`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[etherror(
        name = "NotEnoughTimeElapsedForTimeoutSinceLastEpoch",
        abi = "NotEnoughTimeElapsedForTimeoutSinceLastEpoch(uint256,uint256,uint256)"
    )]
    pub struct NotEnoughTimeElapsedForTimeoutSinceLastEpoch {
        pub current_timestamp: ::ethers::core::types::U256,
        pub epoch_end_time: ::ethers::core::types::U256,
        pub timeout: ::ethers::core::types::U256,
    }
    ///Custom Error type `NotEnoughTimeElapsedSinceLastEpoch` with signature `NotEnoughTimeElapsedSinceLastEpoch(uint256,uint256)` and selector `0xf44bc0a7`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[etherror(
        name = "NotEnoughTimeElapsedSinceLastEpoch",
        abi = "NotEnoughTimeElapsedSinceLastEpoch(uint256,uint256)"
    )]
    pub struct NotEnoughTimeElapsedSinceLastEpoch {
        pub current_timestamp: ::ethers::core::types::U256,
        pub epoch_end_time: ::ethers::core::types::U256,
    }
    ///Custom Error type `NotEnoughValidatorsInNextEpoch` with signature `NotEnoughValidatorsInNextEpoch(uint256,uint256)` and selector `0x8a0defa4`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[etherror(
        name = "NotEnoughValidatorsInNextEpoch",
        abi = "NotEnoughValidatorsInNextEpoch(uint256,uint256)"
    )]
    pub struct NotEnoughValidatorsInNextEpoch {
        pub validator_count: ::ethers::core::types::U256,
        pub minimum_validator_count: ::ethers::core::types::U256,
    }
    ///Custom Error type `NotEnoughValidatorsReadyForNextEpoch` with signature `NotEnoughValidatorsReadyForNextEpoch(uint256,uint256,uint256)` and selector `0x26d6b3de`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[etherror(
        name = "NotEnoughValidatorsReadyForNextEpoch",
        abi = "NotEnoughValidatorsReadyForNextEpoch(uint256,uint256,uint256)"
    )]
    pub struct NotEnoughValidatorsReadyForNextEpoch {
        pub current_ready_validator_count: ::ethers::core::types::U256,
        pub next_ready_validator_count: ::ethers::core::types::U256,
        pub minimum_validator_count_to_be_ready: ::ethers::core::types::U256,
    }
    ///Custom Error type `NotOwner` with signature `NotOwner()` and selector `0x30cd7471`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[etherror(name = "NotOwner", abi = "NotOwner()")]
    pub struct NotOwner;
    ///Custom Error type `RealmIdNotFound` with signature `RealmIdNotFound(address)` and selector `0x4d1e0bab`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[etherror(name = "RealmIdNotFound", abi = "RealmIdNotFound(address)")]
    pub struct RealmIdNotFound {
        pub staker_address: ::ethers::core::types::Address,
    }
    ///Custom Error type `RemoveFacetAddressMustBeZeroAddress` with signature `RemoveFacetAddressMustBeZeroAddress(address)` and selector `0xd091bc81`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[etherror(
        name = "RemoveFacetAddressMustBeZeroAddress",
        abi = "RemoveFacetAddressMustBeZeroAddress(address)"
    )]
    pub struct RemoveFacetAddressMustBeZeroAddress {
        pub facet_address: ::ethers::core::types::Address,
    }
    ///Custom Error type `RewardsMustBeClaimed` with signature `RewardsMustBeClaimed()` and selector `0xdd20a5af`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[etherror(name = "RewardsMustBeClaimed", abi = "RewardsMustBeClaimed()")]
    pub struct RewardsMustBeClaimed;
    ///Custom Error type `SameAddress` with signature `SameAddress()` and selector `0x367558c3`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[etherror(name = "SameAddress", abi = "SameAddress()")]
    pub struct SameAddress;
    ///Custom Error type `SignaledReadyForWrongEpochNumber` with signature `SignaledReadyForWrongEpochNumber(uint256,uint256)` and selector `0x068cde2a`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[etherror(
        name = "SignaledReadyForWrongEpochNumber",
        abi = "SignaledReadyForWrongEpochNumber(uint256,uint256)"
    )]
    pub struct SignaledReadyForWrongEpochNumber {
        pub current_epoch_number: ::ethers::core::types::U256,
        pub received_epoch_number: ::ethers::core::types::U256,
    }
    ///Custom Error type `SlashingMustOccurInSameRealm` with signature `SlashingMustOccurInSameRealm(address,uint256,address,uint256)` and selector `0x9ac37887`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[etherror(
        name = "SlashingMustOccurInSameRealm",
        abi = "SlashingMustOccurInSameRealm(address,uint256,address,uint256)"
    )]
    pub struct SlashingMustOccurInSameRealm {
        pub slahed_address: ::ethers::core::types::Address,
        pub slashed_realm_id: ::ethers::core::types::U256,
        pub sender_address: ::ethers::core::types::Address,
        pub sender_realm_id: ::ethers::core::types::U256,
    }
    ///Custom Error type `StakeAmountNotMet` with signature `StakeAmountNotMet(uint256)` and selector `0xd15fec9f`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[etherror(name = "StakeAmountNotMet", abi = "StakeAmountNotMet(uint256)")]
    pub struct StakeAmountNotMet {
        pub amount: ::ethers::core::types::U256,
    }
    ///Custom Error type `StakeMustBeGreaterThanMinimumStake` with signature `StakeMustBeGreaterThanMinimumStake(address,uint256,uint256)` and selector `0xb72e1699`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[etherror(
        name = "StakeMustBeGreaterThanMinimumStake",
        abi = "StakeMustBeGreaterThanMinimumStake(address,uint256,uint256)"
    )]
    pub struct StakeMustBeGreaterThanMinimumStake {
        pub staker_address: ::ethers::core::types::Address,
        pub staked_amount: ::ethers::core::types::U256,
        pub minimum_stake: ::ethers::core::types::U256,
    }
    ///Custom Error type `StakeRecordNotFound` with signature `StakeRecordNotFound(uint256)` and selector `0x358ef7ec`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[etherror(name = "StakeRecordNotFound", abi = "StakeRecordNotFound(uint256)")]
    pub struct StakeRecordNotFound {
        pub stake_record_id: ::ethers::core::types::U256,
    }
    ///Custom Error type `StakerAddressMismatch` with signature `StakerAddressMismatch(address,address,address)` and selector `0x9cb1bb26`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[etherror(
        name = "StakerAddressMismatch",
        abi = "StakerAddressMismatch(address,address,address)"
    )]
    pub struct StakerAddressMismatch {
        pub sender_address: ::ethers::core::types::Address,
        pub operator_address: ::ethers::core::types::Address,
        pub staker_address: ::ethers::core::types::Address,
    }
    ///Custom Error type `TimeLockNotMet` with signature `TimeLockNotMet()` and selector `0xc2244eb3`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[etherror(name = "TimeLockNotMet", abi = "TimeLockNotMet()")]
    pub struct TimeLockNotMet;
    ///Custom Error type `TooSoonToWithdraw` with signature `TooSoonToWithdraw()` and selector `0xba28c410`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[etherror(name = "TooSoonToWithdraw", abi = "TooSoonToWithdraw()")]
    pub struct TooSoonToWithdraw;
    ///Custom Error type `TryingToWithdrawMoreThanStaked` with signature `TryingToWithdrawMoreThanStaked(uint256,uint256)` and selector `0xfdf3c18d`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[etherror(
        name = "TryingToWithdrawMoreThanStaked",
        abi = "TryingToWithdrawMoreThanStaked(uint256,uint256)"
    )]
    pub struct TryingToWithdrawMoreThanStaked {
        pub your_balance: ::ethers::core::types::U256,
        pub requested_withdrawl_amount: ::ethers::core::types::U256,
    }
    ///Custom Error type `ValidatorAlreadyInNextValidatorSet` with signature `ValidatorAlreadyInNextValidatorSet(address)` and selector `0xfd67040a`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[etherror(
        name = "ValidatorAlreadyInNextValidatorSet",
        abi = "ValidatorAlreadyInNextValidatorSet(address)"
    )]
    pub struct ValidatorAlreadyInNextValidatorSet {
        pub staker: ::ethers::core::types::Address,
    }
    ///Custom Error type `ValidatorAlreadyInRealm` with signature `ValidatorAlreadyInRealm(address,uint256)` and selector `0x7efe180d`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[etherror(
        name = "ValidatorAlreadyInRealm",
        abi = "ValidatorAlreadyInRealm(address,uint256)"
    )]
    pub struct ValidatorAlreadyInRealm {
        pub staker: ::ethers::core::types::Address,
        pub existing_realm_id: ::ethers::core::types::U256,
    }
    ///Custom Error type `ValidatorIsNotInNextEpoch` with signature `ValidatorIsNotInNextEpoch(address,address[])` and selector `0xa3113c0e`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[etherror(
        name = "ValidatorIsNotInNextEpoch",
        abi = "ValidatorIsNotInNextEpoch(address,address[])"
    )]
    pub struct ValidatorIsNotInNextEpoch {
        pub validator: ::ethers::core::types::Address,
        pub validators_in_next_epoch: ::std::vec::Vec<::ethers::core::types::Address>,
    }
    ///Custom Error type `ValidatorNotInNextEpoch` with signature `ValidatorNotInNextEpoch(address)` and selector `0x74bd9393`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[etherror(
        name = "ValidatorNotInNextEpoch",
        abi = "ValidatorNotInNextEpoch(address)"
    )]
    pub struct ValidatorNotInNextEpoch {
        pub staker: ::ethers::core::types::Address,
    }
    ///Custom Error type `ValidatorNotPermitted` with signature `ValidatorNotPermitted(address,uint256)` and selector `0x69c355e5`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[etherror(
        name = "ValidatorNotPermitted",
        abi = "ValidatorNotPermitted(address,uint256)"
    )]
    pub struct ValidatorNotPermitted {
        pub validator_address: ::ethers::core::types::Address,
        pub realm_id: ::ethers::core::types::U256,
    }
    ///Custom Error type `ValidatorNotRegistered` with signature `ValidatorNotRegistered(address)` and selector `0x4049c7c6`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[etherror(name = "ValidatorNotRegistered", abi = "ValidatorNotRegistered(address)")]
    pub struct ValidatorNotRegistered {
        pub validator_address: ::ethers::core::types::Address,
    }
    ///Custom Error type `ValidatorRegisterAttestedWalletDisabled` with signature `ValidatorRegisterAttestedWalletDisabled()` and selector `0x0f1c4833`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[etherror(
        name = "ValidatorRegisterAttestedWalletDisabled",
        abi = "ValidatorRegisterAttestedWalletDisabled()"
    )]
    pub struct ValidatorRegisterAttestedWalletDisabled;
    ///Custom Error type `ValueMustBeNonzero` with signature `ValueMustBeNonzero(string)` and selector `0x15c46e7e`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[etherror(name = "ValueMustBeNonzero", abi = "ValueMustBeNonzero(string)")]
    pub struct ValueMustBeNonzero {
        pub value_name: ::std::string::String,
    }
    ///Custom Error type `ZeroAddress` with signature `ZeroAddress()` and selector `0xd92e233d`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[etherror(name = "ZeroAddress", abi = "ZeroAddress()")]
    pub struct ZeroAddress;
    ///Container type for all of the contract's custom errors
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        serde::Serialize,
        serde::Deserialize,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub enum StakingErrors {
        ActiveValidatorsCannotLeave(ActiveValidatorsCannotLeave),
        CallerNotContract(CallerNotContract),
        CallerNotOwner(CallerNotOwner),
        CallerNotOwnerOrDevopsAdmin(CallerNotOwnerOrDevopsAdmin),
        CannotAddFunctionToDiamondThatAlreadyExists(
            CannotAddFunctionToDiamondThatAlreadyExists,
        ),
        CannotAddSelectorsToZeroAddress(CannotAddSelectorsToZeroAddress),
        CannotKickBelowCurrentValidatorThreshold(
            CannotKickBelowCurrentValidatorThreshold,
        ),
        CannotMigrateFromValidator(CannotMigrateFromValidator),
        CannotModifyUnfrozen(CannotModifyUnfrozen),
        CannotMoveToLockedValidatorStateBeforeEpochEnds(
            CannotMoveToLockedValidatorStateBeforeEpochEnds,
        ),
        CannotRejoinBecauseBanned(CannotRejoinBecauseBanned),
        CannotRejoinUntilNextEpochBecauseKicked(CannotRejoinUntilNextEpochBecauseKicked),
        CannotRemoveFunctionThatDoesNotExist(CannotRemoveFunctionThatDoesNotExist),
        CannotRemoveImmutableFunction(CannotRemoveImmutableFunction),
        CannotReplaceFunctionThatDoesNotExists(CannotReplaceFunctionThatDoesNotExists),
        CannotReplaceFunctionWithTheSameFunctionFromTheSameFacet(
            CannotReplaceFunctionWithTheSameFunctionFromTheSameFacet,
        ),
        CannotReplaceFunctionsFromFacetWithZeroAddress(
            CannotReplaceFunctionsFromFacetWithZeroAddress,
        ),
        CannotReplaceImmutableFunction(CannotReplaceImmutableFunction),
        CannotReuseCommsKeys(CannotReuseCommsKeys),
        CannotStakeZero(CannotStakeZero),
        CannotVoteTwice(CannotVoteTwice),
        CannotWithdrawFrozen(CannotWithdrawFrozen),
        CannotWithdrawZero(CannotWithdrawZero),
        CheckpointAheadOfCurrentEpoch(CheckpointAheadOfCurrentEpoch),
        CouldNotMapNodeAddressToStakerAddress(CouldNotMapNodeAddressToStakerAddress),
        ERC721ReceiverRejectedTokens(ERC721ReceiverRejectedTokens),
        ERC721TransferToNonERC721ReceiverImplementer(
            ERC721TransferToNonERC721ReceiverImplementer,
        ),
        IncorrectFacetCutAction(IncorrectFacetCutAction),
        InitializationFunctionReverted(InitializationFunctionReverted),
        InsufficientSelfStake(InsufficientSelfStake),
        InvalidAttestedAddress(InvalidAttestedAddress),
        InvalidNewSharePrice(InvalidNewSharePrice),
        InvalidRatio(InvalidRatio),
        InvalidSlashPercentage(InvalidSlashPercentage),
        InvalidTimeLock(InvalidTimeLock),
        MinTimeLockNotMet(MinTimeLockNotMet),
        MustBeInActiveOrUnlockedOrPausedState(MustBeInActiveOrUnlockedOrPausedState),
        MustBeInActiveOrUnlockedState(MustBeInActiveOrUnlockedState),
        MustBeInNextValidatorSetLockedOrReadyForNextEpochOrRestoreState(
            MustBeInNextValidatorSetLockedOrReadyForNextEpochOrRestoreState,
        ),
        MustBeInNextValidatorSetLockedOrReadyForNextEpochState(
            MustBeInNextValidatorSetLockedOrReadyForNextEpochState,
        ),
        MustBeInNextValidatorSetLockedState(MustBeInNextValidatorSetLockedState),
        MustBeInReadyForNextEpochState(MustBeInReadyForNextEpochState),
        MustBeValidatorInNextEpochToKick(MustBeValidatorInNextEpochToKick),
        NewTimeLockMustBeGreaterThanCurrent(NewTimeLockMustBeGreaterThanCurrent),
        NoBytecodeAtAddress(NoBytecodeAtAddress),
        NoEmptyStakeRecordSlots(NoEmptyStakeRecordSlots),
        NoEmptyStakingSlot(NoEmptyStakingSlot),
        NoSelectorsProvidedForFacetForCut(NoSelectorsProvidedForFacetForCut),
        NodeAddressNotFoundForStaker(NodeAddressNotFoundForStaker),
        NotApprovedOrOwner(NotApprovedOrOwner),
        NotContractOwner(NotContractOwner),
        NotEnoughTimeElapsedForTimeoutSinceLastEpoch(
            NotEnoughTimeElapsedForTimeoutSinceLastEpoch,
        ),
        NotEnoughTimeElapsedSinceLastEpoch(NotEnoughTimeElapsedSinceLastEpoch),
        NotEnoughValidatorsInNextEpoch(NotEnoughValidatorsInNextEpoch),
        NotEnoughValidatorsReadyForNextEpoch(NotEnoughValidatorsReadyForNextEpoch),
        NotOwner(NotOwner),
        RealmIdNotFound(RealmIdNotFound),
        RemoveFacetAddressMustBeZeroAddress(RemoveFacetAddressMustBeZeroAddress),
        RewardsMustBeClaimed(RewardsMustBeClaimed),
        SameAddress(SameAddress),
        SignaledReadyForWrongEpochNumber(SignaledReadyForWrongEpochNumber),
        SlashingMustOccurInSameRealm(SlashingMustOccurInSameRealm),
        StakeAmountNotMet(StakeAmountNotMet),
        StakeMustBeGreaterThanMinimumStake(StakeMustBeGreaterThanMinimumStake),
        StakeRecordNotFound(StakeRecordNotFound),
        StakerAddressMismatch(StakerAddressMismatch),
        TimeLockNotMet(TimeLockNotMet),
        TooSoonToWithdraw(TooSoonToWithdraw),
        TryingToWithdrawMoreThanStaked(TryingToWithdrawMoreThanStaked),
        ValidatorAlreadyInNextValidatorSet(ValidatorAlreadyInNextValidatorSet),
        ValidatorAlreadyInRealm(ValidatorAlreadyInRealm),
        ValidatorIsNotInNextEpoch(ValidatorIsNotInNextEpoch),
        ValidatorNotInNextEpoch(ValidatorNotInNextEpoch),
        ValidatorNotPermitted(ValidatorNotPermitted),
        ValidatorNotRegistered(ValidatorNotRegistered),
        ValidatorRegisterAttestedWalletDisabled(ValidatorRegisterAttestedWalletDisabled),
        ValueMustBeNonzero(ValueMustBeNonzero),
        ZeroAddress(ZeroAddress),
        /// The standard solidity revert string, with selector
        /// Error(string) -- 0x08c379a0
        RevertString(::std::string::String),
    }
    impl ::ethers::core::abi::AbiDecode for StakingErrors {
        fn decode(
            data: impl AsRef<[u8]>,
        ) -> ::core::result::Result<Self, ::ethers::core::abi::AbiError> {
            let data = data.as_ref();
            if let Ok(decoded) = <::std::string::String as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::RevertString(decoded));
            }
            if let Ok(decoded) = <ActiveValidatorsCannotLeave as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::ActiveValidatorsCannotLeave(decoded));
            }
            if let Ok(decoded) = <CallerNotContract as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::CallerNotContract(decoded));
            }
            if let Ok(decoded) = <CallerNotOwner as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::CallerNotOwner(decoded));
            }
            if let Ok(decoded) = <CallerNotOwnerOrDevopsAdmin as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::CallerNotOwnerOrDevopsAdmin(decoded));
            }
            if let Ok(decoded) = <CannotAddFunctionToDiamondThatAlreadyExists as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::CannotAddFunctionToDiamondThatAlreadyExists(decoded));
            }
            if let Ok(decoded) = <CannotAddSelectorsToZeroAddress as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::CannotAddSelectorsToZeroAddress(decoded));
            }
            if let Ok(decoded) = <CannotKickBelowCurrentValidatorThreshold as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::CannotKickBelowCurrentValidatorThreshold(decoded));
            }
            if let Ok(decoded) = <CannotMigrateFromValidator as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::CannotMigrateFromValidator(decoded));
            }
            if let Ok(decoded) = <CannotModifyUnfrozen as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::CannotModifyUnfrozen(decoded));
            }
            if let Ok(decoded) = <CannotMoveToLockedValidatorStateBeforeEpochEnds as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(
                    Self::CannotMoveToLockedValidatorStateBeforeEpochEnds(decoded),
                );
            }
            if let Ok(decoded) = <CannotRejoinBecauseBanned as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::CannotRejoinBecauseBanned(decoded));
            }
            if let Ok(decoded) = <CannotRejoinUntilNextEpochBecauseKicked as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::CannotRejoinUntilNextEpochBecauseKicked(decoded));
            }
            if let Ok(decoded) = <CannotRemoveFunctionThatDoesNotExist as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::CannotRemoveFunctionThatDoesNotExist(decoded));
            }
            if let Ok(decoded) = <CannotRemoveImmutableFunction as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::CannotRemoveImmutableFunction(decoded));
            }
            if let Ok(decoded) = <CannotReplaceFunctionThatDoesNotExists as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::CannotReplaceFunctionThatDoesNotExists(decoded));
            }
            if let Ok(decoded) = <CannotReplaceFunctionWithTheSameFunctionFromTheSameFacet as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(
                    Self::CannotReplaceFunctionWithTheSameFunctionFromTheSameFacet(
                        decoded,
                    ),
                );
            }
            if let Ok(decoded) = <CannotReplaceFunctionsFromFacetWithZeroAddress as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::CannotReplaceFunctionsFromFacetWithZeroAddress(decoded));
            }
            if let Ok(decoded) = <CannotReplaceImmutableFunction as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::CannotReplaceImmutableFunction(decoded));
            }
            if let Ok(decoded) = <CannotReuseCommsKeys as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::CannotReuseCommsKeys(decoded));
            }
            if let Ok(decoded) = <CannotStakeZero as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::CannotStakeZero(decoded));
            }
            if let Ok(decoded) = <CannotVoteTwice as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::CannotVoteTwice(decoded));
            }
            if let Ok(decoded) = <CannotWithdrawFrozen as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::CannotWithdrawFrozen(decoded));
            }
            if let Ok(decoded) = <CannotWithdrawZero as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::CannotWithdrawZero(decoded));
            }
            if let Ok(decoded) = <CheckpointAheadOfCurrentEpoch as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::CheckpointAheadOfCurrentEpoch(decoded));
            }
            if let Ok(decoded) = <CouldNotMapNodeAddressToStakerAddress as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::CouldNotMapNodeAddressToStakerAddress(decoded));
            }
            if let Ok(decoded) = <ERC721ReceiverRejectedTokens as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::ERC721ReceiverRejectedTokens(decoded));
            }
            if let Ok(decoded) = <ERC721TransferToNonERC721ReceiverImplementer as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::ERC721TransferToNonERC721ReceiverImplementer(decoded));
            }
            if let Ok(decoded) = <IncorrectFacetCutAction as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::IncorrectFacetCutAction(decoded));
            }
            if let Ok(decoded) = <InitializationFunctionReverted as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::InitializationFunctionReverted(decoded));
            }
            if let Ok(decoded) = <InsufficientSelfStake as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::InsufficientSelfStake(decoded));
            }
            if let Ok(decoded) = <InvalidAttestedAddress as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::InvalidAttestedAddress(decoded));
            }
            if let Ok(decoded) = <InvalidNewSharePrice as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::InvalidNewSharePrice(decoded));
            }
            if let Ok(decoded) = <InvalidRatio as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::InvalidRatio(decoded));
            }
            if let Ok(decoded) = <InvalidSlashPercentage as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::InvalidSlashPercentage(decoded));
            }
            if let Ok(decoded) = <InvalidTimeLock as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::InvalidTimeLock(decoded));
            }
            if let Ok(decoded) = <MinTimeLockNotMet as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::MinTimeLockNotMet(decoded));
            }
            if let Ok(decoded) = <MustBeInActiveOrUnlockedOrPausedState as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::MustBeInActiveOrUnlockedOrPausedState(decoded));
            }
            if let Ok(decoded) = <MustBeInActiveOrUnlockedState as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::MustBeInActiveOrUnlockedState(decoded));
            }
            if let Ok(decoded) = <MustBeInNextValidatorSetLockedOrReadyForNextEpochOrRestoreState as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(
                    Self::MustBeInNextValidatorSetLockedOrReadyForNextEpochOrRestoreState(
                        decoded,
                    ),
                );
            }
            if let Ok(decoded) = <MustBeInNextValidatorSetLockedOrReadyForNextEpochState as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(
                    Self::MustBeInNextValidatorSetLockedOrReadyForNextEpochState(decoded),
                );
            }
            if let Ok(decoded) = <MustBeInNextValidatorSetLockedState as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::MustBeInNextValidatorSetLockedState(decoded));
            }
            if let Ok(decoded) = <MustBeInReadyForNextEpochState as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::MustBeInReadyForNextEpochState(decoded));
            }
            if let Ok(decoded) = <MustBeValidatorInNextEpochToKick as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::MustBeValidatorInNextEpochToKick(decoded));
            }
            if let Ok(decoded) = <NewTimeLockMustBeGreaterThanCurrent as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::NewTimeLockMustBeGreaterThanCurrent(decoded));
            }
            if let Ok(decoded) = <NoBytecodeAtAddress as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::NoBytecodeAtAddress(decoded));
            }
            if let Ok(decoded) = <NoEmptyStakeRecordSlots as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::NoEmptyStakeRecordSlots(decoded));
            }
            if let Ok(decoded) = <NoEmptyStakingSlot as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::NoEmptyStakingSlot(decoded));
            }
            if let Ok(decoded) = <NoSelectorsProvidedForFacetForCut as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::NoSelectorsProvidedForFacetForCut(decoded));
            }
            if let Ok(decoded) = <NodeAddressNotFoundForStaker as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::NodeAddressNotFoundForStaker(decoded));
            }
            if let Ok(decoded) = <NotApprovedOrOwner as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::NotApprovedOrOwner(decoded));
            }
            if let Ok(decoded) = <NotContractOwner as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::NotContractOwner(decoded));
            }
            if let Ok(decoded) = <NotEnoughTimeElapsedForTimeoutSinceLastEpoch as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::NotEnoughTimeElapsedForTimeoutSinceLastEpoch(decoded));
            }
            if let Ok(decoded) = <NotEnoughTimeElapsedSinceLastEpoch as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::NotEnoughTimeElapsedSinceLastEpoch(decoded));
            }
            if let Ok(decoded) = <NotEnoughValidatorsInNextEpoch as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::NotEnoughValidatorsInNextEpoch(decoded));
            }
            if let Ok(decoded) = <NotEnoughValidatorsReadyForNextEpoch as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::NotEnoughValidatorsReadyForNextEpoch(decoded));
            }
            if let Ok(decoded) = <NotOwner as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::NotOwner(decoded));
            }
            if let Ok(decoded) = <RealmIdNotFound as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::RealmIdNotFound(decoded));
            }
            if let Ok(decoded) = <RemoveFacetAddressMustBeZeroAddress as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::RemoveFacetAddressMustBeZeroAddress(decoded));
            }
            if let Ok(decoded) = <RewardsMustBeClaimed as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::RewardsMustBeClaimed(decoded));
            }
            if let Ok(decoded) = <SameAddress as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::SameAddress(decoded));
            }
            if let Ok(decoded) = <SignaledReadyForWrongEpochNumber as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::SignaledReadyForWrongEpochNumber(decoded));
            }
            if let Ok(decoded) = <SlashingMustOccurInSameRealm as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::SlashingMustOccurInSameRealm(decoded));
            }
            if let Ok(decoded) = <StakeAmountNotMet as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::StakeAmountNotMet(decoded));
            }
            if let Ok(decoded) = <StakeMustBeGreaterThanMinimumStake as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::StakeMustBeGreaterThanMinimumStake(decoded));
            }
            if let Ok(decoded) = <StakeRecordNotFound as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::StakeRecordNotFound(decoded));
            }
            if let Ok(decoded) = <StakerAddressMismatch as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::StakerAddressMismatch(decoded));
            }
            if let Ok(decoded) = <TimeLockNotMet as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::TimeLockNotMet(decoded));
            }
            if let Ok(decoded) = <TooSoonToWithdraw as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::TooSoonToWithdraw(decoded));
            }
            if let Ok(decoded) = <TryingToWithdrawMoreThanStaked as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::TryingToWithdrawMoreThanStaked(decoded));
            }
            if let Ok(decoded) = <ValidatorAlreadyInNextValidatorSet as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::ValidatorAlreadyInNextValidatorSet(decoded));
            }
            if let Ok(decoded) = <ValidatorAlreadyInRealm as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::ValidatorAlreadyInRealm(decoded));
            }
            if let Ok(decoded) = <ValidatorIsNotInNextEpoch as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::ValidatorIsNotInNextEpoch(decoded));
            }
            if let Ok(decoded) = <ValidatorNotInNextEpoch as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::ValidatorNotInNextEpoch(decoded));
            }
            if let Ok(decoded) = <ValidatorNotPermitted as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::ValidatorNotPermitted(decoded));
            }
            if let Ok(decoded) = <ValidatorNotRegistered as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::ValidatorNotRegistered(decoded));
            }
            if let Ok(decoded) = <ValidatorRegisterAttestedWalletDisabled as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::ValidatorRegisterAttestedWalletDisabled(decoded));
            }
            if let Ok(decoded) = <ValueMustBeNonzero as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::ValueMustBeNonzero(decoded));
            }
            if let Ok(decoded) = <ZeroAddress as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::ZeroAddress(decoded));
            }
            Err(::ethers::core::abi::Error::InvalidData.into())
        }
    }
    impl ::ethers::core::abi::AbiEncode for StakingErrors {
        fn encode(self) -> ::std::vec::Vec<u8> {
            match self {
                Self::ActiveValidatorsCannotLeave(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::CallerNotContract(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::CallerNotOwner(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::CallerNotOwnerOrDevopsAdmin(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::CannotAddFunctionToDiamondThatAlreadyExists(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::CannotAddSelectorsToZeroAddress(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::CannotKickBelowCurrentValidatorThreshold(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::CannotMigrateFromValidator(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::CannotModifyUnfrozen(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::CannotMoveToLockedValidatorStateBeforeEpochEnds(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::CannotRejoinBecauseBanned(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::CannotRejoinUntilNextEpochBecauseKicked(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::CannotRemoveFunctionThatDoesNotExist(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::CannotRemoveImmutableFunction(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::CannotReplaceFunctionThatDoesNotExists(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::CannotReplaceFunctionWithTheSameFunctionFromTheSameFacet(
                    element,
                ) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::CannotReplaceFunctionsFromFacetWithZeroAddress(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::CannotReplaceImmutableFunction(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::CannotReuseCommsKeys(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::CannotStakeZero(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::CannotVoteTwice(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::CannotWithdrawFrozen(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::CannotWithdrawZero(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::CheckpointAheadOfCurrentEpoch(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::CouldNotMapNodeAddressToStakerAddress(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::ERC721ReceiverRejectedTokens(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::ERC721TransferToNonERC721ReceiverImplementer(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::IncorrectFacetCutAction(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::InitializationFunctionReverted(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::InsufficientSelfStake(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::InvalidAttestedAddress(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::InvalidNewSharePrice(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::InvalidRatio(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::InvalidSlashPercentage(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::InvalidTimeLock(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::MinTimeLockNotMet(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::MustBeInActiveOrUnlockedOrPausedState(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::MustBeInActiveOrUnlockedState(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::MustBeInNextValidatorSetLockedOrReadyForNextEpochOrRestoreState(
                    element,
                ) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::MustBeInNextValidatorSetLockedOrReadyForNextEpochState(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::MustBeInNextValidatorSetLockedState(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::MustBeInReadyForNextEpochState(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::MustBeValidatorInNextEpochToKick(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::NewTimeLockMustBeGreaterThanCurrent(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::NoBytecodeAtAddress(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::NoEmptyStakeRecordSlots(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::NoEmptyStakingSlot(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::NoSelectorsProvidedForFacetForCut(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::NodeAddressNotFoundForStaker(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::NotApprovedOrOwner(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::NotContractOwner(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::NotEnoughTimeElapsedForTimeoutSinceLastEpoch(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::NotEnoughTimeElapsedSinceLastEpoch(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::NotEnoughValidatorsInNextEpoch(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::NotEnoughValidatorsReadyForNextEpoch(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::NotOwner(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::RealmIdNotFound(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::RemoveFacetAddressMustBeZeroAddress(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::RewardsMustBeClaimed(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::SameAddress(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::SignaledReadyForWrongEpochNumber(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::SlashingMustOccurInSameRealm(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::StakeAmountNotMet(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::StakeMustBeGreaterThanMinimumStake(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::StakeRecordNotFound(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::StakerAddressMismatch(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::TimeLockNotMet(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::TooSoonToWithdraw(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::TryingToWithdrawMoreThanStaked(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::ValidatorAlreadyInNextValidatorSet(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::ValidatorAlreadyInRealm(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::ValidatorIsNotInNextEpoch(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::ValidatorNotInNextEpoch(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::ValidatorNotPermitted(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::ValidatorNotRegistered(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::ValidatorRegisterAttestedWalletDisabled(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::ValueMustBeNonzero(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::ZeroAddress(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::RevertString(s) => ::ethers::core::abi::AbiEncode::encode(s),
            }
        }
    }
    impl ::ethers::contract::ContractRevert for StakingErrors {
        fn valid_selector(selector: [u8; 4]) -> bool {
            match selector {
                [0x08, 0xc3, 0x79, 0xa0] => true,
                _ if selector
                    == <ActiveValidatorsCannotLeave as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <CallerNotContract as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <CallerNotOwner as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <CallerNotOwnerOrDevopsAdmin as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <CannotAddFunctionToDiamondThatAlreadyExists as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <CannotAddSelectorsToZeroAddress as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <CannotKickBelowCurrentValidatorThreshold as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <CannotMigrateFromValidator as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <CannotModifyUnfrozen as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <CannotMoveToLockedValidatorStateBeforeEpochEnds as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <CannotRejoinBecauseBanned as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <CannotRejoinUntilNextEpochBecauseKicked as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <CannotRemoveFunctionThatDoesNotExist as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <CannotRemoveImmutableFunction as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <CannotReplaceFunctionThatDoesNotExists as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <CannotReplaceFunctionWithTheSameFunctionFromTheSameFacet as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <CannotReplaceFunctionsFromFacetWithZeroAddress as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <CannotReplaceImmutableFunction as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <CannotReuseCommsKeys as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <CannotStakeZero as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <CannotVoteTwice as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <CannotWithdrawFrozen as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <CannotWithdrawZero as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <CheckpointAheadOfCurrentEpoch as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <CouldNotMapNodeAddressToStakerAddress as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <ERC721ReceiverRejectedTokens as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <ERC721TransferToNonERC721ReceiverImplementer as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <IncorrectFacetCutAction as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <InitializationFunctionReverted as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <InsufficientSelfStake as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <InvalidAttestedAddress as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <InvalidNewSharePrice as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <InvalidRatio as ::ethers::contract::EthError>::selector() => true,
                _ if selector
                    == <InvalidSlashPercentage as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <InvalidTimeLock as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <MinTimeLockNotMet as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <MustBeInActiveOrUnlockedOrPausedState as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <MustBeInActiveOrUnlockedState as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <MustBeInNextValidatorSetLockedOrReadyForNextEpochOrRestoreState as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <MustBeInNextValidatorSetLockedOrReadyForNextEpochState as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <MustBeInNextValidatorSetLockedState as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <MustBeInReadyForNextEpochState as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <MustBeValidatorInNextEpochToKick as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <NewTimeLockMustBeGreaterThanCurrent as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <NoBytecodeAtAddress as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <NoEmptyStakeRecordSlots as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <NoEmptyStakingSlot as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <NoSelectorsProvidedForFacetForCut as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <NodeAddressNotFoundForStaker as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <NotApprovedOrOwner as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <NotContractOwner as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <NotEnoughTimeElapsedForTimeoutSinceLastEpoch as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <NotEnoughTimeElapsedSinceLastEpoch as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <NotEnoughValidatorsInNextEpoch as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <NotEnoughValidatorsReadyForNextEpoch as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <NotOwner as ::ethers::contract::EthError>::selector() => true,
                _ if selector
                    == <RealmIdNotFound as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <RemoveFacetAddressMustBeZeroAddress as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <RewardsMustBeClaimed as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <SameAddress as ::ethers::contract::EthError>::selector() => true,
                _ if selector
                    == <SignaledReadyForWrongEpochNumber as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <SlashingMustOccurInSameRealm as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <StakeAmountNotMet as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <StakeMustBeGreaterThanMinimumStake as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <StakeRecordNotFound as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <StakerAddressMismatch as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <TimeLockNotMet as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <TooSoonToWithdraw as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <TryingToWithdrawMoreThanStaked as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <ValidatorAlreadyInNextValidatorSet as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <ValidatorAlreadyInRealm as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <ValidatorIsNotInNextEpoch as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <ValidatorNotInNextEpoch as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <ValidatorNotPermitted as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <ValidatorNotRegistered as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <ValidatorRegisterAttestedWalletDisabled as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <ValueMustBeNonzero as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <ZeroAddress as ::ethers::contract::EthError>::selector() => true,
                _ => false,
            }
        }
    }
    impl ::core::fmt::Display for StakingErrors {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            match self {
                Self::ActiveValidatorsCannotLeave(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::CallerNotContract(element) => ::core::fmt::Display::fmt(element, f),
                Self::CallerNotOwner(element) => ::core::fmt::Display::fmt(element, f),
                Self::CallerNotOwnerOrDevopsAdmin(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::CannotAddFunctionToDiamondThatAlreadyExists(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::CannotAddSelectorsToZeroAddress(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::CannotKickBelowCurrentValidatorThreshold(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::CannotMigrateFromValidator(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::CannotModifyUnfrozen(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::CannotMoveToLockedValidatorStateBeforeEpochEnds(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::CannotRejoinBecauseBanned(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::CannotRejoinUntilNextEpochBecauseKicked(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::CannotRemoveFunctionThatDoesNotExist(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::CannotRemoveImmutableFunction(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::CannotReplaceFunctionThatDoesNotExists(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::CannotReplaceFunctionWithTheSameFunctionFromTheSameFacet(
                    element,
                ) => ::core::fmt::Display::fmt(element, f),
                Self::CannotReplaceFunctionsFromFacetWithZeroAddress(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::CannotReplaceImmutableFunction(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::CannotReuseCommsKeys(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::CannotStakeZero(element) => ::core::fmt::Display::fmt(element, f),
                Self::CannotVoteTwice(element) => ::core::fmt::Display::fmt(element, f),
                Self::CannotWithdrawFrozen(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::CannotWithdrawZero(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::CheckpointAheadOfCurrentEpoch(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::CouldNotMapNodeAddressToStakerAddress(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::ERC721ReceiverRejectedTokens(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::ERC721TransferToNonERC721ReceiverImplementer(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::IncorrectFacetCutAction(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::InitializationFunctionReverted(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::InsufficientSelfStake(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::InvalidAttestedAddress(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::InvalidNewSharePrice(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::InvalidRatio(element) => ::core::fmt::Display::fmt(element, f),
                Self::InvalidSlashPercentage(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::InvalidTimeLock(element) => ::core::fmt::Display::fmt(element, f),
                Self::MinTimeLockNotMet(element) => ::core::fmt::Display::fmt(element, f),
                Self::MustBeInActiveOrUnlockedOrPausedState(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::MustBeInActiveOrUnlockedState(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::MustBeInNextValidatorSetLockedOrReadyForNextEpochOrRestoreState(
                    element,
                ) => ::core::fmt::Display::fmt(element, f),
                Self::MustBeInNextValidatorSetLockedOrReadyForNextEpochState(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::MustBeInNextValidatorSetLockedState(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::MustBeInReadyForNextEpochState(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::MustBeValidatorInNextEpochToKick(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::NewTimeLockMustBeGreaterThanCurrent(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::NoBytecodeAtAddress(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::NoEmptyStakeRecordSlots(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::NoEmptyStakingSlot(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::NoSelectorsProvidedForFacetForCut(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::NodeAddressNotFoundForStaker(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::NotApprovedOrOwner(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::NotContractOwner(element) => ::core::fmt::Display::fmt(element, f),
                Self::NotEnoughTimeElapsedForTimeoutSinceLastEpoch(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::NotEnoughTimeElapsedSinceLastEpoch(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::NotEnoughValidatorsInNextEpoch(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::NotEnoughValidatorsReadyForNextEpoch(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::NotOwner(element) => ::core::fmt::Display::fmt(element, f),
                Self::RealmIdNotFound(element) => ::core::fmt::Display::fmt(element, f),
                Self::RemoveFacetAddressMustBeZeroAddress(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::RewardsMustBeClaimed(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::SameAddress(element) => ::core::fmt::Display::fmt(element, f),
                Self::SignaledReadyForWrongEpochNumber(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::SlashingMustOccurInSameRealm(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::StakeAmountNotMet(element) => ::core::fmt::Display::fmt(element, f),
                Self::StakeMustBeGreaterThanMinimumStake(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::StakeRecordNotFound(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::StakerAddressMismatch(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::TimeLockNotMet(element) => ::core::fmt::Display::fmt(element, f),
                Self::TooSoonToWithdraw(element) => ::core::fmt::Display::fmt(element, f),
                Self::TryingToWithdrawMoreThanStaked(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::ValidatorAlreadyInNextValidatorSet(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::ValidatorAlreadyInRealm(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::ValidatorIsNotInNextEpoch(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::ValidatorNotInNextEpoch(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::ValidatorNotPermitted(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::ValidatorNotRegistered(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::ValidatorRegisterAttestedWalletDisabled(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::ValueMustBeNonzero(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::ZeroAddress(element) => ::core::fmt::Display::fmt(element, f),
                Self::RevertString(s) => ::core::fmt::Display::fmt(s, f),
            }
        }
    }
    impl ::core::convert::From<::std::string::String> for StakingErrors {
        fn from(value: String) -> Self {
            Self::RevertString(value)
        }
    }
    impl ::core::convert::From<ActiveValidatorsCannotLeave> for StakingErrors {
        fn from(value: ActiveValidatorsCannotLeave) -> Self {
            Self::ActiveValidatorsCannotLeave(value)
        }
    }
    impl ::core::convert::From<CallerNotContract> for StakingErrors {
        fn from(value: CallerNotContract) -> Self {
            Self::CallerNotContract(value)
        }
    }
    impl ::core::convert::From<CallerNotOwner> for StakingErrors {
        fn from(value: CallerNotOwner) -> Self {
            Self::CallerNotOwner(value)
        }
    }
    impl ::core::convert::From<CallerNotOwnerOrDevopsAdmin> for StakingErrors {
        fn from(value: CallerNotOwnerOrDevopsAdmin) -> Self {
            Self::CallerNotOwnerOrDevopsAdmin(value)
        }
    }
    impl ::core::convert::From<CannotAddFunctionToDiamondThatAlreadyExists>
    for StakingErrors {
        fn from(value: CannotAddFunctionToDiamondThatAlreadyExists) -> Self {
            Self::CannotAddFunctionToDiamondThatAlreadyExists(value)
        }
    }
    impl ::core::convert::From<CannotAddSelectorsToZeroAddress> for StakingErrors {
        fn from(value: CannotAddSelectorsToZeroAddress) -> Self {
            Self::CannotAddSelectorsToZeroAddress(value)
        }
    }
    impl ::core::convert::From<CannotKickBelowCurrentValidatorThreshold>
    for StakingErrors {
        fn from(value: CannotKickBelowCurrentValidatorThreshold) -> Self {
            Self::CannotKickBelowCurrentValidatorThreshold(value)
        }
    }
    impl ::core::convert::From<CannotMigrateFromValidator> for StakingErrors {
        fn from(value: CannotMigrateFromValidator) -> Self {
            Self::CannotMigrateFromValidator(value)
        }
    }
    impl ::core::convert::From<CannotModifyUnfrozen> for StakingErrors {
        fn from(value: CannotModifyUnfrozen) -> Self {
            Self::CannotModifyUnfrozen(value)
        }
    }
    impl ::core::convert::From<CannotMoveToLockedValidatorStateBeforeEpochEnds>
    for StakingErrors {
        fn from(value: CannotMoveToLockedValidatorStateBeforeEpochEnds) -> Self {
            Self::CannotMoveToLockedValidatorStateBeforeEpochEnds(value)
        }
    }
    impl ::core::convert::From<CannotRejoinBecauseBanned> for StakingErrors {
        fn from(value: CannotRejoinBecauseBanned) -> Self {
            Self::CannotRejoinBecauseBanned(value)
        }
    }
    impl ::core::convert::From<CannotRejoinUntilNextEpochBecauseKicked>
    for StakingErrors {
        fn from(value: CannotRejoinUntilNextEpochBecauseKicked) -> Self {
            Self::CannotRejoinUntilNextEpochBecauseKicked(value)
        }
    }
    impl ::core::convert::From<CannotRemoveFunctionThatDoesNotExist> for StakingErrors {
        fn from(value: CannotRemoveFunctionThatDoesNotExist) -> Self {
            Self::CannotRemoveFunctionThatDoesNotExist(value)
        }
    }
    impl ::core::convert::From<CannotRemoveImmutableFunction> for StakingErrors {
        fn from(value: CannotRemoveImmutableFunction) -> Self {
            Self::CannotRemoveImmutableFunction(value)
        }
    }
    impl ::core::convert::From<CannotReplaceFunctionThatDoesNotExists>
    for StakingErrors {
        fn from(value: CannotReplaceFunctionThatDoesNotExists) -> Self {
            Self::CannotReplaceFunctionThatDoesNotExists(value)
        }
    }
    impl ::core::convert::From<CannotReplaceFunctionWithTheSameFunctionFromTheSameFacet>
    for StakingErrors {
        fn from(
            value: CannotReplaceFunctionWithTheSameFunctionFromTheSameFacet,
        ) -> Self {
            Self::CannotReplaceFunctionWithTheSameFunctionFromTheSameFacet(value)
        }
    }
    impl ::core::convert::From<CannotReplaceFunctionsFromFacetWithZeroAddress>
    for StakingErrors {
        fn from(value: CannotReplaceFunctionsFromFacetWithZeroAddress) -> Self {
            Self::CannotReplaceFunctionsFromFacetWithZeroAddress(value)
        }
    }
    impl ::core::convert::From<CannotReplaceImmutableFunction> for StakingErrors {
        fn from(value: CannotReplaceImmutableFunction) -> Self {
            Self::CannotReplaceImmutableFunction(value)
        }
    }
    impl ::core::convert::From<CannotReuseCommsKeys> for StakingErrors {
        fn from(value: CannotReuseCommsKeys) -> Self {
            Self::CannotReuseCommsKeys(value)
        }
    }
    impl ::core::convert::From<CannotStakeZero> for StakingErrors {
        fn from(value: CannotStakeZero) -> Self {
            Self::CannotStakeZero(value)
        }
    }
    impl ::core::convert::From<CannotVoteTwice> for StakingErrors {
        fn from(value: CannotVoteTwice) -> Self {
            Self::CannotVoteTwice(value)
        }
    }
    impl ::core::convert::From<CannotWithdrawFrozen> for StakingErrors {
        fn from(value: CannotWithdrawFrozen) -> Self {
            Self::CannotWithdrawFrozen(value)
        }
    }
    impl ::core::convert::From<CannotWithdrawZero> for StakingErrors {
        fn from(value: CannotWithdrawZero) -> Self {
            Self::CannotWithdrawZero(value)
        }
    }
    impl ::core::convert::From<CheckpointAheadOfCurrentEpoch> for StakingErrors {
        fn from(value: CheckpointAheadOfCurrentEpoch) -> Self {
            Self::CheckpointAheadOfCurrentEpoch(value)
        }
    }
    impl ::core::convert::From<CouldNotMapNodeAddressToStakerAddress> for StakingErrors {
        fn from(value: CouldNotMapNodeAddressToStakerAddress) -> Self {
            Self::CouldNotMapNodeAddressToStakerAddress(value)
        }
    }
    impl ::core::convert::From<ERC721ReceiverRejectedTokens> for StakingErrors {
        fn from(value: ERC721ReceiverRejectedTokens) -> Self {
            Self::ERC721ReceiverRejectedTokens(value)
        }
    }
    impl ::core::convert::From<ERC721TransferToNonERC721ReceiverImplementer>
    for StakingErrors {
        fn from(value: ERC721TransferToNonERC721ReceiverImplementer) -> Self {
            Self::ERC721TransferToNonERC721ReceiverImplementer(value)
        }
    }
    impl ::core::convert::From<IncorrectFacetCutAction> for StakingErrors {
        fn from(value: IncorrectFacetCutAction) -> Self {
            Self::IncorrectFacetCutAction(value)
        }
    }
    impl ::core::convert::From<InitializationFunctionReverted> for StakingErrors {
        fn from(value: InitializationFunctionReverted) -> Self {
            Self::InitializationFunctionReverted(value)
        }
    }
    impl ::core::convert::From<InsufficientSelfStake> for StakingErrors {
        fn from(value: InsufficientSelfStake) -> Self {
            Self::InsufficientSelfStake(value)
        }
    }
    impl ::core::convert::From<InvalidAttestedAddress> for StakingErrors {
        fn from(value: InvalidAttestedAddress) -> Self {
            Self::InvalidAttestedAddress(value)
        }
    }
    impl ::core::convert::From<InvalidNewSharePrice> for StakingErrors {
        fn from(value: InvalidNewSharePrice) -> Self {
            Self::InvalidNewSharePrice(value)
        }
    }
    impl ::core::convert::From<InvalidRatio> for StakingErrors {
        fn from(value: InvalidRatio) -> Self {
            Self::InvalidRatio(value)
        }
    }
    impl ::core::convert::From<InvalidSlashPercentage> for StakingErrors {
        fn from(value: InvalidSlashPercentage) -> Self {
            Self::InvalidSlashPercentage(value)
        }
    }
    impl ::core::convert::From<InvalidTimeLock> for StakingErrors {
        fn from(value: InvalidTimeLock) -> Self {
            Self::InvalidTimeLock(value)
        }
    }
    impl ::core::convert::From<MinTimeLockNotMet> for StakingErrors {
        fn from(value: MinTimeLockNotMet) -> Self {
            Self::MinTimeLockNotMet(value)
        }
    }
    impl ::core::convert::From<MustBeInActiveOrUnlockedOrPausedState> for StakingErrors {
        fn from(value: MustBeInActiveOrUnlockedOrPausedState) -> Self {
            Self::MustBeInActiveOrUnlockedOrPausedState(value)
        }
    }
    impl ::core::convert::From<MustBeInActiveOrUnlockedState> for StakingErrors {
        fn from(value: MustBeInActiveOrUnlockedState) -> Self {
            Self::MustBeInActiveOrUnlockedState(value)
        }
    }
    impl ::core::convert::From<
        MustBeInNextValidatorSetLockedOrReadyForNextEpochOrRestoreState,
    > for StakingErrors {
        fn from(
            value: MustBeInNextValidatorSetLockedOrReadyForNextEpochOrRestoreState,
        ) -> Self {
            Self::MustBeInNextValidatorSetLockedOrReadyForNextEpochOrRestoreState(value)
        }
    }
    impl ::core::convert::From<MustBeInNextValidatorSetLockedOrReadyForNextEpochState>
    for StakingErrors {
        fn from(value: MustBeInNextValidatorSetLockedOrReadyForNextEpochState) -> Self {
            Self::MustBeInNextValidatorSetLockedOrReadyForNextEpochState(value)
        }
    }
    impl ::core::convert::From<MustBeInNextValidatorSetLockedState> for StakingErrors {
        fn from(value: MustBeInNextValidatorSetLockedState) -> Self {
            Self::MustBeInNextValidatorSetLockedState(value)
        }
    }
    impl ::core::convert::From<MustBeInReadyForNextEpochState> for StakingErrors {
        fn from(value: MustBeInReadyForNextEpochState) -> Self {
            Self::MustBeInReadyForNextEpochState(value)
        }
    }
    impl ::core::convert::From<MustBeValidatorInNextEpochToKick> for StakingErrors {
        fn from(value: MustBeValidatorInNextEpochToKick) -> Self {
            Self::MustBeValidatorInNextEpochToKick(value)
        }
    }
    impl ::core::convert::From<NewTimeLockMustBeGreaterThanCurrent> for StakingErrors {
        fn from(value: NewTimeLockMustBeGreaterThanCurrent) -> Self {
            Self::NewTimeLockMustBeGreaterThanCurrent(value)
        }
    }
    impl ::core::convert::From<NoBytecodeAtAddress> for StakingErrors {
        fn from(value: NoBytecodeAtAddress) -> Self {
            Self::NoBytecodeAtAddress(value)
        }
    }
    impl ::core::convert::From<NoEmptyStakeRecordSlots> for StakingErrors {
        fn from(value: NoEmptyStakeRecordSlots) -> Self {
            Self::NoEmptyStakeRecordSlots(value)
        }
    }
    impl ::core::convert::From<NoEmptyStakingSlot> for StakingErrors {
        fn from(value: NoEmptyStakingSlot) -> Self {
            Self::NoEmptyStakingSlot(value)
        }
    }
    impl ::core::convert::From<NoSelectorsProvidedForFacetForCut> for StakingErrors {
        fn from(value: NoSelectorsProvidedForFacetForCut) -> Self {
            Self::NoSelectorsProvidedForFacetForCut(value)
        }
    }
    impl ::core::convert::From<NodeAddressNotFoundForStaker> for StakingErrors {
        fn from(value: NodeAddressNotFoundForStaker) -> Self {
            Self::NodeAddressNotFoundForStaker(value)
        }
    }
    impl ::core::convert::From<NotApprovedOrOwner> for StakingErrors {
        fn from(value: NotApprovedOrOwner) -> Self {
            Self::NotApprovedOrOwner(value)
        }
    }
    impl ::core::convert::From<NotContractOwner> for StakingErrors {
        fn from(value: NotContractOwner) -> Self {
            Self::NotContractOwner(value)
        }
    }
    impl ::core::convert::From<NotEnoughTimeElapsedForTimeoutSinceLastEpoch>
    for StakingErrors {
        fn from(value: NotEnoughTimeElapsedForTimeoutSinceLastEpoch) -> Self {
            Self::NotEnoughTimeElapsedForTimeoutSinceLastEpoch(value)
        }
    }
    impl ::core::convert::From<NotEnoughTimeElapsedSinceLastEpoch> for StakingErrors {
        fn from(value: NotEnoughTimeElapsedSinceLastEpoch) -> Self {
            Self::NotEnoughTimeElapsedSinceLastEpoch(value)
        }
    }
    impl ::core::convert::From<NotEnoughValidatorsInNextEpoch> for StakingErrors {
        fn from(value: NotEnoughValidatorsInNextEpoch) -> Self {
            Self::NotEnoughValidatorsInNextEpoch(value)
        }
    }
    impl ::core::convert::From<NotEnoughValidatorsReadyForNextEpoch> for StakingErrors {
        fn from(value: NotEnoughValidatorsReadyForNextEpoch) -> Self {
            Self::NotEnoughValidatorsReadyForNextEpoch(value)
        }
    }
    impl ::core::convert::From<NotOwner> for StakingErrors {
        fn from(value: NotOwner) -> Self {
            Self::NotOwner(value)
        }
    }
    impl ::core::convert::From<RealmIdNotFound> for StakingErrors {
        fn from(value: RealmIdNotFound) -> Self {
            Self::RealmIdNotFound(value)
        }
    }
    impl ::core::convert::From<RemoveFacetAddressMustBeZeroAddress> for StakingErrors {
        fn from(value: RemoveFacetAddressMustBeZeroAddress) -> Self {
            Self::RemoveFacetAddressMustBeZeroAddress(value)
        }
    }
    impl ::core::convert::From<RewardsMustBeClaimed> for StakingErrors {
        fn from(value: RewardsMustBeClaimed) -> Self {
            Self::RewardsMustBeClaimed(value)
        }
    }
    impl ::core::convert::From<SameAddress> for StakingErrors {
        fn from(value: SameAddress) -> Self {
            Self::SameAddress(value)
        }
    }
    impl ::core::convert::From<SignaledReadyForWrongEpochNumber> for StakingErrors {
        fn from(value: SignaledReadyForWrongEpochNumber) -> Self {
            Self::SignaledReadyForWrongEpochNumber(value)
        }
    }
    impl ::core::convert::From<SlashingMustOccurInSameRealm> for StakingErrors {
        fn from(value: SlashingMustOccurInSameRealm) -> Self {
            Self::SlashingMustOccurInSameRealm(value)
        }
    }
    impl ::core::convert::From<StakeAmountNotMet> for StakingErrors {
        fn from(value: StakeAmountNotMet) -> Self {
            Self::StakeAmountNotMet(value)
        }
    }
    impl ::core::convert::From<StakeMustBeGreaterThanMinimumStake> for StakingErrors {
        fn from(value: StakeMustBeGreaterThanMinimumStake) -> Self {
            Self::StakeMustBeGreaterThanMinimumStake(value)
        }
    }
    impl ::core::convert::From<StakeRecordNotFound> for StakingErrors {
        fn from(value: StakeRecordNotFound) -> Self {
            Self::StakeRecordNotFound(value)
        }
    }
    impl ::core::convert::From<StakerAddressMismatch> for StakingErrors {
        fn from(value: StakerAddressMismatch) -> Self {
            Self::StakerAddressMismatch(value)
        }
    }
    impl ::core::convert::From<TimeLockNotMet> for StakingErrors {
        fn from(value: TimeLockNotMet) -> Self {
            Self::TimeLockNotMet(value)
        }
    }
    impl ::core::convert::From<TooSoonToWithdraw> for StakingErrors {
        fn from(value: TooSoonToWithdraw) -> Self {
            Self::TooSoonToWithdraw(value)
        }
    }
    impl ::core::convert::From<TryingToWithdrawMoreThanStaked> for StakingErrors {
        fn from(value: TryingToWithdrawMoreThanStaked) -> Self {
            Self::TryingToWithdrawMoreThanStaked(value)
        }
    }
    impl ::core::convert::From<ValidatorAlreadyInNextValidatorSet> for StakingErrors {
        fn from(value: ValidatorAlreadyInNextValidatorSet) -> Self {
            Self::ValidatorAlreadyInNextValidatorSet(value)
        }
    }
    impl ::core::convert::From<ValidatorAlreadyInRealm> for StakingErrors {
        fn from(value: ValidatorAlreadyInRealm) -> Self {
            Self::ValidatorAlreadyInRealm(value)
        }
    }
    impl ::core::convert::From<ValidatorIsNotInNextEpoch> for StakingErrors {
        fn from(value: ValidatorIsNotInNextEpoch) -> Self {
            Self::ValidatorIsNotInNextEpoch(value)
        }
    }
    impl ::core::convert::From<ValidatorNotInNextEpoch> for StakingErrors {
        fn from(value: ValidatorNotInNextEpoch) -> Self {
            Self::ValidatorNotInNextEpoch(value)
        }
    }
    impl ::core::convert::From<ValidatorNotPermitted> for StakingErrors {
        fn from(value: ValidatorNotPermitted) -> Self {
            Self::ValidatorNotPermitted(value)
        }
    }
    impl ::core::convert::From<ValidatorNotRegistered> for StakingErrors {
        fn from(value: ValidatorNotRegistered) -> Self {
            Self::ValidatorNotRegistered(value)
        }
    }
    impl ::core::convert::From<ValidatorRegisterAttestedWalletDisabled>
    for StakingErrors {
        fn from(value: ValidatorRegisterAttestedWalletDisabled) -> Self {
            Self::ValidatorRegisterAttestedWalletDisabled(value)
        }
    }
    impl ::core::convert::From<ValueMustBeNonzero> for StakingErrors {
        fn from(value: ValueMustBeNonzero) -> Self {
            Self::ValueMustBeNonzero(value)
        }
    }
    impl ::core::convert::From<ZeroAddress> for StakingErrors {
        fn from(value: ZeroAddress) -> Self {
            Self::ZeroAddress(value)
        }
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethevent(name = "AdvancedEpoch", abi = "AdvancedEpoch(uint256,uint256)")]
    pub struct AdvancedEpochFilter {
        pub realm_id: ::ethers::core::types::U256,
        pub epoch_number: ::ethers::core::types::U256,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethevent(name = "Approval", abi = "Approval(address,address,uint256)")]
    pub struct ApprovalFilter {
        #[ethevent(indexed)]
        pub owner: ::ethers::core::types::Address,
        #[ethevent(indexed)]
        pub approved: ::ethers::core::types::Address,
        #[ethevent(indexed)]
        pub token_id: ::ethers::core::types::U256,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethevent(name = "ApprovalForAll", abi = "ApprovalForAll(address,address,bool)")]
    pub struct ApprovalForAllFilter {
        #[ethevent(indexed)]
        pub owner: ::ethers::core::types::Address,
        #[ethevent(indexed)]
        pub operator: ::ethers::core::types::Address,
        pub approved: bool,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethevent(
        name = "AttestedWalletRegistered",
        abi = "AttestedWalletRegistered(address,address,(uint256,uint256))"
    )]
    pub struct AttestedWalletRegisteredFilter {
        #[ethevent(indexed)]
        pub staker: ::ethers::core::types::Address,
        #[ethevent(indexed)]
        pub attested_address: ::ethers::core::types::Address,
        #[ethevent(indexed)]
        pub attested_pub_key: ::ethers::core::types::H256,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethevent(name = "ClearOfflinePhaseData", abi = "ClearOfflinePhaseData(uint256)")]
    pub struct ClearOfflinePhaseDataFilter {
        pub data_type: ::ethers::core::types::U256,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethevent(
        name = "ComplaintConfigSet",
        abi = "ComplaintConfigSet(uint256,(uint256,uint256,uint256,uint256))"
    )]
    pub struct ComplaintConfigSetFilter {
        pub reason: ::ethers::core::types::U256,
        pub config: ComplaintConfig,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethevent(
        name = "ConfigSet",
        abi = "ConfigSet(uint256,uint256[],uint256,uint256,uint256,uint256,uint256,uint256,bool)"
    )]
    pub struct ConfigSetFilter {
        pub new_token_reward_per_token_per_epoch: ::ethers::core::types::U256,
        pub new_key_types: ::std::vec::Vec<::ethers::core::types::U256>,
        pub new_minimum_validator_count: ::ethers::core::types::U256,
        pub new_max_concurrent_requests: ::ethers::core::types::U256,
        pub new_max_presign_count: ::ethers::core::types::U256,
        pub new_min_presign_count: ::ethers::core::types::U256,
        pub new_peer_checking_interval_secs: ::ethers::core::types::U256,
        pub new_max_presign_concurrency: ::ethers::core::types::U256,
        pub new_rpc_healthcheck_enabled: bool,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethevent(name = "CountOfflinePhaseData", abi = "CountOfflinePhaseData(uint256)")]
    pub struct CountOfflinePhaseDataFilter {
        pub data_type: ::ethers::core::types::U256,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethevent(name = "DebugEvent", abi = "DebugEvent(string,address,uint256)")]
    pub struct DebugEventFilter {
        pub message: ::std::string::String,
        pub sender: ::ethers::core::types::Address,
        pub value: ::ethers::core::types::U256,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethevent(name = "DevopsAdminSet", abi = "DevopsAdminSet(address)")]
    pub struct DevopsAdminSetFilter {
        pub new_devops_admin: ::ethers::core::types::Address,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethevent(
        name = "DiamondCut",
        abi = "DiamondCut((address,uint8,bytes4[])[],address,bytes)"
    )]
    pub struct DiamondCutFilter {
        pub diamond_cut: ::std::vec::Vec<FacetCut>,
        pub init: ::ethers::core::types::Address,
        pub calldata: ::ethers::core::types::Bytes,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethevent(name = "EpochEndTimeSet", abi = "EpochEndTimeSet(uint256,uint256)")]
    pub struct EpochEndTimeSetFilter {
        pub realm_id: ::ethers::core::types::U256,
        pub new_epoch_end_time: ::ethers::core::types::U256,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethevent(name = "EpochLengthSet", abi = "EpochLengthSet(uint256,uint256)")]
    pub struct EpochLengthSetFilter {
        pub realm_id: ::ethers::core::types::U256,
        pub new_epoch_length: ::ethers::core::types::U256,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethevent(name = "EpochTimeoutSet", abi = "EpochTimeoutSet(uint256,uint256)")]
    pub struct EpochTimeoutSetFilter {
        pub realm_id: ::ethers::core::types::U256,
        pub new_epoch_timeout: ::ethers::core::types::U256,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethevent(
        name = "FixedCostRewardsClaimed",
        abi = "FixedCostRewardsClaimed(address,uint256,uint256,uint256)"
    )]
    pub struct FixedCostRewardsClaimedFilter {
        pub staker_address: ::ethers::core::types::Address,
        pub rewards: ::ethers::core::types::U256,
        pub from_epoch: ::ethers::core::types::U256,
        pub to_epoch: ::ethers::core::types::U256,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethevent(name = "KeySetConfigSet", abi = "KeySetConfigSet(bool,string,bytes32)")]
    pub struct KeySetConfigSetFilter {
        pub exists: bool,
        pub identifier: ::std::string::String,
        pub hashed: [u8; 32],
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethevent(name = "KeySetConfigUpdated", abi = "KeySetConfigUpdated(string)")]
    pub struct KeySetConfigUpdatedFilter {
        pub identifier: ::std::string::String,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethevent(
        name = "KickPenaltyPercentSet",
        abi = "KickPenaltyPercentSet(uint256,uint256)"
    )]
    pub struct KickPenaltyPercentSetFilter {
        pub reason: ::ethers::core::types::U256,
        pub new_kick_penalty_percent: ::ethers::core::types::U256,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethevent(
        name = "OwnershipTransferred",
        abi = "OwnershipTransferred(address,address)"
    )]
    pub struct OwnershipTransferredFilter {
        #[ethevent(indexed)]
        pub previous_owner: ::ethers::core::types::Address,
        #[ethevent(indexed)]
        pub new_owner: ::ethers::core::types::Address,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethevent(name = "ReadyForNextEpoch", abi = "ReadyForNextEpoch(address,uint256)")]
    pub struct ReadyForNextEpochFilter {
        #[ethevent(indexed)]
        pub staker: ::ethers::core::types::Address,
        pub epoch_number: ::ethers::core::types::U256,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethevent(name = "Recovered", abi = "Recovered(address,uint256)")]
    pub struct RecoveredFilter {
        pub token: ::ethers::core::types::Address,
        pub amount: ::ethers::core::types::U256,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethevent(name = "RequestToJoin", abi = "RequestToJoin(uint256)")]
    pub struct RequestToJoin1Filter {
        #[ethevent(indexed)]
        pub validator_id: ::ethers::core::types::U256,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethevent(name = "RequestToJoin", abi = "RequestToJoin(address)")]
    pub struct RequestToJoin2Filter {
        #[ethevent(indexed)]
        pub staker: ::ethers::core::types::Address,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethevent(name = "RequestToLeave", abi = "RequestToLeave(address)")]
    pub struct RequestToLeaveFilter {
        #[ethevent(indexed)]
        pub staker: ::ethers::core::types::Address,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethevent(
        name = "ResolverContractAddressSet",
        abi = "ResolverContractAddressSet(address)"
    )]
    pub struct ResolverContractAddressSetFilter {
        pub new_resolver_contract_address: ::ethers::core::types::Address,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethevent(name = "RewardsDurationUpdated", abi = "RewardsDurationUpdated(uint256)")]
    pub struct RewardsDurationUpdatedFilter {
        pub new_duration: ::ethers::core::types::U256,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethevent(
        name = "StakeRecordCreated",
        abi = "StakeRecordCreated(address,uint256,uint256,address)"
    )]
    pub struct StakeRecordCreatedFilter {
        pub staker_address: ::ethers::core::types::Address,
        pub record_id: ::ethers::core::types::U256,
        pub amount: ::ethers::core::types::U256,
        pub staker_address_client: ::ethers::core::types::Address,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethevent(name = "StakeRecordRemoved", abi = "StakeRecordRemoved(address,uint256)")]
    pub struct StakeRecordRemovedFilter {
        pub user_staker_address: ::ethers::core::types::Address,
        pub record_id: ::ethers::core::types::U256,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethevent(name = "StakeRecordUpdated", abi = "StakeRecordUpdated(address,uint256)")]
    pub struct StakeRecordUpdatedFilter {
        pub staker_address: ::ethers::core::types::Address,
        pub record_id: ::ethers::core::types::U256,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethevent(
        name = "StakeRewardsClaimed",
        abi = "StakeRewardsClaimed(address,uint256,uint256,uint256,uint256)"
    )]
    pub struct StakeRewardsClaimed1Filter {
        pub staker_address: ::ethers::core::types::Address,
        pub record_id: ::ethers::core::types::U256,
        pub rewards: ::ethers::core::types::U256,
        pub from_epoch: ::ethers::core::types::U256,
        pub to_epoch: ::ethers::core::types::U256,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethevent(
        name = "StakeRewardsClaimed",
        abi = "StakeRewardsClaimed(uint256,uint256,uint256)"
    )]
    pub struct StakeRewardsClaimed2Filter {
        pub validator_id: ::ethers::core::types::U256,
        pub record_id: ::ethers::core::types::U256,
        pub rewards: ::ethers::core::types::U256,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethevent(name = "Staked", abi = "Staked(address,uint256)")]
    pub struct StakedFilter {
        #[ethevent(indexed)]
        pub staker: ::ethers::core::types::Address,
        pub amount: ::ethers::core::types::U256,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethevent(name = "StakingTokenSet", abi = "StakingTokenSet(address)")]
    pub struct StakingTokenSetFilter {
        pub new_staking_token_address: ::ethers::core::types::Address,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethevent(name = "StateChanged", abi = "StateChanged(uint8)")]
    pub struct StateChangedFilter {
        pub new_state: u8,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethevent(name = "Transfer", abi = "Transfer(address,address,uint256)")]
    pub struct TransferFilter {
        #[ethevent(indexed)]
        pub from: ::ethers::core::types::Address,
        #[ethevent(indexed)]
        pub to: ::ethers::core::types::Address,
        #[ethevent(indexed)]
        pub token_id: ::ethers::core::types::U256,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethevent(name = "TrustedForwarderSet", abi = "TrustedForwarderSet(address)")]
    pub struct TrustedForwarderSetFilter {
        pub new_trusted_forwarder: ::ethers::core::types::Address,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethevent(name = "ValidatorBanned", abi = "ValidatorBanned(address)")]
    pub struct ValidatorBannedFilter {
        #[ethevent(indexed)]
        pub staker: ::ethers::core::types::Address,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethevent(
        name = "ValidatorCommissionClaimed",
        abi = "ValidatorCommissionClaimed(address,uint256,uint256,uint256)"
    )]
    pub struct ValidatorCommissionClaimedFilter {
        pub staker_address: ::ethers::core::types::Address,
        pub rewards: ::ethers::core::types::U256,
        pub from_epoch: ::ethers::core::types::U256,
        pub to_epoch: ::ethers::core::types::U256,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethevent(
        name = "ValidatorKickedFromNextEpoch",
        abi = "ValidatorKickedFromNextEpoch(address)"
    )]
    pub struct ValidatorKickedFromNextEpochFilter {
        #[ethevent(indexed)]
        pub staker: ::ethers::core::types::Address,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethevent(name = "ValidatorRegistered", abi = "ValidatorRegistered(address)")]
    pub struct ValidatorRegisteredFilter {
        #[ethevent(indexed)]
        pub staker_address: ::ethers::core::types::Address,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethevent(
        name = "ValidatorRejoinedNextEpoch",
        abi = "ValidatorRejoinedNextEpoch(address)"
    )]
    pub struct ValidatorRejoinedNextEpochFilter {
        pub staker: ::ethers::core::types::Address,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethevent(
        name = "VersionRequirementsUpdated",
        abi = "VersionRequirementsUpdated(uint256,uint256,(uint256,uint256,uint256))"
    )]
    pub struct VersionRequirementsUpdatedFilter {
        pub index: ::ethers::core::types::U256,
        pub realm_id: ::ethers::core::types::U256,
        pub version: Version,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethevent(
        name = "VoteToAdvanceTimeOutElapsed",
        abi = "VoteToAdvanceTimeOutElapsed(uint256)"
    )]
    pub struct VoteToAdvanceTimeOutElapsedFilter {
        pub realm_id: ::ethers::core::types::U256,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethevent(
        name = "VotedToKickValidatorInNextEpoch",
        abi = "VotedToKickValidatorInNextEpoch(address,address,uint256,bytes)"
    )]
    pub struct VotedToKickValidatorInNextEpochFilter {
        #[ethevent(indexed)]
        pub reporter: ::ethers::core::types::Address,
        #[ethevent(indexed)]
        pub validator_to_kick_staker_address: ::ethers::core::types::Address,
        #[ethevent(indexed)]
        pub reason: ::ethers::core::types::U256,
        pub data: ::ethers::core::types::Bytes,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethevent(name = "Withdrawn", abi = "Withdrawn(address,uint256)")]
    pub struct WithdrawnFilter {
        #[ethevent(indexed)]
        pub staker: ::ethers::core::types::Address,
        pub amount: ::ethers::core::types::U256,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethevent(name = "log", abi = "log(string)")]
    pub struct LogFilter(pub ::std::string::String);
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethevent(name = "log_address", abi = "log_address(address)")]
    pub struct LogAddressFilter(pub ::ethers::core::types::Address);
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethevent(name = "log_array", abi = "log_array(uint256[])")]
    pub struct LogArray1Filter {
        pub val: ::std::vec::Vec<::ethers::core::types::U256>,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethevent(name = "log_array", abi = "log_array(int256[])")]
    pub struct LogArray2Filter {
        pub val: ::std::vec::Vec<::ethers::core::types::I256>,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethevent(name = "log_array", abi = "log_array(address[])")]
    pub struct LogArray3Filter {
        pub val: ::std::vec::Vec<::ethers::core::types::Address>,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethevent(name = "log_bytes", abi = "log_bytes(bytes)")]
    pub struct LogBytesFilter(pub ::ethers::core::types::Bytes);
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethevent(name = "log_bytes32", abi = "log_bytes32(bytes32)")]
    pub struct LogBytes32Filter(pub [u8; 32]);
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethevent(name = "log_int", abi = "log_int(int256)")]
    pub struct LogIntFilter(pub ::ethers::core::types::I256);
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethevent(name = "log_named_address", abi = "log_named_address(string,address)")]
    pub struct LogNamedAddressFilter {
        pub key: ::std::string::String,
        pub val: ::ethers::core::types::Address,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethevent(name = "log_named_array", abi = "log_named_array(string,uint256[])")]
    pub struct LogNamedArray1Filter {
        pub key: ::std::string::String,
        pub val: ::std::vec::Vec<::ethers::core::types::U256>,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethevent(name = "log_named_array", abi = "log_named_array(string,int256[])")]
    pub struct LogNamedArray2Filter {
        pub key: ::std::string::String,
        pub val: ::std::vec::Vec<::ethers::core::types::I256>,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethevent(name = "log_named_array", abi = "log_named_array(string,address[])")]
    pub struct LogNamedArray3Filter {
        pub key: ::std::string::String,
        pub val: ::std::vec::Vec<::ethers::core::types::Address>,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethevent(name = "log_named_bytes", abi = "log_named_bytes(string,bytes)")]
    pub struct LogNamedBytesFilter {
        pub key: ::std::string::String,
        pub val: ::ethers::core::types::Bytes,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethevent(name = "log_named_bytes32", abi = "log_named_bytes32(string,bytes32)")]
    pub struct LogNamedBytes32Filter {
        pub key: ::std::string::String,
        pub val: [u8; 32],
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethevent(
        name = "log_named_decimal_int",
        abi = "log_named_decimal_int(string,int256,uint256)"
    )]
    pub struct LogNamedDecimalIntFilter {
        pub key: ::std::string::String,
        pub val: ::ethers::core::types::I256,
        pub decimals: ::ethers::core::types::U256,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethevent(
        name = "log_named_decimal_uint",
        abi = "log_named_decimal_uint(string,uint256,uint256)"
    )]
    pub struct LogNamedDecimalUintFilter {
        pub key: ::std::string::String,
        pub val: ::ethers::core::types::U256,
        pub decimals: ::ethers::core::types::U256,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethevent(name = "log_named_int", abi = "log_named_int(string,int256)")]
    pub struct LogNamedIntFilter {
        pub key: ::std::string::String,
        pub val: ::ethers::core::types::I256,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethevent(name = "log_named_string", abi = "log_named_string(string,string)")]
    pub struct LogNamedStringFilter {
        pub key: ::std::string::String,
        pub val: ::std::string::String,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethevent(name = "log_named_uint", abi = "log_named_uint(string,uint256)")]
    pub struct LogNamedUintFilter {
        pub key: ::std::string::String,
        pub val: ::ethers::core::types::U256,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethevent(name = "log_string", abi = "log_string(string)")]
    pub struct LogStringFilter(pub ::std::string::String);
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethevent(name = "log_uint", abi = "log_uint(uint256)")]
    pub struct LogUintFilter(pub ::ethers::core::types::U256);
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethevent(name = "logs", abi = "logs(bytes)")]
    pub struct LogsFilter(pub ::ethers::core::types::Bytes);
    ///Container type for all of the contract's events
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        serde::Serialize,
        serde::Deserialize,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub enum StakingEvents {
        AdvancedEpochFilter(AdvancedEpochFilter),
        ApprovalFilter(ApprovalFilter),
        ApprovalForAllFilter(ApprovalForAllFilter),
        AttestedWalletRegisteredFilter(AttestedWalletRegisteredFilter),
        ClearOfflinePhaseDataFilter(ClearOfflinePhaseDataFilter),
        ComplaintConfigSetFilter(ComplaintConfigSetFilter),
        ConfigSetFilter(ConfigSetFilter),
        CountOfflinePhaseDataFilter(CountOfflinePhaseDataFilter),
        DebugEventFilter(DebugEventFilter),
        DevopsAdminSetFilter(DevopsAdminSetFilter),
        DiamondCutFilter(DiamondCutFilter),
        EpochEndTimeSetFilter(EpochEndTimeSetFilter),
        EpochLengthSetFilter(EpochLengthSetFilter),
        EpochTimeoutSetFilter(EpochTimeoutSetFilter),
        FixedCostRewardsClaimedFilter(FixedCostRewardsClaimedFilter),
        KeySetConfigSetFilter(KeySetConfigSetFilter),
        KeySetConfigUpdatedFilter(KeySetConfigUpdatedFilter),
        KickPenaltyPercentSetFilter(KickPenaltyPercentSetFilter),
        OwnershipTransferredFilter(OwnershipTransferredFilter),
        ReadyForNextEpochFilter(ReadyForNextEpochFilter),
        RecoveredFilter(RecoveredFilter),
        RequestToJoin1Filter(RequestToJoin1Filter),
        RequestToJoin2Filter(RequestToJoin2Filter),
        RequestToLeaveFilter(RequestToLeaveFilter),
        ResolverContractAddressSetFilter(ResolverContractAddressSetFilter),
        RewardsDurationUpdatedFilter(RewardsDurationUpdatedFilter),
        StakeRecordCreatedFilter(StakeRecordCreatedFilter),
        StakeRecordRemovedFilter(StakeRecordRemovedFilter),
        StakeRecordUpdatedFilter(StakeRecordUpdatedFilter),
        StakeRewardsClaimed1Filter(StakeRewardsClaimed1Filter),
        StakeRewardsClaimed2Filter(StakeRewardsClaimed2Filter),
        StakedFilter(StakedFilter),
        StakingTokenSetFilter(StakingTokenSetFilter),
        StateChangedFilter(StateChangedFilter),
        TransferFilter(TransferFilter),
        TrustedForwarderSetFilter(TrustedForwarderSetFilter),
        ValidatorBannedFilter(ValidatorBannedFilter),
        ValidatorCommissionClaimedFilter(ValidatorCommissionClaimedFilter),
        ValidatorKickedFromNextEpochFilter(ValidatorKickedFromNextEpochFilter),
        ValidatorRegisteredFilter(ValidatorRegisteredFilter),
        ValidatorRejoinedNextEpochFilter(ValidatorRejoinedNextEpochFilter),
        VersionRequirementsUpdatedFilter(VersionRequirementsUpdatedFilter),
        VoteToAdvanceTimeOutElapsedFilter(VoteToAdvanceTimeOutElapsedFilter),
        VotedToKickValidatorInNextEpochFilter(VotedToKickValidatorInNextEpochFilter),
        WithdrawnFilter(WithdrawnFilter),
        LogFilter(LogFilter),
        LogAddressFilter(LogAddressFilter),
        LogArray1Filter(LogArray1Filter),
        LogArray2Filter(LogArray2Filter),
        LogArray3Filter(LogArray3Filter),
        LogBytesFilter(LogBytesFilter),
        LogBytes32Filter(LogBytes32Filter),
        LogIntFilter(LogIntFilter),
        LogNamedAddressFilter(LogNamedAddressFilter),
        LogNamedArray1Filter(LogNamedArray1Filter),
        LogNamedArray2Filter(LogNamedArray2Filter),
        LogNamedArray3Filter(LogNamedArray3Filter),
        LogNamedBytesFilter(LogNamedBytesFilter),
        LogNamedBytes32Filter(LogNamedBytes32Filter),
        LogNamedDecimalIntFilter(LogNamedDecimalIntFilter),
        LogNamedDecimalUintFilter(LogNamedDecimalUintFilter),
        LogNamedIntFilter(LogNamedIntFilter),
        LogNamedStringFilter(LogNamedStringFilter),
        LogNamedUintFilter(LogNamedUintFilter),
        LogStringFilter(LogStringFilter),
        LogUintFilter(LogUintFilter),
        LogsFilter(LogsFilter),
    }
    impl ::ethers::contract::EthLogDecode for StakingEvents {
        fn decode_log(
            log: &::ethers::core::abi::RawLog,
        ) -> ::core::result::Result<Self, ::ethers::core::abi::Error> {
            if let Ok(decoded) = AdvancedEpochFilter::decode_log(log) {
                return Ok(StakingEvents::AdvancedEpochFilter(decoded));
            }
            if let Ok(decoded) = ApprovalFilter::decode_log(log) {
                return Ok(StakingEvents::ApprovalFilter(decoded));
            }
            if let Ok(decoded) = ApprovalForAllFilter::decode_log(log) {
                return Ok(StakingEvents::ApprovalForAllFilter(decoded));
            }
            if let Ok(decoded) = AttestedWalletRegisteredFilter::decode_log(log) {
                return Ok(StakingEvents::AttestedWalletRegisteredFilter(decoded));
            }
            if let Ok(decoded) = ClearOfflinePhaseDataFilter::decode_log(log) {
                return Ok(StakingEvents::ClearOfflinePhaseDataFilter(decoded));
            }
            if let Ok(decoded) = ComplaintConfigSetFilter::decode_log(log) {
                return Ok(StakingEvents::ComplaintConfigSetFilter(decoded));
            }
            if let Ok(decoded) = ConfigSetFilter::decode_log(log) {
                return Ok(StakingEvents::ConfigSetFilter(decoded));
            }
            if let Ok(decoded) = CountOfflinePhaseDataFilter::decode_log(log) {
                return Ok(StakingEvents::CountOfflinePhaseDataFilter(decoded));
            }
            if let Ok(decoded) = DebugEventFilter::decode_log(log) {
                return Ok(StakingEvents::DebugEventFilter(decoded));
            }
            if let Ok(decoded) = DevopsAdminSetFilter::decode_log(log) {
                return Ok(StakingEvents::DevopsAdminSetFilter(decoded));
            }
            if let Ok(decoded) = DiamondCutFilter::decode_log(log) {
                return Ok(StakingEvents::DiamondCutFilter(decoded));
            }
            if let Ok(decoded) = EpochEndTimeSetFilter::decode_log(log) {
                return Ok(StakingEvents::EpochEndTimeSetFilter(decoded));
            }
            if let Ok(decoded) = EpochLengthSetFilter::decode_log(log) {
                return Ok(StakingEvents::EpochLengthSetFilter(decoded));
            }
            if let Ok(decoded) = EpochTimeoutSetFilter::decode_log(log) {
                return Ok(StakingEvents::EpochTimeoutSetFilter(decoded));
            }
            if let Ok(decoded) = FixedCostRewardsClaimedFilter::decode_log(log) {
                return Ok(StakingEvents::FixedCostRewardsClaimedFilter(decoded));
            }
            if let Ok(decoded) = KeySetConfigSetFilter::decode_log(log) {
                return Ok(StakingEvents::KeySetConfigSetFilter(decoded));
            }
            if let Ok(decoded) = KeySetConfigUpdatedFilter::decode_log(log) {
                return Ok(StakingEvents::KeySetConfigUpdatedFilter(decoded));
            }
            if let Ok(decoded) = KickPenaltyPercentSetFilter::decode_log(log) {
                return Ok(StakingEvents::KickPenaltyPercentSetFilter(decoded));
            }
            if let Ok(decoded) = OwnershipTransferredFilter::decode_log(log) {
                return Ok(StakingEvents::OwnershipTransferredFilter(decoded));
            }
            if let Ok(decoded) = ReadyForNextEpochFilter::decode_log(log) {
                return Ok(StakingEvents::ReadyForNextEpochFilter(decoded));
            }
            if let Ok(decoded) = RecoveredFilter::decode_log(log) {
                return Ok(StakingEvents::RecoveredFilter(decoded));
            }
            if let Ok(decoded) = RequestToJoin1Filter::decode_log(log) {
                return Ok(StakingEvents::RequestToJoin1Filter(decoded));
            }
            if let Ok(decoded) = RequestToJoin2Filter::decode_log(log) {
                return Ok(StakingEvents::RequestToJoin2Filter(decoded));
            }
            if let Ok(decoded) = RequestToLeaveFilter::decode_log(log) {
                return Ok(StakingEvents::RequestToLeaveFilter(decoded));
            }
            if let Ok(decoded) = ResolverContractAddressSetFilter::decode_log(log) {
                return Ok(StakingEvents::ResolverContractAddressSetFilter(decoded));
            }
            if let Ok(decoded) = RewardsDurationUpdatedFilter::decode_log(log) {
                return Ok(StakingEvents::RewardsDurationUpdatedFilter(decoded));
            }
            if let Ok(decoded) = StakeRecordCreatedFilter::decode_log(log) {
                return Ok(StakingEvents::StakeRecordCreatedFilter(decoded));
            }
            if let Ok(decoded) = StakeRecordRemovedFilter::decode_log(log) {
                return Ok(StakingEvents::StakeRecordRemovedFilter(decoded));
            }
            if let Ok(decoded) = StakeRecordUpdatedFilter::decode_log(log) {
                return Ok(StakingEvents::StakeRecordUpdatedFilter(decoded));
            }
            if let Ok(decoded) = StakeRewardsClaimed1Filter::decode_log(log) {
                return Ok(StakingEvents::StakeRewardsClaimed1Filter(decoded));
            }
            if let Ok(decoded) = StakeRewardsClaimed2Filter::decode_log(log) {
                return Ok(StakingEvents::StakeRewardsClaimed2Filter(decoded));
            }
            if let Ok(decoded) = StakedFilter::decode_log(log) {
                return Ok(StakingEvents::StakedFilter(decoded));
            }
            if let Ok(decoded) = StakingTokenSetFilter::decode_log(log) {
                return Ok(StakingEvents::StakingTokenSetFilter(decoded));
            }
            if let Ok(decoded) = StateChangedFilter::decode_log(log) {
                return Ok(StakingEvents::StateChangedFilter(decoded));
            }
            if let Ok(decoded) = TransferFilter::decode_log(log) {
                return Ok(StakingEvents::TransferFilter(decoded));
            }
            if let Ok(decoded) = TrustedForwarderSetFilter::decode_log(log) {
                return Ok(StakingEvents::TrustedForwarderSetFilter(decoded));
            }
            if let Ok(decoded) = ValidatorBannedFilter::decode_log(log) {
                return Ok(StakingEvents::ValidatorBannedFilter(decoded));
            }
            if let Ok(decoded) = ValidatorCommissionClaimedFilter::decode_log(log) {
                return Ok(StakingEvents::ValidatorCommissionClaimedFilter(decoded));
            }
            if let Ok(decoded) = ValidatorKickedFromNextEpochFilter::decode_log(log) {
                return Ok(StakingEvents::ValidatorKickedFromNextEpochFilter(decoded));
            }
            if let Ok(decoded) = ValidatorRegisteredFilter::decode_log(log) {
                return Ok(StakingEvents::ValidatorRegisteredFilter(decoded));
            }
            if let Ok(decoded) = ValidatorRejoinedNextEpochFilter::decode_log(log) {
                return Ok(StakingEvents::ValidatorRejoinedNextEpochFilter(decoded));
            }
            if let Ok(decoded) = VersionRequirementsUpdatedFilter::decode_log(log) {
                return Ok(StakingEvents::VersionRequirementsUpdatedFilter(decoded));
            }
            if let Ok(decoded) = VoteToAdvanceTimeOutElapsedFilter::decode_log(log) {
                return Ok(StakingEvents::VoteToAdvanceTimeOutElapsedFilter(decoded));
            }
            if let Ok(decoded) = VotedToKickValidatorInNextEpochFilter::decode_log(log) {
                return Ok(StakingEvents::VotedToKickValidatorInNextEpochFilter(decoded));
            }
            if let Ok(decoded) = WithdrawnFilter::decode_log(log) {
                return Ok(StakingEvents::WithdrawnFilter(decoded));
            }
            if let Ok(decoded) = LogFilter::decode_log(log) {
                return Ok(StakingEvents::LogFilter(decoded));
            }
            if let Ok(decoded) = LogAddressFilter::decode_log(log) {
                return Ok(StakingEvents::LogAddressFilter(decoded));
            }
            if let Ok(decoded) = LogArray1Filter::decode_log(log) {
                return Ok(StakingEvents::LogArray1Filter(decoded));
            }
            if let Ok(decoded) = LogArray2Filter::decode_log(log) {
                return Ok(StakingEvents::LogArray2Filter(decoded));
            }
            if let Ok(decoded) = LogArray3Filter::decode_log(log) {
                return Ok(StakingEvents::LogArray3Filter(decoded));
            }
            if let Ok(decoded) = LogBytesFilter::decode_log(log) {
                return Ok(StakingEvents::LogBytesFilter(decoded));
            }
            if let Ok(decoded) = LogBytes32Filter::decode_log(log) {
                return Ok(StakingEvents::LogBytes32Filter(decoded));
            }
            if let Ok(decoded) = LogIntFilter::decode_log(log) {
                return Ok(StakingEvents::LogIntFilter(decoded));
            }
            if let Ok(decoded) = LogNamedAddressFilter::decode_log(log) {
                return Ok(StakingEvents::LogNamedAddressFilter(decoded));
            }
            if let Ok(decoded) = LogNamedArray1Filter::decode_log(log) {
                return Ok(StakingEvents::LogNamedArray1Filter(decoded));
            }
            if let Ok(decoded) = LogNamedArray2Filter::decode_log(log) {
                return Ok(StakingEvents::LogNamedArray2Filter(decoded));
            }
            if let Ok(decoded) = LogNamedArray3Filter::decode_log(log) {
                return Ok(StakingEvents::LogNamedArray3Filter(decoded));
            }
            if let Ok(decoded) = LogNamedBytesFilter::decode_log(log) {
                return Ok(StakingEvents::LogNamedBytesFilter(decoded));
            }
            if let Ok(decoded) = LogNamedBytes32Filter::decode_log(log) {
                return Ok(StakingEvents::LogNamedBytes32Filter(decoded));
            }
            if let Ok(decoded) = LogNamedDecimalIntFilter::decode_log(log) {
                return Ok(StakingEvents::LogNamedDecimalIntFilter(decoded));
            }
            if let Ok(decoded) = LogNamedDecimalUintFilter::decode_log(log) {
                return Ok(StakingEvents::LogNamedDecimalUintFilter(decoded));
            }
            if let Ok(decoded) = LogNamedIntFilter::decode_log(log) {
                return Ok(StakingEvents::LogNamedIntFilter(decoded));
            }
            if let Ok(decoded) = LogNamedStringFilter::decode_log(log) {
                return Ok(StakingEvents::LogNamedStringFilter(decoded));
            }
            if let Ok(decoded) = LogNamedUintFilter::decode_log(log) {
                return Ok(StakingEvents::LogNamedUintFilter(decoded));
            }
            if let Ok(decoded) = LogStringFilter::decode_log(log) {
                return Ok(StakingEvents::LogStringFilter(decoded));
            }
            if let Ok(decoded) = LogUintFilter::decode_log(log) {
                return Ok(StakingEvents::LogUintFilter(decoded));
            }
            if let Ok(decoded) = LogsFilter::decode_log(log) {
                return Ok(StakingEvents::LogsFilter(decoded));
            }
            Err(::ethers::core::abi::Error::InvalidData)
        }
    }
    impl ::core::fmt::Display for StakingEvents {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            match self {
                Self::AdvancedEpochFilter(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::ApprovalFilter(element) => ::core::fmt::Display::fmt(element, f),
                Self::ApprovalForAllFilter(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::AttestedWalletRegisteredFilter(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::ClearOfflinePhaseDataFilter(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::ComplaintConfigSetFilter(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::ConfigSetFilter(element) => ::core::fmt::Display::fmt(element, f),
                Self::CountOfflinePhaseDataFilter(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::DebugEventFilter(element) => ::core::fmt::Display::fmt(element, f),
                Self::DevopsAdminSetFilter(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::DiamondCutFilter(element) => ::core::fmt::Display::fmt(element, f),
                Self::EpochEndTimeSetFilter(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::EpochLengthSetFilter(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::EpochTimeoutSetFilter(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::FixedCostRewardsClaimedFilter(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::KeySetConfigSetFilter(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::KeySetConfigUpdatedFilter(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::KickPenaltyPercentSetFilter(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::OwnershipTransferredFilter(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::ReadyForNextEpochFilter(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::RecoveredFilter(element) => ::core::fmt::Display::fmt(element, f),
                Self::RequestToJoin1Filter(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::RequestToJoin2Filter(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::RequestToLeaveFilter(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::ResolverContractAddressSetFilter(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::RewardsDurationUpdatedFilter(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::StakeRecordCreatedFilter(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::StakeRecordRemovedFilter(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::StakeRecordUpdatedFilter(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::StakeRewardsClaimed1Filter(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::StakeRewardsClaimed2Filter(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::StakedFilter(element) => ::core::fmt::Display::fmt(element, f),
                Self::StakingTokenSetFilter(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::StateChangedFilter(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::TransferFilter(element) => ::core::fmt::Display::fmt(element, f),
                Self::TrustedForwarderSetFilter(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::ValidatorBannedFilter(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::ValidatorCommissionClaimedFilter(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::ValidatorKickedFromNextEpochFilter(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::ValidatorRegisteredFilter(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::ValidatorRejoinedNextEpochFilter(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::VersionRequirementsUpdatedFilter(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::VoteToAdvanceTimeOutElapsedFilter(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::VotedToKickValidatorInNextEpochFilter(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::WithdrawnFilter(element) => ::core::fmt::Display::fmt(element, f),
                Self::LogFilter(element) => ::core::fmt::Display::fmt(element, f),
                Self::LogAddressFilter(element) => ::core::fmt::Display::fmt(element, f),
                Self::LogArray1Filter(element) => ::core::fmt::Display::fmt(element, f),
                Self::LogArray2Filter(element) => ::core::fmt::Display::fmt(element, f),
                Self::LogArray3Filter(element) => ::core::fmt::Display::fmt(element, f),
                Self::LogBytesFilter(element) => ::core::fmt::Display::fmt(element, f),
                Self::LogBytes32Filter(element) => ::core::fmt::Display::fmt(element, f),
                Self::LogIntFilter(element) => ::core::fmt::Display::fmt(element, f),
                Self::LogNamedAddressFilter(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::LogNamedArray1Filter(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::LogNamedArray2Filter(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::LogNamedArray3Filter(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::LogNamedBytesFilter(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::LogNamedBytes32Filter(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::LogNamedDecimalIntFilter(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::LogNamedDecimalUintFilter(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::LogNamedIntFilter(element) => ::core::fmt::Display::fmt(element, f),
                Self::LogNamedStringFilter(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::LogNamedUintFilter(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::LogStringFilter(element) => ::core::fmt::Display::fmt(element, f),
                Self::LogUintFilter(element) => ::core::fmt::Display::fmt(element, f),
                Self::LogsFilter(element) => ::core::fmt::Display::fmt(element, f),
            }
        }
    }
    impl ::core::convert::From<AdvancedEpochFilter> for StakingEvents {
        fn from(value: AdvancedEpochFilter) -> Self {
            Self::AdvancedEpochFilter(value)
        }
    }
    impl ::core::convert::From<ApprovalFilter> for StakingEvents {
        fn from(value: ApprovalFilter) -> Self {
            Self::ApprovalFilter(value)
        }
    }
    impl ::core::convert::From<ApprovalForAllFilter> for StakingEvents {
        fn from(value: ApprovalForAllFilter) -> Self {
            Self::ApprovalForAllFilter(value)
        }
    }
    impl ::core::convert::From<AttestedWalletRegisteredFilter> for StakingEvents {
        fn from(value: AttestedWalletRegisteredFilter) -> Self {
            Self::AttestedWalletRegisteredFilter(value)
        }
    }
    impl ::core::convert::From<ClearOfflinePhaseDataFilter> for StakingEvents {
        fn from(value: ClearOfflinePhaseDataFilter) -> Self {
            Self::ClearOfflinePhaseDataFilter(value)
        }
    }
    impl ::core::convert::From<ComplaintConfigSetFilter> for StakingEvents {
        fn from(value: ComplaintConfigSetFilter) -> Self {
            Self::ComplaintConfigSetFilter(value)
        }
    }
    impl ::core::convert::From<ConfigSetFilter> for StakingEvents {
        fn from(value: ConfigSetFilter) -> Self {
            Self::ConfigSetFilter(value)
        }
    }
    impl ::core::convert::From<CountOfflinePhaseDataFilter> for StakingEvents {
        fn from(value: CountOfflinePhaseDataFilter) -> Self {
            Self::CountOfflinePhaseDataFilter(value)
        }
    }
    impl ::core::convert::From<DebugEventFilter> for StakingEvents {
        fn from(value: DebugEventFilter) -> Self {
            Self::DebugEventFilter(value)
        }
    }
    impl ::core::convert::From<DevopsAdminSetFilter> for StakingEvents {
        fn from(value: DevopsAdminSetFilter) -> Self {
            Self::DevopsAdminSetFilter(value)
        }
    }
    impl ::core::convert::From<DiamondCutFilter> for StakingEvents {
        fn from(value: DiamondCutFilter) -> Self {
            Self::DiamondCutFilter(value)
        }
    }
    impl ::core::convert::From<EpochEndTimeSetFilter> for StakingEvents {
        fn from(value: EpochEndTimeSetFilter) -> Self {
            Self::EpochEndTimeSetFilter(value)
        }
    }
    impl ::core::convert::From<EpochLengthSetFilter> for StakingEvents {
        fn from(value: EpochLengthSetFilter) -> Self {
            Self::EpochLengthSetFilter(value)
        }
    }
    impl ::core::convert::From<EpochTimeoutSetFilter> for StakingEvents {
        fn from(value: EpochTimeoutSetFilter) -> Self {
            Self::EpochTimeoutSetFilter(value)
        }
    }
    impl ::core::convert::From<FixedCostRewardsClaimedFilter> for StakingEvents {
        fn from(value: FixedCostRewardsClaimedFilter) -> Self {
            Self::FixedCostRewardsClaimedFilter(value)
        }
    }
    impl ::core::convert::From<KeySetConfigSetFilter> for StakingEvents {
        fn from(value: KeySetConfigSetFilter) -> Self {
            Self::KeySetConfigSetFilter(value)
        }
    }
    impl ::core::convert::From<KeySetConfigUpdatedFilter> for StakingEvents {
        fn from(value: KeySetConfigUpdatedFilter) -> Self {
            Self::KeySetConfigUpdatedFilter(value)
        }
    }
    impl ::core::convert::From<KickPenaltyPercentSetFilter> for StakingEvents {
        fn from(value: KickPenaltyPercentSetFilter) -> Self {
            Self::KickPenaltyPercentSetFilter(value)
        }
    }
    impl ::core::convert::From<OwnershipTransferredFilter> for StakingEvents {
        fn from(value: OwnershipTransferredFilter) -> Self {
            Self::OwnershipTransferredFilter(value)
        }
    }
    impl ::core::convert::From<ReadyForNextEpochFilter> for StakingEvents {
        fn from(value: ReadyForNextEpochFilter) -> Self {
            Self::ReadyForNextEpochFilter(value)
        }
    }
    impl ::core::convert::From<RecoveredFilter> for StakingEvents {
        fn from(value: RecoveredFilter) -> Self {
            Self::RecoveredFilter(value)
        }
    }
    impl ::core::convert::From<RequestToJoin1Filter> for StakingEvents {
        fn from(value: RequestToJoin1Filter) -> Self {
            Self::RequestToJoin1Filter(value)
        }
    }
    impl ::core::convert::From<RequestToJoin2Filter> for StakingEvents {
        fn from(value: RequestToJoin2Filter) -> Self {
            Self::RequestToJoin2Filter(value)
        }
    }
    impl ::core::convert::From<RequestToLeaveFilter> for StakingEvents {
        fn from(value: RequestToLeaveFilter) -> Self {
            Self::RequestToLeaveFilter(value)
        }
    }
    impl ::core::convert::From<ResolverContractAddressSetFilter> for StakingEvents {
        fn from(value: ResolverContractAddressSetFilter) -> Self {
            Self::ResolverContractAddressSetFilter(value)
        }
    }
    impl ::core::convert::From<RewardsDurationUpdatedFilter> for StakingEvents {
        fn from(value: RewardsDurationUpdatedFilter) -> Self {
            Self::RewardsDurationUpdatedFilter(value)
        }
    }
    impl ::core::convert::From<StakeRecordCreatedFilter> for StakingEvents {
        fn from(value: StakeRecordCreatedFilter) -> Self {
            Self::StakeRecordCreatedFilter(value)
        }
    }
    impl ::core::convert::From<StakeRecordRemovedFilter> for StakingEvents {
        fn from(value: StakeRecordRemovedFilter) -> Self {
            Self::StakeRecordRemovedFilter(value)
        }
    }
    impl ::core::convert::From<StakeRecordUpdatedFilter> for StakingEvents {
        fn from(value: StakeRecordUpdatedFilter) -> Self {
            Self::StakeRecordUpdatedFilter(value)
        }
    }
    impl ::core::convert::From<StakeRewardsClaimed1Filter> for StakingEvents {
        fn from(value: StakeRewardsClaimed1Filter) -> Self {
            Self::StakeRewardsClaimed1Filter(value)
        }
    }
    impl ::core::convert::From<StakeRewardsClaimed2Filter> for StakingEvents {
        fn from(value: StakeRewardsClaimed2Filter) -> Self {
            Self::StakeRewardsClaimed2Filter(value)
        }
    }
    impl ::core::convert::From<StakedFilter> for StakingEvents {
        fn from(value: StakedFilter) -> Self {
            Self::StakedFilter(value)
        }
    }
    impl ::core::convert::From<StakingTokenSetFilter> for StakingEvents {
        fn from(value: StakingTokenSetFilter) -> Self {
            Self::StakingTokenSetFilter(value)
        }
    }
    impl ::core::convert::From<StateChangedFilter> for StakingEvents {
        fn from(value: StateChangedFilter) -> Self {
            Self::StateChangedFilter(value)
        }
    }
    impl ::core::convert::From<TransferFilter> for StakingEvents {
        fn from(value: TransferFilter) -> Self {
            Self::TransferFilter(value)
        }
    }
    impl ::core::convert::From<TrustedForwarderSetFilter> for StakingEvents {
        fn from(value: TrustedForwarderSetFilter) -> Self {
            Self::TrustedForwarderSetFilter(value)
        }
    }
    impl ::core::convert::From<ValidatorBannedFilter> for StakingEvents {
        fn from(value: ValidatorBannedFilter) -> Self {
            Self::ValidatorBannedFilter(value)
        }
    }
    impl ::core::convert::From<ValidatorCommissionClaimedFilter> for StakingEvents {
        fn from(value: ValidatorCommissionClaimedFilter) -> Self {
            Self::ValidatorCommissionClaimedFilter(value)
        }
    }
    impl ::core::convert::From<ValidatorKickedFromNextEpochFilter> for StakingEvents {
        fn from(value: ValidatorKickedFromNextEpochFilter) -> Self {
            Self::ValidatorKickedFromNextEpochFilter(value)
        }
    }
    impl ::core::convert::From<ValidatorRegisteredFilter> for StakingEvents {
        fn from(value: ValidatorRegisteredFilter) -> Self {
            Self::ValidatorRegisteredFilter(value)
        }
    }
    impl ::core::convert::From<ValidatorRejoinedNextEpochFilter> for StakingEvents {
        fn from(value: ValidatorRejoinedNextEpochFilter) -> Self {
            Self::ValidatorRejoinedNextEpochFilter(value)
        }
    }
    impl ::core::convert::From<VersionRequirementsUpdatedFilter> for StakingEvents {
        fn from(value: VersionRequirementsUpdatedFilter) -> Self {
            Self::VersionRequirementsUpdatedFilter(value)
        }
    }
    impl ::core::convert::From<VoteToAdvanceTimeOutElapsedFilter> for StakingEvents {
        fn from(value: VoteToAdvanceTimeOutElapsedFilter) -> Self {
            Self::VoteToAdvanceTimeOutElapsedFilter(value)
        }
    }
    impl ::core::convert::From<VotedToKickValidatorInNextEpochFilter> for StakingEvents {
        fn from(value: VotedToKickValidatorInNextEpochFilter) -> Self {
            Self::VotedToKickValidatorInNextEpochFilter(value)
        }
    }
    impl ::core::convert::From<WithdrawnFilter> for StakingEvents {
        fn from(value: WithdrawnFilter) -> Self {
            Self::WithdrawnFilter(value)
        }
    }
    impl ::core::convert::From<LogFilter> for StakingEvents {
        fn from(value: LogFilter) -> Self {
            Self::LogFilter(value)
        }
    }
    impl ::core::convert::From<LogAddressFilter> for StakingEvents {
        fn from(value: LogAddressFilter) -> Self {
            Self::LogAddressFilter(value)
        }
    }
    impl ::core::convert::From<LogArray1Filter> for StakingEvents {
        fn from(value: LogArray1Filter) -> Self {
            Self::LogArray1Filter(value)
        }
    }
    impl ::core::convert::From<LogArray2Filter> for StakingEvents {
        fn from(value: LogArray2Filter) -> Self {
            Self::LogArray2Filter(value)
        }
    }
    impl ::core::convert::From<LogArray3Filter> for StakingEvents {
        fn from(value: LogArray3Filter) -> Self {
            Self::LogArray3Filter(value)
        }
    }
    impl ::core::convert::From<LogBytesFilter> for StakingEvents {
        fn from(value: LogBytesFilter) -> Self {
            Self::LogBytesFilter(value)
        }
    }
    impl ::core::convert::From<LogBytes32Filter> for StakingEvents {
        fn from(value: LogBytes32Filter) -> Self {
            Self::LogBytes32Filter(value)
        }
    }
    impl ::core::convert::From<LogIntFilter> for StakingEvents {
        fn from(value: LogIntFilter) -> Self {
            Self::LogIntFilter(value)
        }
    }
    impl ::core::convert::From<LogNamedAddressFilter> for StakingEvents {
        fn from(value: LogNamedAddressFilter) -> Self {
            Self::LogNamedAddressFilter(value)
        }
    }
    impl ::core::convert::From<LogNamedArray1Filter> for StakingEvents {
        fn from(value: LogNamedArray1Filter) -> Self {
            Self::LogNamedArray1Filter(value)
        }
    }
    impl ::core::convert::From<LogNamedArray2Filter> for StakingEvents {
        fn from(value: LogNamedArray2Filter) -> Self {
            Self::LogNamedArray2Filter(value)
        }
    }
    impl ::core::convert::From<LogNamedArray3Filter> for StakingEvents {
        fn from(value: LogNamedArray3Filter) -> Self {
            Self::LogNamedArray3Filter(value)
        }
    }
    impl ::core::convert::From<LogNamedBytesFilter> for StakingEvents {
        fn from(value: LogNamedBytesFilter) -> Self {
            Self::LogNamedBytesFilter(value)
        }
    }
    impl ::core::convert::From<LogNamedBytes32Filter> for StakingEvents {
        fn from(value: LogNamedBytes32Filter) -> Self {
            Self::LogNamedBytes32Filter(value)
        }
    }
    impl ::core::convert::From<LogNamedDecimalIntFilter> for StakingEvents {
        fn from(value: LogNamedDecimalIntFilter) -> Self {
            Self::LogNamedDecimalIntFilter(value)
        }
    }
    impl ::core::convert::From<LogNamedDecimalUintFilter> for StakingEvents {
        fn from(value: LogNamedDecimalUintFilter) -> Self {
            Self::LogNamedDecimalUintFilter(value)
        }
    }
    impl ::core::convert::From<LogNamedIntFilter> for StakingEvents {
        fn from(value: LogNamedIntFilter) -> Self {
            Self::LogNamedIntFilter(value)
        }
    }
    impl ::core::convert::From<LogNamedStringFilter> for StakingEvents {
        fn from(value: LogNamedStringFilter) -> Self {
            Self::LogNamedStringFilter(value)
        }
    }
    impl ::core::convert::From<LogNamedUintFilter> for StakingEvents {
        fn from(value: LogNamedUintFilter) -> Self {
            Self::LogNamedUintFilter(value)
        }
    }
    impl ::core::convert::From<LogStringFilter> for StakingEvents {
        fn from(value: LogStringFilter) -> Self {
            Self::LogStringFilter(value)
        }
    }
    impl ::core::convert::From<LogUintFilter> for StakingEvents {
        fn from(value: LogUintFilter) -> Self {
            Self::LogUintFilter(value)
        }
    }
    impl ::core::convert::From<LogsFilter> for StakingEvents {
        fn from(value: LogsFilter) -> Self {
            Self::LogsFilter(value)
        }
    }
    ///Container type for all input parameters for the `IS_TEST` function with signature `IS_TEST()` and selector `0xfa7626d4`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "IS_TEST", abi = "IS_TEST()")]
    pub struct IsTestCall;
    ///Container type for all input parameters for the `_generateAddresses` function with signature `_generateAddresses(uint256)` and selector `0x678ac78a`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "_generateAddresses", abi = "_generateAddresses(uint256)")]
    pub struct GenerateAddressesCall {
        pub num_addresses: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `_generateAddressesWithOffset` function with signature `_generateAddressesWithOffset(uint256,uint256)` and selector `0xa5187b2b`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "_generateAddressesWithOffset",
        abi = "_generateAddressesWithOffset(uint256,uint256)"
    )]
    pub struct GenerateAddressesWithOffsetCall {
        pub num_addresses: ::ethers::core::types::U256,
        pub offset: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `_generatePubKeys` function with signature `_generatePubKeys(uint256)` and selector `0xfed0a77b`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "_generatePubKeys", abi = "_generatePubKeys(uint256)")]
    pub struct GeneratePubKeysCall {
        pub stakers: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `_generateUint256s` function with signature `_generateUint256s(uint256)` and selector `0xae517f4d`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "_generateUint256s", abi = "_generateUint256s(uint256)")]
    pub struct GenerateUint256SCall {
        pub num_uint_25_6s: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `_generateUint256sWithOffset` function with signature `_generateUint256sWithOffset(uint256,uint256)` and selector `0xfb9d55b8`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "_generateUint256sWithOffset",
        abi = "_generateUint256sWithOffset(uint256,uint256)"
    )]
    pub struct GenerateUint256SWithOffsetCall {
        pub num_uint_25_6s: ::ethers::core::types::U256,
        pub offset: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `_generateValidators` function with signature `_generateValidators(uint256)` and selector `0xc5344d40`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "_generateValidators", abi = "_generateValidators(uint256)")]
    pub struct GenerateValidatorsCall {
        pub num_validators: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `addRealm` function with signature `addRealm()` and selector `0x472a7d89`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "addRealm", abi = "addRealm()")]
    pub struct AddRealmCall;
    ///Container type for all input parameters for the `adminKickValidatorInNextEpoch` function with signature `adminKickValidatorInNextEpoch(address)` and selector `0x7aa086e7`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "adminKickValidatorInNextEpoch",
        abi = "adminKickValidatorInNextEpoch(address)"
    )]
    pub struct AdminKickValidatorInNextEpochCall {
        pub validator_staker_address: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `adminRejoinValidator` function with signature `adminRejoinValidator(uint256,address)` and selector `0x4cd938ce`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "adminRejoinValidator",
        abi = "adminRejoinValidator(uint256,address)"
    )]
    pub struct AdminRejoinValidatorCall {
        pub realm_id: ::ethers::core::types::U256,
        pub staker_address: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `adminSetValidatorRegisterAttestedWalletDisabled` function with signature `adminSetValidatorRegisterAttestedWalletDisabled(address,bool)` and selector `0x15319384`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "adminSetValidatorRegisterAttestedWalletDisabled",
        abi = "adminSetValidatorRegisterAttestedWalletDisabled(address,bool)"
    )]
    pub struct AdminSetValidatorRegisterAttestedWalletDisabledCall {
        pub validator_address: ::ethers::core::types::Address,
        pub disabled: bool,
    }
    ///Container type for all input parameters for the `adminSetValidatorsInCurrentEpoch` function with signature `adminSetValidatorsInCurrentEpoch(uint256,address[])` and selector `0x7db39fb4`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "adminSetValidatorsInCurrentEpoch",
        abi = "adminSetValidatorsInCurrentEpoch(uint256,address[])"
    )]
    pub struct AdminSetValidatorsInCurrentEpochCall {
        pub realm_id: ::ethers::core::types::U256,
        pub validators_for_current_epoch: ::std::vec::Vec<
            ::ethers::core::types::Address,
        >,
    }
    ///Container type for all input parameters for the `adminSetValidatorsInNextEpoch` function with signature `adminSetValidatorsInNextEpoch(uint256,address[])` and selector `0x2d5e1361`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "adminSetValidatorsInNextEpoch",
        abi = "adminSetValidatorsInNextEpoch(uint256,address[])"
    )]
    pub struct AdminSetValidatorsInNextEpochCall {
        pub realm_id: ::ethers::core::types::U256,
        pub validators_for_next_epoch: ::std::vec::Vec<::ethers::core::types::Address>,
    }
    ///Container type for all input parameters for the `adminSetupShadowSplicing` function with signature `adminSetupShadowSplicing(uint256,uint256,address[])` and selector `0x684d8bd9`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "adminSetupShadowSplicing",
        abi = "adminSetupShadowSplicing(uint256,uint256,address[])"
    )]
    pub struct AdminSetupShadowSplicingCall {
        pub source_realm_id: ::ethers::core::types::U256,
        pub target_realm_id: ::ethers::core::types::U256,
        pub target_validators: ::std::vec::Vec<::ethers::core::types::Address>,
    }
    ///Container type for all input parameters for the `adminSlashValidator` function with signature `adminSlashValidator(uint256,address)` and selector `0x1f1c50cb`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "adminSlashValidator",
        abi = "adminSlashValidator(uint256,address)"
    )]
    pub struct AdminSlashValidatorCall {
        pub percentage: ::ethers::core::types::U256,
        pub staker_address: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `adminStakeForUser` function with signature `adminStakeForUser(address,address,uint256,uint256)` and selector `0xf5008ed2`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "adminStakeForUser",
        abi = "adminStakeForUser(address,address,uint256,uint256)"
    )]
    pub struct AdminStakeForUserCall {
        pub user_staker_address: ::ethers::core::types::Address,
        pub operator_staker_address: ::ethers::core::types::Address,
        pub time_lock: ::ethers::core::types::U256,
        pub amount: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `adminUnfreezeForUser` function with signature `adminUnfreezeForUser(address,address,uint256)` and selector `0x06732018`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "adminUnfreezeForUser",
        abi = "adminUnfreezeForUser(address,address,uint256)"
    )]
    pub struct AdminUnfreezeForUserCall {
        pub user_staker_address: ::ethers::core::types::Address,
        pub operator_staker_address: ::ethers::core::types::Address,
        pub stake_id: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `advanceEpoch` function with signature `advanceEpoch(uint256)` and selector `0xf3b87779`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "advanceEpoch", abi = "advanceEpoch(uint256)")]
    pub struct AdvanceEpochCall {
        pub realm_id: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `approve` function with signature `approve(address,uint256)` and selector `0x095ea7b3`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "approve", abi = "approve(address,uint256)")]
    pub struct ApproveCall {
        pub approved: ::ethers::core::types::Address,
        pub token_id: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `balanceOf` function with signature `balanceOf(address)` and selector `0x70a08231`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "balanceOf", abi = "balanceOf(address)")]
    pub struct BalanceOfCall {
        pub owner: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `calculateRewardsPerDay` function with signature `calculateRewardsPerDay((uint256,uint256,address[],uint256))` and selector `0x9be372e0`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "calculateRewardsPerDay",
        abi = "calculateRewardsPerDay((uint256,uint256,address[],uint256))"
    )]
    pub struct CalculateRewardsPerDayCall {
        pub global_stats: RewardEpochGlobalStats,
    }
    ///Container type for all input parameters for the `calculateStakeWeight` function with signature `calculateStakeWeight(uint256,uint256)` and selector `0x2b7c29e3`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "calculateStakeWeight",
        abi = "calculateStakeWeight(uint256,uint256)"
    )]
    pub struct CalculateStakeWeightCall {
        pub time_lock: ::ethers::core::types::U256,
        pub amount: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `checkActiveOrUnlockedOrPausedState` function with signature `checkActiveOrUnlockedOrPausedState(uint8)` and selector `0xb6e184c0`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "checkActiveOrUnlockedOrPausedState",
        abi = "checkActiveOrUnlockedOrPausedState(uint8)"
    )]
    pub struct CheckActiveOrUnlockedOrPausedStateCall {
        pub state: u8,
    }
    ///Container type for all input parameters for the `checkStakingAmounts` function with signature `checkStakingAmounts(address)` and selector `0x49919966`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "checkStakingAmounts", abi = "checkStakingAmounts(address)")]
    pub struct CheckStakingAmountsCall {
        pub staker_address: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `checkVersion` function with signature `checkVersion(uint256,(uint256,uint256,uint256))` and selector `0xcffbfc20`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "checkVersion",
        abi = "checkVersion(uint256,(uint256,uint256,uint256))"
    )]
    pub struct CheckVersionCall {
        pub realm_id: ::ethers::core::types::U256,
        pub version: Version,
    }
    ///Container type for all input parameters for the `claimFixedCostRewards` function with signature `claimFixedCostRewards(uint256,uint256)` and selector `0xcc5e546b`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "claimFixedCostRewards",
        abi = "claimFixedCostRewards(uint256,uint256)"
    )]
    pub struct ClaimFixedCostRewardsCall {
        pub realm_id: ::ethers::core::types::U256,
        pub max_number_of_epochs_to_claim: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `claimStakeRewards` function with signature `claimStakeRewards(uint256,address,uint256,uint256)` and selector `0x0ffb0d94`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "claimStakeRewards",
        abi = "claimStakeRewards(uint256,address,uint256,uint256)"
    )]
    pub struct ClaimStakeRewardsCall {
        pub realm_id: ::ethers::core::types::U256,
        pub staker_address: ::ethers::core::types::Address,
        pub stake_record_id: ::ethers::core::types::U256,
        pub max_number_of_epochs_to_claim: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `claimValidatorCommission` function with signature `claimValidatorCommission(uint256,uint256)` and selector `0x123eab4b`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "claimValidatorCommission",
        abi = "claimValidatorCommission(uint256,uint256)"
    )]
    pub struct ClaimValidatorCommissionCall {
        pub realm_id: ::ethers::core::types::U256,
        pub max_number_of_epochs_to_claim: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `complaintConfig` function with signature `complaintConfig(uint256)` and selector `0x02f6da56`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "complaintConfig", abi = "complaintConfig(uint256)")]
    pub struct ComplaintConfigCall {
        pub reason: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `contractResolver` function with signature `contractResolver()` and selector `0x50d17b5e`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "contractResolver", abi = "contractResolver()")]
    pub struct ContractResolverCall;
    ///Container type for all input parameters for the `countOfCurrentValidatorsReadyForNextEpoch` function with signature `countOfCurrentValidatorsReadyForNextEpoch(uint256)` and selector `0x31232f31`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "countOfCurrentValidatorsReadyForNextEpoch",
        abi = "countOfCurrentValidatorsReadyForNextEpoch(uint256)"
    )]
    pub struct CountOfCurrentValidatorsReadyForNextEpochCall {
        pub realm_id: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `countOfNextValidatorsReadyForNextEpoch` function with signature `countOfNextValidatorsReadyForNextEpoch(uint256)` and selector `0xdce6f078`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "countOfNextValidatorsReadyForNextEpoch",
        abi = "countOfNextValidatorsReadyForNextEpoch(uint256)"
    )]
    pub struct CountOfNextValidatorsReadyForNextEpochCall {
        pub realm_id: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `currentValidatorCountForConsensus` function with signature `currentValidatorCountForConsensus(uint256)` and selector `0x9423f589`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "currentValidatorCountForConsensus",
        abi = "currentValidatorCountForConsensus(uint256)"
    )]
    pub struct CurrentValidatorCountForConsensusCall {
        pub realm_id: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `decreaseRewardPool` function with signature `decreaseRewardPool(uint256,uint256)` and selector `0xfc36f915`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "decreaseRewardPool", abi = "decreaseRewardPool(uint256,uint256)")]
    pub struct DecreaseRewardPoolCall {
        pub realm_id: ::ethers::core::types::U256,
        pub amount: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `deleteKeySet` function with signature `deleteKeySet(string)` and selector `0x0815b188`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "deleteKeySet", abi = "deleteKeySet(string)")]
    pub struct DeleteKeySetCall {
        pub identifier: ::std::string::String,
    }
    ///Container type for all input parameters for the `diamondCut` function with signature `diamondCut((address,uint8,bytes4[])[],address,bytes)` and selector `0x1f931c1c`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "diamondCut",
        abi = "diamondCut((address,uint8,bytes4[])[],address,bytes)"
    )]
    pub struct DiamondCutCall {
        pub diamond_cut: ::std::vec::Vec<FacetCut>,
        pub init: ::ethers::core::types::Address,
        pub calldata: ::ethers::core::types::Bytes,
    }
    ///Container type for all input parameters for the `emitClearOfflinePhaseData` function with signature `emitClearOfflinePhaseData(uint256)` and selector `0x00a52713`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "emitClearOfflinePhaseData",
        abi = "emitClearOfflinePhaseData(uint256)"
    )]
    pub struct EmitClearOfflinePhaseDataCall {
        pub data_type: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `emitCountOfflinePhaseData` function with signature `emitCountOfflinePhaseData(uint256)` and selector `0x9a74745d`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "emitCountOfflinePhaseData",
        abi = "emitCountOfflinePhaseData(uint256)"
    )]
    pub struct EmitCountOfflinePhaseDataCall {
        pub data_type: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `epoch` function with signature `epoch(uint256)` and selector `0x5487c577`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "epoch", abi = "epoch(uint256)")]
    pub struct EpochCall {
        pub realm_id: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `excludeArtifacts` function with signature `excludeArtifacts()` and selector `0xb5508aa9`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "excludeArtifacts", abi = "excludeArtifacts()")]
    pub struct ExcludeArtifactsCall;
    ///Container type for all input parameters for the `excludeContracts` function with signature `excludeContracts()` and selector `0xe20c9f71`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "excludeContracts", abi = "excludeContracts()")]
    pub struct ExcludeContractsCall;
    ///Container type for all input parameters for the `excludeSelectors` function with signature `excludeSelectors()` and selector `0xb0464fdc`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "excludeSelectors", abi = "excludeSelectors()")]
    pub struct ExcludeSelectorsCall;
    ///Container type for all input parameters for the `excludeSenders` function with signature `excludeSenders()` and selector `0x1ed7831c`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "excludeSenders", abi = "excludeSenders()")]
    pub struct ExcludeSendersCall;
    ///Container type for all input parameters for the `exit` function with signature `exit()` and selector `0xe9fad8ee`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "exit", abi = "exit()")]
    pub struct ExitCall;
    ///Container type for all input parameters for the `facetAddress` function with signature `facetAddress(bytes4)` and selector `0xcdffacc6`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "facetAddress", abi = "facetAddress(bytes4)")]
    pub struct FacetAddressCall {
        pub function_selector: [u8; 4],
    }
    ///Container type for all input parameters for the `facetAddresses` function with signature `facetAddresses()` and selector `0x52ef6b2c`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "facetAddresses", abi = "facetAddresses()")]
    pub struct FacetAddressesCall;
    ///Container type for all input parameters for the `facetFunctionSelectors` function with signature `facetFunctionSelectors(address)` and selector `0xadfca15e`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "facetFunctionSelectors", abi = "facetFunctionSelectors(address)")]
    pub struct FacetFunctionSelectorsCall {
        pub facet: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `facets` function with signature `facets()` and selector `0x7a0ed627`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "facets", abi = "facets()")]
    pub struct FacetsCall;
    ///Container type for all input parameters for the `failed` function with signature `failed()` and selector `0xba414fa6`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "failed", abi = "failed()")]
    pub struct FailedCall;
    ///Container type for all input parameters for the `getActiveUnkickedValidatorCount` function with signature `getActiveUnkickedValidatorCount(uint256)` and selector `0x7a808c0d`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "getActiveUnkickedValidatorCount",
        abi = "getActiveUnkickedValidatorCount(uint256)"
    )]
    pub struct GetActiveUnkickedValidatorCountCall {
        pub realm_id: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `getActiveUnkickedValidatorStructs` function with signature `getActiveUnkickedValidatorStructs(uint256)` and selector `0xe4ccc020`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "getActiveUnkickedValidatorStructs",
        abi = "getActiveUnkickedValidatorStructs(uint256)"
    )]
    pub struct GetActiveUnkickedValidatorStructsCall {
        pub realm_id: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `getActiveUnkickedValidatorStructsAndCounts` function with signature `getActiveUnkickedValidatorStructsAndCounts(uint256)` and selector `0xd09cd5a8`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "getActiveUnkickedValidatorStructsAndCounts",
        abi = "getActiveUnkickedValidatorStructsAndCounts(uint256)"
    )]
    pub struct GetActiveUnkickedValidatorStructsAndCountsCall {
        pub realm_id: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `getActiveUnkickedValidators` function with signature `getActiveUnkickedValidators(uint256)` and selector `0x8b6de0d1`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "getActiveUnkickedValidators",
        abi = "getActiveUnkickedValidators(uint256)"
    )]
    pub struct GetActiveUnkickedValidatorsCall {
        pub realm_id: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `getAllReserveValidators` function with signature `getAllReserveValidators()` and selector `0xbd8578d6`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "getAllReserveValidators", abi = "getAllReserveValidators()")]
    pub struct GetAllReserveValidatorsCall;
    ///Container type for all input parameters for the `getAllUnkickedValidators` function with signature `getAllUnkickedValidators()` and selector `0x0df47a24`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "getAllUnkickedValidators", abi = "getAllUnkickedValidators()")]
    pub struct GetAllUnkickedValidatorsCall;
    ///Container type for all input parameters for the `getAllValidators` function with signature `getAllValidators()` and selector `0xf3513a37`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "getAllValidators", abi = "getAllValidators()")]
    pub struct GetAllValidatorsCall;
    ///Container type for all input parameters for the `getApproved` function with signature `getApproved(uint256)` and selector `0x081812fc`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "getApproved", abi = "getApproved(uint256)")]
    pub struct GetApprovedCall {
        pub token_id: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `getAttestedPubKey` function with signature `getAttestedPubKey(address)` and selector `0xe9332ea7`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "getAttestedPubKey", abi = "getAttestedPubKey(address)")]
    pub struct GetAttestedPubKeyCall {
        pub attested_address: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `getCurrentRealmIdForStakerAddress` function with signature `getCurrentRealmIdForStakerAddress(address)` and selector `0x88de4e25`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "getCurrentRealmIdForStakerAddress",
        abi = "getCurrentRealmIdForStakerAddress(address)"
    )]
    pub struct GetCurrentRealmIdForStakerAddressCall {
        pub staker_address: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `getDelegatedStakersWithUnfreezingStakes` function with signature `getDelegatedStakersWithUnfreezingStakes(address,uint256,uint256)` and selector `0x9fe51529`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "getDelegatedStakersWithUnfreezingStakes",
        abi = "getDelegatedStakersWithUnfreezingStakes(address,uint256,uint256)"
    )]
    pub struct GetDelegatedStakersWithUnfreezingStakesCall {
        pub validator_address: ::ethers::core::types::Address,
        pub limit: ::ethers::core::types::U256,
        pub offset: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `getDelegatedStakersWithUnfreezingStakesCount` function with signature `getDelegatedStakersWithUnfreezingStakesCount(address)` and selector `0x8c3ccf4c`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "getDelegatedStakersWithUnfreezingStakesCount",
        abi = "getDelegatedStakersWithUnfreezingStakesCount(address)"
    )]
    pub struct GetDelegatedStakersWithUnfreezingStakesCountCall {
        pub validator_address: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `getEmptyStakeRecordSlots` function with signature `getEmptyStakeRecordSlots(address,address)` and selector `0xa6f67c51`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "getEmptyStakeRecordSlots",
        abi = "getEmptyStakeRecordSlots(address,address)"
    )]
    pub struct GetEmptyStakeRecordSlotsCall {
        pub user_staker_address: ::ethers::core::types::Address,
        pub operator_staker_address: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `getKeySet` function with signature `getKeySet(string)` and selector `0xa305e5fe`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "getKeySet", abi = "getKeySet(string)")]
    pub struct GetKeySetCall {
        pub identifier: ::std::string::String,
    }
    ///Container type for all input parameters for the `getKeyTypes` function with signature `getKeyTypes()` and selector `0xf1b877a8`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "getKeyTypes", abi = "getKeyTypes()")]
    pub struct GetKeyTypesCall;
    ///Container type for all input parameters for the `getKickedValidators` function with signature `getKickedValidators(uint256)` and selector `0x4b6afbbb`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "getKickedValidators", abi = "getKickedValidators(uint256)")]
    pub struct GetKickedValidatorsCall {
        pub realm_id: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `getLastStakeRecord` function with signature `getLastStakeRecord(address,address)` and selector `0xfc73fb85`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "getLastStakeRecord", abi = "getLastStakeRecord(address,address)")]
    pub struct GetLastStakeRecordCall {
        pub user: ::ethers::core::types::Address,
        pub staker_address: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `getLitCirc` function with signature `getLitCirc()` and selector `0xebc17602`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "getLitCirc", abi = "getLitCirc()")]
    pub struct GetLitCircCall;
    ///Container type for all input parameters for the `getLowestRewardEpochNumber` function with signature `getLowestRewardEpochNumber()` and selector `0x3866c0ef`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "getLowestRewardEpochNumber", abi = "getLowestRewardEpochNumber()")]
    pub struct GetLowestRewardEpochNumberCall;
    ///Container type for all input parameters for the `getMaxVersion` function with signature `getMaxVersion(uint256)` and selector `0x73dd15ac`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "getMaxVersion", abi = "getMaxVersion(uint256)")]
    pub struct GetMaxVersionCall {
        pub realm_id: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `getMaxVersionString` function with signature `getMaxVersionString(uint256)` and selector `0x64a481f5`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "getMaxVersionString", abi = "getMaxVersionString(uint256)")]
    pub struct GetMaxVersionStringCall {
        pub realm_id: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `getMaximumStake` function with signature `getMaximumStake()` and selector `0x468a4883`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "getMaximumStake", abi = "getMaximumStake()")]
    pub struct GetMaximumStakeCall;
    ///Container type for all input parameters for the `getMinVersion` function with signature `getMinVersion(uint256)` and selector `0x18443e59`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "getMinVersion", abi = "getMinVersion(uint256)")]
    pub struct GetMinVersionCall {
        pub realm_id: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `getMinVersionString` function with signature `getMinVersionString(uint256)` and selector `0xf57610e3`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "getMinVersionString", abi = "getMinVersionString(uint256)")]
    pub struct GetMinVersionStringCall {
        pub realm_id: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `getMinimumSelfStake` function with signature `getMinimumSelfStake()` and selector `0x8bc97a37`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "getMinimumSelfStake", abi = "getMinimumSelfStake()")]
    pub struct GetMinimumSelfStakeCall;
    ///Container type for all input parameters for the `getMinimumStake` function with signature `getMinimumStake()` and selector `0xd9bbd278`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "getMinimumStake", abi = "getMinimumStake()")]
    pub struct GetMinimumStakeCall;
    ///Container type for all input parameters for the `getMostRecentStakeRecord` function with signature `getMostRecentStakeRecord(address,address)` and selector `0x7d0f412f`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "getMostRecentStakeRecord",
        abi = "getMostRecentStakeRecord(address,address)"
    )]
    pub struct GetMostRecentStakeRecordCall {
        pub user_staker_address: ::ethers::core::types::Address,
        pub operator_staker_address: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `getNodeAttestedPubKeyMappings` function with signature `getNodeAttestedPubKeyMappings(address[])` and selector `0x88790aee`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "getNodeAttestedPubKeyMappings",
        abi = "getNodeAttestedPubKeyMappings(address[])"
    )]
    pub struct GetNodeAttestedPubKeyMappingsCall {
        pub addresses: ::std::vec::Vec<::ethers::core::types::Address>,
    }
    ///Container type for all input parameters for the `getNodeDemerits` function with signature `getNodeDemerits(address)` and selector `0xa8d6cedd`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "getNodeDemerits", abi = "getNodeDemerits(address)")]
    pub struct GetNodeDemeritsCall {
        pub staker_address: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `getNodeStakerAddressMappings` function with signature `getNodeStakerAddressMappings(address[])` and selector `0x90fba112`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "getNodeStakerAddressMappings",
        abi = "getNodeStakerAddressMappings(address[])"
    )]
    pub struct GetNodeStakerAddressMappingsCall {
        pub addresses: ::std::vec::Vec<::ethers::core::types::Address>,
    }
    ///Container type for all input parameters for the `getNonShadowValidators` function with signature `getNonShadowValidators(uint256)` and selector `0x65e3dcf6`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "getNonShadowValidators", abi = "getNonShadowValidators(uint256)")]
    pub struct GetNonShadowValidatorsCall {
        pub realm_id: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `getNonShadowValidatorsInCurrentEpochLength` function with signature `getNonShadowValidatorsInCurrentEpochLength(uint256)` and selector `0x399ebc13`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "getNonShadowValidatorsInCurrentEpochLength",
        abi = "getNonShadowValidatorsInCurrentEpochLength(uint256)"
    )]
    pub struct GetNonShadowValidatorsInCurrentEpochLengthCall {
        pub realm_id: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `getRealmIdForStakerAddress` function with signature `getRealmIdForStakerAddress(address)` and selector `0xaa3bed0b`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "getRealmIdForStakerAddress",
        abi = "getRealmIdForStakerAddress(address)"
    )]
    pub struct GetRealmIdForStakerAddressCall {
        pub staker_address: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `getRewardEpoch` function with signature `getRewardEpoch(address,uint256)` and selector `0x7e867f87`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "getRewardEpoch", abi = "getRewardEpoch(address,uint256)")]
    pub struct GetRewardEpochCall {
        pub staker_address: ::ethers::core::types::Address,
        pub reward_epoch_number: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `getRewardEpochGlobalStats` function with signature `getRewardEpochGlobalStats(uint256)` and selector `0x2c9d1844`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "getRewardEpochGlobalStats",
        abi = "getRewardEpochGlobalStats(uint256)"
    )]
    pub struct GetRewardEpochGlobalStatsCall {
        pub epoch_number: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `getRewardEpochNumber` function with signature `getRewardEpochNumber(uint256)` and selector `0xba1d8fef`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "getRewardEpochNumber", abi = "getRewardEpochNumber(uint256)")]
    pub struct GetRewardEpochNumberCall {
        pub realm_id: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `getRewardEpochView` function with signature `getRewardEpochView(address,uint256)` and selector `0x709fe8a3`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "getRewardEpochView", abi = "getRewardEpochView(address,uint256)")]
    pub struct GetRewardEpochViewCall {
        pub staker_address: ::ethers::core::types::Address,
        pub reward_epoch_number: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `getSelfStakeRecordCount` function with signature `getSelfStakeRecordCount(address)` and selector `0x01362dc3`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "getSelfStakeRecordCount",
        abi = "getSelfStakeRecordCount(address)"
    )]
    pub struct GetSelfStakeRecordCountCall {
        pub staker_address: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `getShadowRealmIdForStakerAddress` function with signature `getShadowRealmIdForStakerAddress(address)` and selector `0x455636de`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "getShadowRealmIdForStakerAddress",
        abi = "getShadowRealmIdForStakerAddress(address)"
    )]
    pub struct GetShadowRealmIdForStakerAddressCall {
        pub staker_address: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `getShadowValidators` function with signature `getShadowValidators(uint256)` and selector `0xcc090c8a`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "getShadowValidators", abi = "getShadowValidators(uint256)")]
    pub struct GetShadowValidatorsCall {
        pub realm_id: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `getStakeRecord` function with signature `getStakeRecord(address,uint256,address)` and selector `0x114ed11d`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "getStakeRecord", abi = "getStakeRecord(address,uint256,address)")]
    pub struct GetStakeRecordCall {
        pub staker_address: ::ethers::core::types::Address,
        pub record_id: ::ethers::core::types::U256,
        pub user_staker_address: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `getStakeRecordCount` function with signature `getStakeRecordCount(address,address)` and selector `0x125fc3d4`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "getStakeRecordCount",
        abi = "getStakeRecordCount(address,address)"
    )]
    pub struct GetStakeRecordCountCall {
        pub user_staker_address: ::ethers::core::types::Address,
        pub operator_staker_address: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `getStakeRecordsForUser` function with signature `getStakeRecordsForUser(address,address)` and selector `0xdc1fab7f`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "getStakeRecordsForUser",
        abi = "getStakeRecordsForUser(address,address)"
    )]
    pub struct GetStakeRecordsForUserCall {
        pub user_staker_address: ::ethers::core::types::Address,
        pub operator_staker_address: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `getStakeWeightInEpoch` function with signature `getStakeWeightInEpoch(address,uint256,address,uint256)` and selector `0x580f68db`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "getStakeWeightInEpoch",
        abi = "getStakeWeightInEpoch(address,uint256,address,uint256)"
    )]
    pub struct GetStakeWeightInEpochCall {
        pub staker_address: ::ethers::core::types::Address,
        pub record_id: ::ethers::core::types::U256,
        pub user_staker_address: ::ethers::core::types::Address,
        pub reward_epoch_number: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `getThreshold` function with signature `getThreshold(uint256)` and selector `0x4615d5e9`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "getThreshold", abi = "getThreshold(uint256)")]
    pub struct GetThresholdCall {
        pub node_count: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `getTimelockInEpoch` function with signature `getTimelockInEpoch(address,(uint256,uint256,uint256,uint256,uint256,uint256,uint256,bool,bool,address,uint256),uint256)` and selector `0x2db912e4`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "getTimelockInEpoch",
        abi = "getTimelockInEpoch(address,(uint256,uint256,uint256,uint256,uint256,uint256,uint256,bool,bool,address,uint256),uint256)"
    )]
    pub struct GetTimelockInEpochCall {
        pub staker_address: ::ethers::core::types::Address,
        pub stake_record: StakeRecord,
        pub reward_epoch_number: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `getTokenContractAddress` function with signature `getTokenContractAddress()` and selector `0x22e45584`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "getTokenContractAddress", abi = "getTokenContractAddress()")]
    pub struct GetTokenContractAddressCall;
    ///Container type for all input parameters for the `getTokenPrice` function with signature `getTokenPrice()` and selector `0x4b94f50e`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "getTokenPrice", abi = "getTokenPrice()")]
    pub struct GetTokenPriceCall;
    ///Container type for all input parameters for the `getTokensStaked` function with signature `getTokensStaked(address,(uint256,uint256,uint256,uint256,uint256,uint256,uint256,bool,bool,address,uint256),uint256)` and selector `0x0fd78304`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "getTokensStaked",
        abi = "getTokensStaked(address,(uint256,uint256,uint256,uint256,uint256,uint256,uint256,bool,bool,address,uint256),uint256)"
    )]
    pub struct GetTokensStakedCall {
        pub staker_address: ::ethers::core::types::Address,
        pub stake_record: StakeRecord,
        pub reward_epoch_number: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `getTotalStake` function with signature `getTotalStake(address)` and selector `0x1e7ff8f6`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "getTotalStake", abi = "getTotalStake(address)")]
    pub struct GetTotalStakeCall {
        pub staker_address: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `getTotalStakeByUser` function with signature `getTotalStakeByUser(address,address)` and selector `0xd349660a`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "getTotalStakeByUser",
        abi = "getTotalStakeByUser(address,address)"
    )]
    pub struct GetTotalStakeByUserCall {
        pub staker_address: ::ethers::core::types::Address,
        pub user: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `getTrustedForwarder` function with signature `getTrustedForwarder()` and selector `0xce1b815f`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "getTrustedForwarder", abi = "getTrustedForwarder()")]
    pub struct GetTrustedForwarderCall;
    ///Container type for all input parameters for the `getUnfrozenStakeCountForUser` function with signature `getUnfrozenStakeCountForUser(address,address)` and selector `0x5a0909fa`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "getUnfrozenStakeCountForUser",
        abi = "getUnfrozenStakeCountForUser(address,address)"
    )]
    pub struct GetUnfrozenStakeCountForUserCall {
        pub user_staker_address: ::ethers::core::types::Address,
        pub operator_staker_address: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `getValidatorsDelegated` function with signature `getValidatorsDelegated(address)` and selector `0x5b2fcdcf`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "getValidatorsDelegated", abi = "getValidatorsDelegated(address)")]
    pub struct GetValidatorsDelegatedCall {
        pub user: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `getValidatorsInCurrentEpoch` function with signature `getValidatorsInCurrentEpoch(uint256)` and selector `0xeccd9e0e`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "getValidatorsInCurrentEpoch",
        abi = "getValidatorsInCurrentEpoch(uint256)"
    )]
    pub struct GetValidatorsInCurrentEpochCall {
        pub realm_id: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `getValidatorsInNextEpoch` function with signature `getValidatorsInNextEpoch(uint256)` and selector `0x84bc5324`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "getValidatorsInNextEpoch",
        abi = "getValidatorsInNextEpoch(uint256)"
    )]
    pub struct GetValidatorsInNextEpochCall {
        pub realm_id: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `getValidatorsStructs` function with signature `getValidatorsStructs(address[])` and selector `0x533d463e`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "getValidatorsStructs", abi = "getValidatorsStructs(address[])")]
    pub struct GetValidatorsStructsCall {
        pub staker_addresses: ::std::vec::Vec<::ethers::core::types::Address>,
    }
    ///Container type for all input parameters for the `getValidatorsStructsInCurrentEpoch` function with signature `getValidatorsStructsInCurrentEpoch(uint256)` and selector `0xb0dee6c6`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "getValidatorsStructsInCurrentEpoch",
        abi = "getValidatorsStructsInCurrentEpoch(uint256)"
    )]
    pub struct GetValidatorsStructsInCurrentEpochCall {
        pub realm_id: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `getValidatorsStructsInNextEpoch` function with signature `getValidatorsStructsInNextEpoch(uint256)` and selector `0x183c5ff0`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "getValidatorsStructsInNextEpoch",
        abi = "getValidatorsStructsInNextEpoch(uint256)"
    )]
    pub struct GetValidatorsStructsInNextEpochCall {
        pub realm_id: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `getVotingStatusToKickValidator` function with signature `getVotingStatusToKickValidator(uint256,uint256,address,address)` and selector `0x3e1c3693`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "getVotingStatusToKickValidator",
        abi = "getVotingStatusToKickValidator(uint256,uint256,address,address)"
    )]
    pub struct GetVotingStatusToKickValidatorCall {
        pub realm_id: ::ethers::core::types::U256,
        pub epoch_number: ::ethers::core::types::U256,
        pub validator_to_be_kicked_staker_address: ::ethers::core::types::Address,
        pub voter_staker_address: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `globalConfig` function with signature `globalConfig()` and selector `0xa7c1abe0`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "globalConfig", abi = "globalConfig()")]
    pub struct GlobalConfigCall;
    ///Container type for all input parameters for the `increaseRewardPool` function with signature `increaseRewardPool(uint256,uint256)` and selector `0x0c1ea985`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "increaseRewardPool", abi = "increaseRewardPool(uint256,uint256)")]
    pub struct IncreaseRewardPoolCall {
        pub realm_id: ::ethers::core::types::U256,
        pub amount: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `increaseStakeRecordAmount` function with signature `increaseStakeRecordAmount(address,uint256,uint256)` and selector `0x61967297`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "increaseStakeRecordAmount",
        abi = "increaseStakeRecordAmount(address,uint256,uint256)"
    )]
    pub struct IncreaseStakeRecordAmountCall {
        pub staker_address: ::ethers::core::types::Address,
        pub stake_record_id: ::ethers::core::types::U256,
        pub additional_amount: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `increaseStakeRecordTimelock` function with signature `increaseStakeRecordTimelock(address,uint256,uint256)` and selector `0xc5427758`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "increaseStakeRecordTimelock",
        abi = "increaseStakeRecordTimelock(address,uint256,uint256)"
    )]
    pub struct IncreaseStakeRecordTimelockCall {
        pub staker_address: ::ethers::core::types::Address,
        pub stake_record_id: ::ethers::core::types::U256,
        pub additional_time_lock: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `initializeRewardEpoch` function with signature `initializeRewardEpoch(address,uint256,bool)` and selector `0x9654c473`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "initializeRewardEpoch",
        abi = "initializeRewardEpoch(address,uint256,bool)"
    )]
    pub struct InitializeRewardEpochCall {
        pub staker_address: ::ethers::core::types::Address,
        pub reward_epoch_number: ::ethers::core::types::U256,
        pub is_initial: bool,
    }
    ///Container type for all input parameters for the `isActiveShadowValidator` function with signature `isActiveShadowValidator(uint256,address)` and selector `0x7e7ae34c`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "isActiveShadowValidator",
        abi = "isActiveShadowValidator(uint256,address)"
    )]
    pub struct IsActiveShadowValidatorCall {
        pub realm_id: ::ethers::core::types::U256,
        pub staker_address: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `isActiveValidator` function with signature `isActiveValidator(uint256,address)` and selector `0xff347ae8`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "isActiveValidator", abi = "isActiveValidator(uint256,address)")]
    pub struct IsActiveValidatorCall {
        pub realm_id: ::ethers::core::types::U256,
        pub staker_address: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `isActiveValidatorByNodeAddress` function with signature `isActiveValidatorByNodeAddress(uint256,address)` and selector `0x5064c127`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "isActiveValidatorByNodeAddress",
        abi = "isActiveValidatorByNodeAddress(uint256,address)"
    )]
    pub struct IsActiveValidatorByNodeAddressCall {
        pub realm_id: ::ethers::core::types::U256,
        pub account: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `isActiveValidatorByNodeAddressForNextEpoch` function with signature `isActiveValidatorByNodeAddressForNextEpoch(uint256,address)` and selector `0xeb8f2f27`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "isActiveValidatorByNodeAddressForNextEpoch",
        abi = "isActiveValidatorByNodeAddressForNextEpoch(uint256,address)"
    )]
    pub struct IsActiveValidatorByNodeAddressForNextEpochCall {
        pub realm_id: ::ethers::core::types::U256,
        pub node_address: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `isActiveValidatorForNextEpoch` function with signature `isActiveValidatorForNextEpoch(uint256,address)` and selector `0x26fc6f9b`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "isActiveValidatorForNextEpoch",
        abi = "isActiveValidatorForNextEpoch(uint256,address)"
    )]
    pub struct IsActiveValidatorForNextEpochCall {
        pub realm_id: ::ethers::core::types::U256,
        pub staker_address: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `isApprovedForAll` function with signature `isApprovedForAll(address,address)` and selector `0xe985e9c5`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "isApprovedForAll", abi = "isApprovedForAll(address,address)")]
    pub struct IsApprovedForAllCall {
        pub owner: ::ethers::core::types::Address,
        pub operator: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `isReadyForNextEpoch` function with signature `isReadyForNextEpoch(uint256)` and selector `0x7fecc451`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "isReadyForNextEpoch", abi = "isReadyForNextEpoch(uint256)")]
    pub struct IsReadyForNextEpochCall {
        pub realm_id: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `isRecentValidator` function with signature `isRecentValidator(address)` and selector `0x3c2ef732`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "isRecentValidator", abi = "isRecentValidator(address)")]
    pub struct IsRecentValidatorCall {
        pub node_address: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `isRecentValidator` function with signature `isRecentValidator(uint256,address)` and selector `0xc974c355`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "isRecentValidator", abi = "isRecentValidator(uint256,address)")]
    pub struct IsRecentValidatorWithRealmIdCall {
        pub realm_id: ::ethers::core::types::U256,
        pub staker_addresses: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `isValidatorBanned` function with signature `isValidatorBanned(address)` and selector `0xa92252ae`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "isValidatorBanned", abi = "isValidatorBanned(address)")]
    pub struct IsValidatorBannedCall {
        pub validator: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `isValidatorInCurrentEpoch` function with signature `isValidatorInCurrentEpoch(address)` and selector `0xdf8a171f`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "isValidatorInCurrentEpoch",
        abi = "isValidatorInCurrentEpoch(address)"
    )]
    pub struct IsValidatorInCurrentEpochCall {
        pub staker_address: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `isValidatorInCurrentOrNextEpoch` function with signature `isValidatorInCurrentOrNextEpoch(address)` and selector `0x81b9beb7`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "isValidatorInCurrentOrNextEpoch",
        abi = "isValidatorInCurrentOrNextEpoch(address)"
    )]
    pub struct IsValidatorInCurrentOrNextEpochCall {
        pub staker_address: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `isValidatorInNextEpoch` function with signature `isValidatorInNextEpoch(address)` and selector `0xad0466a6`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "isValidatorInNextEpoch", abi = "isValidatorInNextEpoch(address)")]
    pub struct IsValidatorInNextEpochCall {
        pub staker_address: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `keySets` function with signature `keySets()` and selector `0xdce90405`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "keySets", abi = "keySets()")]
    pub struct KeySetsCall;
    ///Container type for all input parameters for the `kickPenaltyPercentByReason` function with signature `kickPenaltyPercentByReason(uint256)` and selector `0x3e685266`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "kickPenaltyPercentByReason",
        abi = "kickPenaltyPercentByReason(uint256)"
    )]
    pub struct KickPenaltyPercentByReasonCall {
        pub reason: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `kickValidatorInNextEpoch` function with signature `kickValidatorInNextEpoch(address,uint256,bytes)` and selector `0x865419e9`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "kickValidatorInNextEpoch",
        abi = "kickValidatorInNextEpoch(address,uint256,bytes)"
    )]
    pub struct KickValidatorInNextEpochCall {
        pub validator_to_kick_staker_address: ::ethers::core::types::Address,
        pub reason: ::ethers::core::types::U256,
        pub data: ::ethers::core::types::Bytes,
    }
    ///Container type for all input parameters for the `litActionsConfig` function with signature `litActionsConfig(uint256)` and selector `0xe3dfd1f5`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "litActionsConfig", abi = "litActionsConfig(uint256)")]
    pub struct LitActionsConfigCall {
        pub realm_id: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `lockValidatorsForNextEpoch` function with signature `lockValidatorsForNextEpoch(uint256)` and selector `0x45c1b1fb`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "lockValidatorsForNextEpoch",
        abi = "lockValidatorsForNextEpoch(uint256)"
    )]
    pub struct LockValidatorsForNextEpochCall {
        pub realm_id: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `maxStake` function with signature `maxStake()` and selector `0xea1b28e0`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "maxStake", abi = "maxStake()")]
    pub struct MaxStakeCall;
    ///Container type for all input parameters for the `maxTimeLock` function with signature `maxTimeLock()` and selector `0xe1cf73b9`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "maxTimeLock", abi = "maxTimeLock()")]
    pub struct MaxTimeLockCall;
    ///Container type for all input parameters for the `migrateStakeRecord` function with signature `migrateStakeRecord(address,uint256,address)` and selector `0x4048b256`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "migrateStakeRecord",
        abi = "migrateStakeRecord(address,uint256,address)"
    )]
    pub struct MigrateStakeRecordCall {
        pub operator_address_to_migrate_from: ::ethers::core::types::Address,
        pub stake_record_id: ::ethers::core::types::U256,
        pub operator_address_to_migrate_to: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `minSelfStake` function with signature `minSelfStake()` and selector `0xc5f530af`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "minSelfStake", abi = "minSelfStake()")]
    pub struct MinSelfStakeCall;
    ///Container type for all input parameters for the `minStake` function with signature `minStake()` and selector `0x375b3c0a`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "minStake", abi = "minStake()")]
    pub struct MinStakeCall;
    ///Container type for all input parameters for the `minTimeLock` function with signature `minTimeLock()` and selector `0xd00a818f`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "minTimeLock", abi = "minTimeLock()")]
    pub struct MinTimeLockCall;
    ///Container type for all input parameters for the `nextValidatorCountForConsensus` function with signature `nextValidatorCountForConsensus(uint256)` and selector `0xa8b89564`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "nextValidatorCountForConsensus",
        abi = "nextValidatorCountForConsensus(uint256)"
    )]
    pub struct NextValidatorCountForConsensusCall {
        pub realm_id: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `nodeAddressToStakerAddress` function with signature `nodeAddressToStakerAddress(address)` and selector `0x5081f66f`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "nodeAddressToStakerAddress",
        abi = "nodeAddressToStakerAddress(address)"
    )]
    pub struct NodeAddressToStakerAddressCall {
        pub node_address: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `nodeAddressToStakerAddressAcrossRealms` function with signature `nodeAddressToStakerAddressAcrossRealms(address)` and selector `0x86b01dd6`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "nodeAddressToStakerAddressAcrossRealms",
        abi = "nodeAddressToStakerAddressAcrossRealms(address)"
    )]
    pub struct NodeAddressToStakerAddressAcrossRealmsCall {
        pub node_address: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `numRealms` function with signature `numRealms()` and selector `0xfc14e3b9`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "numRealms", abi = "numRealms()")]
    pub struct NumRealmsCall;
    ///Container type for all input parameters for the `operatorAddressToStakerAddress` function with signature `operatorAddressToStakerAddress(address)` and selector `0xab8ccfbe`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "operatorAddressToStakerAddress",
        abi = "operatorAddressToStakerAddress(address)"
    )]
    pub struct OperatorAddressToStakerAddressCall {
        pub operator_address: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `owner` function with signature `owner()` and selector `0x8da5cb5b`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "owner", abi = "owner()")]
    pub struct OwnerCall;
    ///Container type for all input parameters for the `ownerOf` function with signature `ownerOf(uint256)` and selector `0x6352211e`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "ownerOf", abi = "ownerOf(uint256)")]
    pub struct OwnerOfCall {
        pub token_id: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `ownershipChange` function with signature `ownershipChange(uint256)` and selector `0x23857d51`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "ownershipChange", abi = "ownershipChange(uint256)")]
    pub struct OwnershipChangeCall {
        pub token_id: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `permittedRealmsForValidator` function with signature `permittedRealmsForValidator(address)` and selector `0xe718ff4c`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "permittedRealmsForValidator",
        abi = "permittedRealmsForValidator(address)"
    )]
    pub struct PermittedRealmsForValidatorCall {
        pub validator: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `permittedValidators` function with signature `permittedValidators(uint256)` and selector `0x58488c31`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "permittedValidators", abi = "permittedValidators(uint256)")]
    pub struct PermittedValidatorsCall {
        pub realm_id: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `pow` function with signature `pow(uint256,uint256)` and selector `0x2e4c697f`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "pow", abi = "pow(uint256,uint256)")]
    pub struct PowCall {
        pub base: ::ethers::core::types::U256,
        pub exponent: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `readyForNextEpoch` function with signature `readyForNextEpoch(uint256,address)` and selector `0xf2c5b908`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "readyForNextEpoch", abi = "readyForNextEpoch(uint256,address)")]
    pub struct ReadyForNextEpochCall {
        pub realm_id: ::ethers::core::types::U256,
        pub staker_address: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `realmConfig` function with signature `realmConfig(uint256)` and selector `0xe56cfb79`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "realmConfig", abi = "realmConfig(uint256)")]
    pub struct RealmConfigCall {
        pub realm_id: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `registerAttestedWallet` function with signature `registerAttestedWallet(address,address,bytes,uint256,uint256)` and selector `0x4aea5542`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "registerAttestedWallet",
        abi = "registerAttestedWallet(address,address,bytes,uint256,uint256)"
    )]
    pub struct RegisterAttestedWalletCall {
        pub staker_address: ::ethers::core::types::Address,
        pub attested_address: ::ethers::core::types::Address,
        pub attested_pub_key: ::ethers::core::types::Bytes,
        pub sender_pub_key: ::ethers::core::types::U256,
        pub receiver_pub_key: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `removeRealm` function with signature `removeRealm(uint256)` and selector `0xd2baca55`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "removeRealm", abi = "removeRealm(uint256)")]
    pub struct RemoveRealmCall {
        pub realm_id: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `requestToJoin` function with signature `requestToJoin(uint256)` and selector `0x84022767`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "requestToJoin", abi = "requestToJoin(uint256)")]
    pub struct RequestToJoinCall {
        pub realm_id: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `requestToJoinAsAdmin` function with signature `requestToJoinAsAdmin(uint256,address)` and selector `0xca005066`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "requestToJoinAsAdmin",
        abi = "requestToJoinAsAdmin(uint256,address)"
    )]
    pub struct RequestToJoinAsAdminCall {
        pub realm_id: ::ethers::core::types::U256,
        pub staker_address: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `requestToJoinAsForShadowSplicing` function with signature `requestToJoinAsForShadowSplicing(uint256,address)` and selector `0x9a1dc1b5`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "requestToJoinAsForShadowSplicing",
        abi = "requestToJoinAsForShadowSplicing(uint256,address)"
    )]
    pub struct RequestToJoinAsForShadowSplicingCall {
        pub realm_id: ::ethers::core::types::U256,
        pub staker_address: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `requestToJoinAsNode` function with signature `requestToJoinAsNode(uint256,address)` and selector `0x5b7204fa`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "requestToJoinAsNode",
        abi = "requestToJoinAsNode(uint256,address)"
    )]
    pub struct RequestToJoinAsNodeCall {
        pub realm_id: ::ethers::core::types::U256,
        pub staker_address: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `requestToLeave` function with signature `requestToLeave()` and selector `0xac2f8afe`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "requestToLeave", abi = "requestToLeave()")]
    pub struct RequestToLeaveCall;
    ///Container type for all input parameters for the `requestToLeaveAsNode` function with signature `requestToLeaveAsNode(uint256)` and selector `0xc6f04cbb`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "requestToLeaveAsNode", abi = "requestToLeaveAsNode(uint256)")]
    pub struct RequestToLeaveAsNodeCall {
        pub realm_id: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `safeTransferFrom` function with signature `safeTransferFrom(address,address,uint256)` and selector `0x42842e0e`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "safeTransferFrom",
        abi = "safeTransferFrom(address,address,uint256)"
    )]
    pub struct SafeTransferFromCall {
        pub from: ::ethers::core::types::Address,
        pub to: ::ethers::core::types::Address,
        pub token_id: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `safeTransferFrom` function with signature `safeTransferFrom(address,address,uint256,bytes)` and selector `0xb88d4fde`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "safeTransferFrom",
        abi = "safeTransferFrom(address,address,uint256,bytes)"
    )]
    pub struct SafeTransferFromWithFromAndToAndDataCall {
        pub from: ::ethers::core::types::Address,
        pub to: ::ethers::core::types::Address,
        pub token_id: ::ethers::core::types::U256,
        pub data: ::ethers::core::types::Bytes,
    }
    ///Container type for all input parameters for the `selfStakeBalanceOf` function with signature `selfStakeBalanceOf(address)` and selector `0xeddf837a`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "selfStakeBalanceOf", abi = "selfStakeBalanceOf(address)")]
    pub struct SelfStakeBalanceOfCall {
        pub staker_address: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `setApprovalForAll` function with signature `setApprovalForAll(address,bool)` and selector `0xa22cb465`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "setApprovalForAll", abi = "setApprovalForAll(address,bool)")]
    pub struct SetApprovalForAllCall {
        pub operator: ::ethers::core::types::Address,
        pub approved: bool,
    }
    ///Container type for all input parameters for the `setComplaintConfig` function with signature `setComplaintConfig(uint256,(uint256,uint256,uint256,uint256))` and selector `0x440e8d22`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "setComplaintConfig",
        abi = "setComplaintConfig(uint256,(uint256,uint256,uint256,uint256))"
    )]
    pub struct SetComplaintConfigCall {
        pub reason: ::ethers::core::types::U256,
        pub config: ComplaintConfig,
    }
    ///Container type for all input parameters for the `setConfig` function with signature `setConfig((uint256,uint256[],uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,bool,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256))` and selector `0x077b0d40`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
    )]
    #[ethcall(
        name = "setConfig",
        abi = "setConfig((uint256,uint256[],uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,bool,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256))"
    )]
    pub struct SetConfigCall {
        pub new_config: GlobalConfig,
    }
    ///Container type for all input parameters for the `setContractResolver` function with signature `setContractResolver(address)` and selector `0xf95d71b1`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "setContractResolver", abi = "setContractResolver(address)")]
    pub struct SetContractResolverCall {
        pub new_resolver_address: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `setDemeritRejoinThreshold` function with signature `setDemeritRejoinThreshold(uint256)` and selector `0x2531431b`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "setDemeritRejoinThreshold",
        abi = "setDemeritRejoinThreshold(uint256)"
    )]
    pub struct SetDemeritRejoinThresholdCall {
        pub new_threshold: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `setDevopsAdmin` function with signature `setDevopsAdmin(address)` and selector `0xcf7d1e87`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "setDevopsAdmin", abi = "setDevopsAdmin(address)")]
    pub struct SetDevopsAdminCall {
        pub new_devops_admin: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `setEpochEndTime` function with signature `setEpochEndTime(uint256,uint256)` and selector `0x5a7e6c22`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "setEpochEndTime", abi = "setEpochEndTime(uint256,uint256)")]
    pub struct SetEpochEndTimeCall {
        pub realm_id: ::ethers::core::types::U256,
        pub new_epoch_end_time: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `setEpochLength` function with signature `setEpochLength(uint256,uint256)` and selector `0xeb57bafb`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "setEpochLength", abi = "setEpochLength(uint256,uint256)")]
    pub struct SetEpochLengthCall {
        pub realm_id: ::ethers::core::types::U256,
        pub new_epoch_length: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `setEpochState` function with signature `setEpochState(uint256,uint8)` and selector `0x7a802454`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "setEpochState", abi = "setEpochState(uint256,uint8)")]
    pub struct SetEpochStateCall {
        pub realm_id: ::ethers::core::types::U256,
        pub new_state: u8,
    }
    ///Container type for all input parameters for the `setEpochTimeout` function with signature `setEpochTimeout(uint256,uint256)` and selector `0x0c9d5399`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "setEpochTimeout", abi = "setEpochTimeout(uint256,uint256)")]
    pub struct SetEpochTimeoutCall {
        pub realm_id: ::ethers::core::types::U256,
        pub new_epoch_timeout: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `setIpPortNodeAddress` function with signature `setIpPortNodeAddress(uint32,uint128,uint32,address)` and selector `0x2c80b549`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "setIpPortNodeAddress",
        abi = "setIpPortNodeAddress(uint32,uint128,uint32,address)"
    )]
    pub struct SetIpPortNodeAddressCall {
        pub ip: u32,
        pub ipv_6: u128,
        pub port: u32,
        pub operator_address: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `setKeySet` function with signature `setKeySet((uint32,uint32,bool,string,string,uint256[],uint256[],uint256[],address[]))` and selector `0x74d0be87`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "setKeySet",
        abi = "setKeySet((uint32,uint32,bool,string,string,uint256[],uint256[],uint256[],address[]))"
    )]
    pub struct SetKeySetCall {
        pub update: KeySetConfig,
    }
    ///Container type for all input parameters for the `setLitActionConfig` function with signature `setLitActionConfig(uint256,(uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,bool))` and selector `0xe7d1f9a1`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "setLitActionConfig",
        abi = "setLitActionConfig(uint256,(uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,bool))"
    )]
    pub struct SetLitActionConfigCall {
        pub realm_id: ::ethers::core::types::U256,
        pub new_config: LitActionConfig,
    }
    ///Container type for all input parameters for the `setMaxVersion` function with signature `setMaxVersion(uint256,(uint256,uint256,uint256))` and selector `0xb34b251d`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "setMaxVersion",
        abi = "setMaxVersion(uint256,(uint256,uint256,uint256))"
    )]
    pub struct SetMaxVersionCall {
        pub realm_id: ::ethers::core::types::U256,
        pub version: Version,
    }
    ///Container type for all input parameters for the `setMinVersion` function with signature `setMinVersion(uint256,(uint256,uint256,uint256))` and selector `0x0c26c77b`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "setMinVersion",
        abi = "setMinVersion(uint256,(uint256,uint256,uint256))"
    )]
    pub struct SetMinVersionCall {
        pub realm_id: ::ethers::core::types::U256,
        pub version: Version,
    }
    ///Container type for all input parameters for the `setPendingRejoinTimeout` function with signature `setPendingRejoinTimeout(uint256)` and selector `0x2b156e7d`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "setPendingRejoinTimeout",
        abi = "setPendingRejoinTimeout(uint256)"
    )]
    pub struct SetPendingRejoinTimeoutCall {
        pub new_timeout: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `setPermittedValidators` function with signature `setPermittedValidators(uint256,address[])` and selector `0x8354ae59`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "setPermittedValidators",
        abi = "setPermittedValidators(uint256,address[])"
    )]
    pub struct SetPermittedValidatorsCall {
        pub realm_id: ::ethers::core::types::U256,
        pub validators_to_set: ::std::vec::Vec<::ethers::core::types::Address>,
    }
    ///Container type for all input parameters for the `setPermittedValidatorsOn` function with signature `setPermittedValidatorsOn(uint256,bool)` and selector `0x74a22c51`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "setPermittedValidatorsOn",
        abi = "setPermittedValidatorsOn(uint256,bool)"
    )]
    pub struct SetPermittedValidatorsOnCall {
        pub realm_id: ::ethers::core::types::U256,
        pub permitted_validators_on: bool,
    }
    ///Container type for all input parameters for the `setRealmConfig` function with signature `setRealmConfig(uint256,(uint256,uint256,uint256,uint256,uint256,bool,uint256,bool))` and selector `0x7d35690f`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "setRealmConfig",
        abi = "setRealmConfig(uint256,(uint256,uint256,uint256,uint256,uint256,bool,uint256,bool))"
    )]
    pub struct SetRealmConfigCall {
        pub realm_id: ::ethers::core::types::U256,
        pub new_config: RealmConfig,
    }
    ///Container type for all input parameters for the `setTokenTotalSupplyStandIn` function with signature `setTokenTotalSupplyStandIn(uint256)` and selector `0xe941a733`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "setTokenTotalSupplyStandIn",
        abi = "setTokenTotalSupplyStandIn(uint256)"
    )]
    pub struct SetTokenTotalSupplyStandInCall {
        pub new_total_supply: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `setTrustedForwarder` function with signature `setTrustedForwarder(address)` and selector `0xda742228`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "setTrustedForwarder", abi = "setTrustedForwarder(address)")]
    pub struct SetTrustedForwarderCall {
        pub forwarder: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `setUp` function with signature `setUp()` and selector `0x0a9254e4`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "setUp", abi = "setUp()")]
    pub struct SetUpCall;
    ///Container type for all input parameters for the `setValidatorCommissionRate` function with signature `setValidatorCommissionRate(uint256)` and selector `0x7149ab58`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "setValidatorCommissionRate",
        abi = "setValidatorCommissionRate(uint256)"
    )]
    pub struct SetValidatorCommissionRateCall {
        pub rate: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `shouldKickValidator` function with signature `shouldKickValidator(uint256,address)` and selector `0x1e966b97`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "shouldKickValidator",
        abi = "shouldKickValidator(uint256,address)"
    )]
    pub struct ShouldKickValidatorCall {
        pub realm_id: ::ethers::core::types::U256,
        pub staker_address: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `signalReadyForNextEpoch` function with signature `signalReadyForNextEpoch(uint256,uint256)` and selector `0x9a25bdee`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "signalReadyForNextEpoch",
        abi = "signalReadyForNextEpoch(uint256,uint256)"
    )]
    pub struct SignalReadyForNextEpochCall {
        pub realm_id: ::ethers::core::types::U256,
        pub epoch_number: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `splitStakeRecord` function with signature `splitStakeRecord(address,uint256,uint256)` and selector `0xf69ccb92`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "splitStakeRecord",
        abi = "splitStakeRecord(address,uint256,uint256)"
    )]
    pub struct SplitStakeRecordCall {
        pub staker_address: ::ethers::core::types::Address,
        pub stake_record_id: ::ethers::core::types::U256,
        pub ratio: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `stake` function with signature `stake(uint256,uint256,address)` and selector `0x7628a37d`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "stake", abi = "stake(uint256,uint256,address)")]
    pub struct StakeCall {
        pub amount: ::ethers::core::types::U256,
        pub time_lock: ::ethers::core::types::U256,
        pub operator_staker_address: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `stakerToValidatorsTheyStakedTo` function with signature `stakerToValidatorsTheyStakedTo(address)` and selector `0x6817d36e`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "stakerToValidatorsTheyStakedTo",
        abi = "stakerToValidatorsTheyStakedTo(address)"
    )]
    pub struct StakerToValidatorsTheyStakedToCall {
        pub staker: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `state` function with signature `state(uint256)` and selector `0x3e4f49e6`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "state", abi = "state(uint256)")]
    pub struct StateCall {
        pub realm_id: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `supportsInterface` function with signature `supportsInterface(bytes4)` and selector `0x01ffc9a7`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "supportsInterface", abi = "supportsInterface(bytes4)")]
    pub struct SupportsInterfaceCall {
        pub interface_id: [u8; 4],
    }
    ///Container type for all input parameters for the `targetArtifactSelectors` function with signature `targetArtifactSelectors()` and selector `0x66d9a9a0`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "targetArtifactSelectors", abi = "targetArtifactSelectors()")]
    pub struct TargetArtifactSelectorsCall;
    ///Container type for all input parameters for the `targetArtifacts` function with signature `targetArtifacts()` and selector `0x85226c81`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "targetArtifacts", abi = "targetArtifacts()")]
    pub struct TargetArtifactsCall;
    ///Container type for all input parameters for the `targetContracts` function with signature `targetContracts()` and selector `0x3f7286f4`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "targetContracts", abi = "targetContracts()")]
    pub struct TargetContractsCall;
    ///Container type for all input parameters for the `targetInterfaces` function with signature `targetInterfaces()` and selector `0x2ade3880`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "targetInterfaces", abi = "targetInterfaces()")]
    pub struct TargetInterfacesCall;
    ///Container type for all input parameters for the `targetSelectors` function with signature `targetSelectors()` and selector `0x916a17c6`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "targetSelectors", abi = "targetSelectors()")]
    pub struct TargetSelectorsCall;
    ///Container type for all input parameters for the `targetSenders` function with signature `targetSenders()` and selector `0x3e5e3c23`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "targetSenders", abi = "targetSenders()")]
    pub struct TargetSendersCall;
    ///Container type for all input parameters for the `test_Stake` function with signature `test_Stake()` and selector `0xdbab1cd7`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "test_Stake", abi = "test_Stake()")]
    pub struct TestStakeCall;
    ///Container type for all input parameters for the `test_StakeAndTransfer` function with signature `test_StakeAndTransfer(bool)` and selector `0xaaedca62`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "test_StakeAndTransfer", abi = "test_StakeAndTransfer(bool)")]
    pub struct TestStakeAndTransferCall {
        pub is_safe_transfer: bool,
    }
    ///Container type for all input parameters for the `test_StakeAndTransfer_ClaimRewards` function with signature `test_StakeAndTransfer_ClaimRewards(bool)` and selector `0x96007d44`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "test_StakeAndTransfer_ClaimRewards",
        abi = "test_StakeAndTransfer_ClaimRewards(bool)"
    )]
    pub struct TestStakeAndTransferClaimRewardsCall {
        pub is_safe_transfer: bool,
    }
    ///Container type for all input parameters for the `test_StakeAndTransfer_ReceiverMutatesStakeRecord` function with signature `test_StakeAndTransfer_ReceiverMutatesStakeRecord(bool,uint256)` and selector `0x6239b4f7`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "test_StakeAndTransfer_ReceiverMutatesStakeRecord",
        abi = "test_StakeAndTransfer_ReceiverMutatesStakeRecord(bool,uint256)"
    )]
    pub struct TestStakeAndTransferReceiverMutatesStakeRecordCall {
        pub is_safe_transfer: bool,
        pub operation: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `test_StakeAndTransfer_RevertNotOwner` function with signature `test_StakeAndTransfer_RevertNotOwner(bool)` and selector `0x5ad8b9a9`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "test_StakeAndTransfer_RevertNotOwner",
        abi = "test_StakeAndTransfer_RevertNotOwner(bool)"
    )]
    pub struct TestStakeAndTransferRevertNotOwnerCall {
        pub is_safe_transfer: bool,
    }
    ///Container type for all input parameters for the `test_StakeAndTransfer_TokenOwnerByIndex` function with signature `test_StakeAndTransfer_TokenOwnerByIndex(bool)` and selector `0xa7319b44`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "test_StakeAndTransfer_TokenOwnerByIndex",
        abi = "test_StakeAndTransfer_TokenOwnerByIndex(bool)"
    )]
    pub struct TestStakeAndTransferTokenOwnerByIndexCall {
        pub is_safe_transfer: bool,
    }
    ///Container type for all input parameters for the `test_StakeAndTransfer_Withdraw` function with signature `test_StakeAndTransfer_Withdraw(bool,bool)` and selector `0x86ef1d4d`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "test_StakeAndTransfer_Withdraw",
        abi = "test_StakeAndTransfer_Withdraw(bool,bool)"
    )]
    pub struct TestStakeAndTransferWithdrawCall {
        pub is_safe_transfer: bool,
        pub is_unfreeze_before_transfer: bool,
    }
    ///Container type for all input parameters for the `test_StakeApproveAndTransfer` function with signature `test_StakeApproveAndTransfer(bool)` and selector `0x22e7a7ac`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "test_StakeApproveAndTransfer",
        abi = "test_StakeApproveAndTransfer(bool)"
    )]
    pub struct TestStakeApproveAndTransferCall {
        pub is_safe_transfer: bool,
    }
    ///Container type for all input parameters for the `test_StakeApproveForAllAndTransfer` function with signature `test_StakeApproveForAllAndTransfer(bool)` and selector `0x78854e37`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "test_StakeApproveForAllAndTransfer",
        abi = "test_StakeApproveForAllAndTransfer(bool)"
    )]
    pub struct TestStakeApproveForAllAndTransferCall {
        pub is_safe_transfer: bool,
    }
    ///Container type for all input parameters for the `test_StakeMax_TransferShouldFail` function with signature `test_StakeMax_TransferShouldFail(bool)` and selector `0xb29fabc7`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "test_StakeMax_TransferShouldFail",
        abi = "test_StakeMax_TransferShouldFail(bool)"
    )]
    pub struct TestStakeMaxTransferShouldFailCall {
        pub is_safe_transfer: bool,
    }
    ///Container type for all input parameters for the `test_Stake_MutateStakeRecord` function with signature `test_Stake_MutateStakeRecord(uint256)` and selector `0xa90bb850`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "test_Stake_MutateStakeRecord",
        abi = "test_Stake_MutateStakeRecord(uint256)"
    )]
    pub struct TestStakeMutateStakeRecordCall {
        pub operation: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `tokenOfOwnerByIndex` function with signature `tokenOfOwnerByIndex(address,uint256)` and selector `0x2f745c59`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "tokenOfOwnerByIndex",
        abi = "tokenOfOwnerByIndex(address,uint256)"
    )]
    pub struct TokenOfOwnerByIndexCall {
        pub owner: ::ethers::core::types::Address,
        pub index: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `tokenToStakeRecord` function with signature `tokenToStakeRecord(uint256)` and selector `0xf0e2d9b5`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "tokenToStakeRecord", abi = "tokenToStakeRecord(uint256)")]
    pub struct TokenToStakeRecordCall {
        pub token_id: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `totalSupply` function with signature `totalSupply()` and selector `0x18160ddd`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "totalSupply", abi = "totalSupply()")]
    pub struct TotalSupplyCall;
    ///Container type for all input parameters for the `transferFrom` function with signature `transferFrom(address,address,uint256)` and selector `0x23b872dd`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "transferFrom", abi = "transferFrom(address,address,uint256)")]
    pub struct TransferFromCall {
        pub from: ::ethers::core::types::Address,
        pub to: ::ethers::core::types::Address,
        pub token_id: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `transferOwnership` function with signature `transferOwnership(address)` and selector `0xf2fde38b`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "transferOwnership", abi = "transferOwnership(address)")]
    pub struct TransferOwnershipCall {
        pub new_owner: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `unfreezeStake` function with signature `unfreezeStake(address,uint256)` and selector `0xb626a4b5`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "unfreezeStake", abi = "unfreezeStake(address,uint256)")]
    pub struct UnfreezeStakeCall {
        pub operator_staker_address: ::ethers::core::types::Address,
        pub stake_id: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `validatorSelfStakeWillExpire` function with signature `validatorSelfStakeWillExpire(uint256,address,bool)` and selector `0xbb8b437f`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "validatorSelfStakeWillExpire",
        abi = "validatorSelfStakeWillExpire(uint256,address,bool)"
    )]
    pub struct ValidatorSelfStakeWillExpireCall {
        pub realm_id: ::ethers::core::types::U256,
        pub staker_address: ::ethers::core::types::Address,
        pub staker_in_current_validator_set: bool,
    }
    ///Container type for all input parameters for the `validator_by_staker_address` function with signature `validator_by_staker_address(address)` and selector `0x794de9b5`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "validator_by_staker_address",
        abi = "validator_by_staker_address(address)"
    )]
    pub struct ValidatorByStakerAddressCall {
        pub staker_address: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `validators` function with signature `validators(address)` and selector `0xfa52c7d8`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "validators", abi = "validators(address)")]
    pub struct ValidatorsCall {
        pub staker_address: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `verifyKeySetCounts` function with signature `verifyKeySetCounts(string,(bytes,uint256)[])` and selector `0xf14baa40`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(
        name = "verifyKeySetCounts",
        abi = "verifyKeySetCounts(string,(bytes,uint256)[])"
    )]
    pub struct VerifyKeySetCountsCall {
        pub identifier: ::std::string::String,
        pub new_root_keys: ::std::vec::Vec<RootKey>,
    }
    ///Container type for all input parameters for the `withdraw` function with signature `withdraw(address,uint256)` and selector `0xf3fef3a3`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    #[ethcall(name = "withdraw", abi = "withdraw(address,uint256)")]
    pub struct WithdrawCall {
        pub operator_staker_address: ::ethers::core::types::Address,
        pub stake_record_id: ::ethers::core::types::U256,
    }
    ///Container type for all of the contract's call
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        serde::Serialize,
        serde::Deserialize,
    )]
    pub enum StakingCalls {
        IsTest(IsTestCall),
        GenerateAddresses(GenerateAddressesCall),
        GenerateAddressesWithOffset(GenerateAddressesWithOffsetCall),
        GeneratePubKeys(GeneratePubKeysCall),
        GenerateUint256S(GenerateUint256SCall),
        GenerateUint256SWithOffset(GenerateUint256SWithOffsetCall),
        GenerateValidators(GenerateValidatorsCall),
        AddRealm(AddRealmCall),
        AdminKickValidatorInNextEpoch(AdminKickValidatorInNextEpochCall),
        AdminRejoinValidator(AdminRejoinValidatorCall),
        AdminSetValidatorRegisterAttestedWalletDisabled(
            AdminSetValidatorRegisterAttestedWalletDisabledCall,
        ),
        AdminSetValidatorsInCurrentEpoch(AdminSetValidatorsInCurrentEpochCall),
        AdminSetValidatorsInNextEpoch(AdminSetValidatorsInNextEpochCall),
        AdminSetupShadowSplicing(AdminSetupShadowSplicingCall),
        AdminSlashValidator(AdminSlashValidatorCall),
        AdminStakeForUser(AdminStakeForUserCall),
        AdminUnfreezeForUser(AdminUnfreezeForUserCall),
        AdvanceEpoch(AdvanceEpochCall),
        Approve(ApproveCall),
        BalanceOf(BalanceOfCall),
        CalculateRewardsPerDay(CalculateRewardsPerDayCall),
        CalculateStakeWeight(CalculateStakeWeightCall),
        CheckActiveOrUnlockedOrPausedState(CheckActiveOrUnlockedOrPausedStateCall),
        CheckStakingAmounts(CheckStakingAmountsCall),
        CheckVersion(CheckVersionCall),
        ClaimFixedCostRewards(ClaimFixedCostRewardsCall),
        ClaimStakeRewards(ClaimStakeRewardsCall),
        ClaimValidatorCommission(ClaimValidatorCommissionCall),
        ComplaintConfig(ComplaintConfigCall),
        ContractResolver(ContractResolverCall),
        CountOfCurrentValidatorsReadyForNextEpoch(
            CountOfCurrentValidatorsReadyForNextEpochCall,
        ),
        CountOfNextValidatorsReadyForNextEpoch(
            CountOfNextValidatorsReadyForNextEpochCall,
        ),
        CurrentValidatorCountForConsensus(CurrentValidatorCountForConsensusCall),
        DecreaseRewardPool(DecreaseRewardPoolCall),
        DeleteKeySet(DeleteKeySetCall),
        DiamondCut(DiamondCutCall),
        EmitClearOfflinePhaseData(EmitClearOfflinePhaseDataCall),
        EmitCountOfflinePhaseData(EmitCountOfflinePhaseDataCall),
        Epoch(EpochCall),
        ExcludeArtifacts(ExcludeArtifactsCall),
        ExcludeContracts(ExcludeContractsCall),
        ExcludeSelectors(ExcludeSelectorsCall),
        ExcludeSenders(ExcludeSendersCall),
        Exit(ExitCall),
        FacetAddress(FacetAddressCall),
        FacetAddresses(FacetAddressesCall),
        FacetFunctionSelectors(FacetFunctionSelectorsCall),
        Facets(FacetsCall),
        Failed(FailedCall),
        GetActiveUnkickedValidatorCount(GetActiveUnkickedValidatorCountCall),
        GetActiveUnkickedValidatorStructs(GetActiveUnkickedValidatorStructsCall),
        GetActiveUnkickedValidatorStructsAndCounts(
            GetActiveUnkickedValidatorStructsAndCountsCall,
        ),
        GetActiveUnkickedValidators(GetActiveUnkickedValidatorsCall),
        GetAllReserveValidators(GetAllReserveValidatorsCall),
        GetAllUnkickedValidators(GetAllUnkickedValidatorsCall),
        GetAllValidators(GetAllValidatorsCall),
        GetApproved(GetApprovedCall),
        GetAttestedPubKey(GetAttestedPubKeyCall),
        GetCurrentRealmIdForStakerAddress(GetCurrentRealmIdForStakerAddressCall),
        GetDelegatedStakersWithUnfreezingStakes(
            GetDelegatedStakersWithUnfreezingStakesCall,
        ),
        GetDelegatedStakersWithUnfreezingStakesCount(
            GetDelegatedStakersWithUnfreezingStakesCountCall,
        ),
        GetEmptyStakeRecordSlots(GetEmptyStakeRecordSlotsCall),
        GetKeySet(GetKeySetCall),
        GetKeyTypes(GetKeyTypesCall),
        GetKickedValidators(GetKickedValidatorsCall),
        GetLastStakeRecord(GetLastStakeRecordCall),
        GetLitCirc(GetLitCircCall),
        GetLowestRewardEpochNumber(GetLowestRewardEpochNumberCall),
        GetMaxVersion(GetMaxVersionCall),
        GetMaxVersionString(GetMaxVersionStringCall),
        GetMaximumStake(GetMaximumStakeCall),
        GetMinVersion(GetMinVersionCall),
        GetMinVersionString(GetMinVersionStringCall),
        GetMinimumSelfStake(GetMinimumSelfStakeCall),
        GetMinimumStake(GetMinimumStakeCall),
        GetMostRecentStakeRecord(GetMostRecentStakeRecordCall),
        GetNodeAttestedPubKeyMappings(GetNodeAttestedPubKeyMappingsCall),
        GetNodeDemerits(GetNodeDemeritsCall),
        GetNodeStakerAddressMappings(GetNodeStakerAddressMappingsCall),
        GetNonShadowValidators(GetNonShadowValidatorsCall),
        GetNonShadowValidatorsInCurrentEpochLength(
            GetNonShadowValidatorsInCurrentEpochLengthCall,
        ),
        GetRealmIdForStakerAddress(GetRealmIdForStakerAddressCall),
        GetRewardEpoch(GetRewardEpochCall),
        GetRewardEpochGlobalStats(GetRewardEpochGlobalStatsCall),
        GetRewardEpochNumber(GetRewardEpochNumberCall),
        GetRewardEpochView(GetRewardEpochViewCall),
        GetSelfStakeRecordCount(GetSelfStakeRecordCountCall),
        GetShadowRealmIdForStakerAddress(GetShadowRealmIdForStakerAddressCall),
        GetShadowValidators(GetShadowValidatorsCall),
        GetStakeRecord(GetStakeRecordCall),
        GetStakeRecordCount(GetStakeRecordCountCall),
        GetStakeRecordsForUser(GetStakeRecordsForUserCall),
        GetStakeWeightInEpoch(GetStakeWeightInEpochCall),
        GetThreshold(GetThresholdCall),
        GetTimelockInEpoch(GetTimelockInEpochCall),
        GetTokenContractAddress(GetTokenContractAddressCall),
        GetTokenPrice(GetTokenPriceCall),
        GetTokensStaked(GetTokensStakedCall),
        GetTotalStake(GetTotalStakeCall),
        GetTotalStakeByUser(GetTotalStakeByUserCall),
        GetTrustedForwarder(GetTrustedForwarderCall),
        GetUnfrozenStakeCountForUser(GetUnfrozenStakeCountForUserCall),
        GetValidatorsDelegated(GetValidatorsDelegatedCall),
        GetValidatorsInCurrentEpoch(GetValidatorsInCurrentEpochCall),
        GetValidatorsInNextEpoch(GetValidatorsInNextEpochCall),
        GetValidatorsStructs(GetValidatorsStructsCall),
        GetValidatorsStructsInCurrentEpoch(GetValidatorsStructsInCurrentEpochCall),
        GetValidatorsStructsInNextEpoch(GetValidatorsStructsInNextEpochCall),
        GetVotingStatusToKickValidator(GetVotingStatusToKickValidatorCall),
        GlobalConfig(GlobalConfigCall),
        IncreaseRewardPool(IncreaseRewardPoolCall),
        IncreaseStakeRecordAmount(IncreaseStakeRecordAmountCall),
        IncreaseStakeRecordTimelock(IncreaseStakeRecordTimelockCall),
        InitializeRewardEpoch(InitializeRewardEpochCall),
        IsActiveShadowValidator(IsActiveShadowValidatorCall),
        IsActiveValidator(IsActiveValidatorCall),
        IsActiveValidatorByNodeAddress(IsActiveValidatorByNodeAddressCall),
        IsActiveValidatorByNodeAddressForNextEpoch(
            IsActiveValidatorByNodeAddressForNextEpochCall,
        ),
        IsActiveValidatorForNextEpoch(IsActiveValidatorForNextEpochCall),
        IsApprovedForAll(IsApprovedForAllCall),
        IsReadyForNextEpoch(IsReadyForNextEpochCall),
        IsRecentValidator(IsRecentValidatorCall),
        IsRecentValidatorWithRealmId(IsRecentValidatorWithRealmIdCall),
        IsValidatorBanned(IsValidatorBannedCall),
        IsValidatorInCurrentEpoch(IsValidatorInCurrentEpochCall),
        IsValidatorInCurrentOrNextEpoch(IsValidatorInCurrentOrNextEpochCall),
        IsValidatorInNextEpoch(IsValidatorInNextEpochCall),
        KeySets(KeySetsCall),
        KickPenaltyPercentByReason(KickPenaltyPercentByReasonCall),
        KickValidatorInNextEpoch(KickValidatorInNextEpochCall),
        LitActionsConfig(LitActionsConfigCall),
        LockValidatorsForNextEpoch(LockValidatorsForNextEpochCall),
        MaxStake(MaxStakeCall),
        MaxTimeLock(MaxTimeLockCall),
        MigrateStakeRecord(MigrateStakeRecordCall),
        MinSelfStake(MinSelfStakeCall),
        MinStake(MinStakeCall),
        MinTimeLock(MinTimeLockCall),
        NextValidatorCountForConsensus(NextValidatorCountForConsensusCall),
        NodeAddressToStakerAddress(NodeAddressToStakerAddressCall),
        NodeAddressToStakerAddressAcrossRealms(
            NodeAddressToStakerAddressAcrossRealmsCall,
        ),
        NumRealms(NumRealmsCall),
        OperatorAddressToStakerAddress(OperatorAddressToStakerAddressCall),
        Owner(OwnerCall),
        OwnerOf(OwnerOfCall),
        OwnershipChange(OwnershipChangeCall),
        PermittedRealmsForValidator(PermittedRealmsForValidatorCall),
        PermittedValidators(PermittedValidatorsCall),
        Pow(PowCall),
        ReadyForNextEpoch(ReadyForNextEpochCall),
        RealmConfig(RealmConfigCall),
        RegisterAttestedWallet(RegisterAttestedWalletCall),
        RemoveRealm(RemoveRealmCall),
        RequestToJoin(RequestToJoinCall),
        RequestToJoinAsAdmin(RequestToJoinAsAdminCall),
        RequestToJoinAsForShadowSplicing(RequestToJoinAsForShadowSplicingCall),
        RequestToJoinAsNode(RequestToJoinAsNodeCall),
        RequestToLeave(RequestToLeaveCall),
        RequestToLeaveAsNode(RequestToLeaveAsNodeCall),
        SafeTransferFrom(SafeTransferFromCall),
        SafeTransferFromWithFromAndToAndData(SafeTransferFromWithFromAndToAndDataCall),
        SelfStakeBalanceOf(SelfStakeBalanceOfCall),
        SetApprovalForAll(SetApprovalForAllCall),
        SetComplaintConfig(SetComplaintConfigCall),
        SetConfig(SetConfigCall),
        SetContractResolver(SetContractResolverCall),
        SetDemeritRejoinThreshold(SetDemeritRejoinThresholdCall),
        SetDevopsAdmin(SetDevopsAdminCall),
        SetEpochEndTime(SetEpochEndTimeCall),
        SetEpochLength(SetEpochLengthCall),
        SetEpochState(SetEpochStateCall),
        SetEpochTimeout(SetEpochTimeoutCall),
        SetIpPortNodeAddress(SetIpPortNodeAddressCall),
        SetKeySet(SetKeySetCall),
        SetLitActionConfig(SetLitActionConfigCall),
        SetMaxVersion(SetMaxVersionCall),
        SetMinVersion(SetMinVersionCall),
        SetPendingRejoinTimeout(SetPendingRejoinTimeoutCall),
        SetPermittedValidators(SetPermittedValidatorsCall),
        SetPermittedValidatorsOn(SetPermittedValidatorsOnCall),
        SetRealmConfig(SetRealmConfigCall),
        SetTokenTotalSupplyStandIn(SetTokenTotalSupplyStandInCall),
        SetTrustedForwarder(SetTrustedForwarderCall),
        SetUp(SetUpCall),
        SetValidatorCommissionRate(SetValidatorCommissionRateCall),
        ShouldKickValidator(ShouldKickValidatorCall),
        SignalReadyForNextEpoch(SignalReadyForNextEpochCall),
        SplitStakeRecord(SplitStakeRecordCall),
        Stake(StakeCall),
        StakerToValidatorsTheyStakedTo(StakerToValidatorsTheyStakedToCall),
        State(StateCall),
        SupportsInterface(SupportsInterfaceCall),
        TargetArtifactSelectors(TargetArtifactSelectorsCall),
        TargetArtifacts(TargetArtifactsCall),
        TargetContracts(TargetContractsCall),
        TargetInterfaces(TargetInterfacesCall),
        TargetSelectors(TargetSelectorsCall),
        TargetSenders(TargetSendersCall),
        TestStake(TestStakeCall),
        TestStakeAndTransfer(TestStakeAndTransferCall),
        TestStakeAndTransferClaimRewards(TestStakeAndTransferClaimRewardsCall),
        TestStakeAndTransferReceiverMutatesStakeRecord(
            TestStakeAndTransferReceiverMutatesStakeRecordCall,
        ),
        TestStakeAndTransferRevertNotOwner(TestStakeAndTransferRevertNotOwnerCall),
        TestStakeAndTransferTokenOwnerByIndex(TestStakeAndTransferTokenOwnerByIndexCall),
        TestStakeAndTransferWithdraw(TestStakeAndTransferWithdrawCall),
        TestStakeApproveAndTransfer(TestStakeApproveAndTransferCall),
        TestStakeApproveForAllAndTransfer(TestStakeApproveForAllAndTransferCall),
        TestStakeMaxTransferShouldFail(TestStakeMaxTransferShouldFailCall),
        TestStakeMutateStakeRecord(TestStakeMutateStakeRecordCall),
        TokenOfOwnerByIndex(TokenOfOwnerByIndexCall),
        TokenToStakeRecord(TokenToStakeRecordCall),
        TotalSupply(TotalSupplyCall),
        TransferFrom(TransferFromCall),
        TransferOwnership(TransferOwnershipCall),
        UnfreezeStake(UnfreezeStakeCall),
        ValidatorSelfStakeWillExpire(ValidatorSelfStakeWillExpireCall),
        ValidatorByStakerAddress(ValidatorByStakerAddressCall),
        Validators(ValidatorsCall),
        VerifyKeySetCounts(VerifyKeySetCountsCall),
        Withdraw(WithdrawCall),
    }
    impl ::ethers::core::abi::AbiDecode for StakingCalls {
        fn decode(
            data: impl AsRef<[u8]>,
        ) -> ::core::result::Result<Self, ::ethers::core::abi::AbiError> {
            let data = data.as_ref();
            if let Ok(decoded) = <IsTestCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::IsTest(decoded));
            }
            if let Ok(decoded) = <GenerateAddressesCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::GenerateAddresses(decoded));
            }
            if let Ok(decoded) = <GenerateAddressesWithOffsetCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::GenerateAddressesWithOffset(decoded));
            }
            if let Ok(decoded) = <GeneratePubKeysCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::GeneratePubKeys(decoded));
            }
            if let Ok(decoded) = <GenerateUint256SCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::GenerateUint256S(decoded));
            }
            if let Ok(decoded) = <GenerateUint256SWithOffsetCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::GenerateUint256SWithOffset(decoded));
            }
            if let Ok(decoded) = <GenerateValidatorsCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::GenerateValidators(decoded));
            }
            if let Ok(decoded) = <AddRealmCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::AddRealm(decoded));
            }
            if let Ok(decoded) = <AdminKickValidatorInNextEpochCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::AdminKickValidatorInNextEpoch(decoded));
            }
            if let Ok(decoded) = <AdminRejoinValidatorCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::AdminRejoinValidator(decoded));
            }
            if let Ok(decoded) = <AdminSetValidatorRegisterAttestedWalletDisabledCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(
                    Self::AdminSetValidatorRegisterAttestedWalletDisabled(decoded),
                );
            }
            if let Ok(decoded) = <AdminSetValidatorsInCurrentEpochCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::AdminSetValidatorsInCurrentEpoch(decoded));
            }
            if let Ok(decoded) = <AdminSetValidatorsInNextEpochCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::AdminSetValidatorsInNextEpoch(decoded));
            }
            if let Ok(decoded) = <AdminSetupShadowSplicingCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::AdminSetupShadowSplicing(decoded));
            }
            if let Ok(decoded) = <AdminSlashValidatorCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::AdminSlashValidator(decoded));
            }
            if let Ok(decoded) = <AdminStakeForUserCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::AdminStakeForUser(decoded));
            }
            if let Ok(decoded) = <AdminUnfreezeForUserCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::AdminUnfreezeForUser(decoded));
            }
            if let Ok(decoded) = <AdvanceEpochCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::AdvanceEpoch(decoded));
            }
            if let Ok(decoded) = <ApproveCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::Approve(decoded));
            }
            if let Ok(decoded) = <BalanceOfCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::BalanceOf(decoded));
            }
            if let Ok(decoded) = <CalculateRewardsPerDayCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::CalculateRewardsPerDay(decoded));
            }
            if let Ok(decoded) = <CalculateStakeWeightCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::CalculateStakeWeight(decoded));
            }
            if let Ok(decoded) = <CheckActiveOrUnlockedOrPausedStateCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::CheckActiveOrUnlockedOrPausedState(decoded));
            }
            if let Ok(decoded) = <CheckStakingAmountsCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::CheckStakingAmounts(decoded));
            }
            if let Ok(decoded) = <CheckVersionCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::CheckVersion(decoded));
            }
            if let Ok(decoded) = <ClaimFixedCostRewardsCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::ClaimFixedCostRewards(decoded));
            }
            if let Ok(decoded) = <ClaimStakeRewardsCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::ClaimStakeRewards(decoded));
            }
            if let Ok(decoded) = <ClaimValidatorCommissionCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::ClaimValidatorCommission(decoded));
            }
            if let Ok(decoded) = <ComplaintConfigCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::ComplaintConfig(decoded));
            }
            if let Ok(decoded) = <ContractResolverCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::ContractResolver(decoded));
            }
            if let Ok(decoded) = <CountOfCurrentValidatorsReadyForNextEpochCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::CountOfCurrentValidatorsReadyForNextEpoch(decoded));
            }
            if let Ok(decoded) = <CountOfNextValidatorsReadyForNextEpochCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::CountOfNextValidatorsReadyForNextEpoch(decoded));
            }
            if let Ok(decoded) = <CurrentValidatorCountForConsensusCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::CurrentValidatorCountForConsensus(decoded));
            }
            if let Ok(decoded) = <DecreaseRewardPoolCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::DecreaseRewardPool(decoded));
            }
            if let Ok(decoded) = <DeleteKeySetCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::DeleteKeySet(decoded));
            }
            if let Ok(decoded) = <DiamondCutCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::DiamondCut(decoded));
            }
            if let Ok(decoded) = <EmitClearOfflinePhaseDataCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::EmitClearOfflinePhaseData(decoded));
            }
            if let Ok(decoded) = <EmitCountOfflinePhaseDataCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::EmitCountOfflinePhaseData(decoded));
            }
            if let Ok(decoded) = <EpochCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::Epoch(decoded));
            }
            if let Ok(decoded) = <ExcludeArtifactsCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::ExcludeArtifacts(decoded));
            }
            if let Ok(decoded) = <ExcludeContractsCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::ExcludeContracts(decoded));
            }
            if let Ok(decoded) = <ExcludeSelectorsCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::ExcludeSelectors(decoded));
            }
            if let Ok(decoded) = <ExcludeSendersCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::ExcludeSenders(decoded));
            }
            if let Ok(decoded) = <ExitCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::Exit(decoded));
            }
            if let Ok(decoded) = <FacetAddressCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::FacetAddress(decoded));
            }
            if let Ok(decoded) = <FacetAddressesCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::FacetAddresses(decoded));
            }
            if let Ok(decoded) = <FacetFunctionSelectorsCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::FacetFunctionSelectors(decoded));
            }
            if let Ok(decoded) = <FacetsCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::Facets(decoded));
            }
            if let Ok(decoded) = <FailedCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::Failed(decoded));
            }
            if let Ok(decoded) = <GetActiveUnkickedValidatorCountCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::GetActiveUnkickedValidatorCount(decoded));
            }
            if let Ok(decoded) = <GetActiveUnkickedValidatorStructsCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::GetActiveUnkickedValidatorStructs(decoded));
            }
            if let Ok(decoded) = <GetActiveUnkickedValidatorStructsAndCountsCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::GetActiveUnkickedValidatorStructsAndCounts(decoded));
            }
            if let Ok(decoded) = <GetActiveUnkickedValidatorsCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::GetActiveUnkickedValidators(decoded));
            }
            if let Ok(decoded) = <GetAllReserveValidatorsCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::GetAllReserveValidators(decoded));
            }
            if let Ok(decoded) = <GetAllUnkickedValidatorsCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::GetAllUnkickedValidators(decoded));
            }
            if let Ok(decoded) = <GetAllValidatorsCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::GetAllValidators(decoded));
            }
            if let Ok(decoded) = <GetApprovedCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::GetApproved(decoded));
            }
            if let Ok(decoded) = <GetAttestedPubKeyCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::GetAttestedPubKey(decoded));
            }
            if let Ok(decoded) = <GetCurrentRealmIdForStakerAddressCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::GetCurrentRealmIdForStakerAddress(decoded));
            }
            if let Ok(decoded) = <GetDelegatedStakersWithUnfreezingStakesCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::GetDelegatedStakersWithUnfreezingStakes(decoded));
            }
            if let Ok(decoded) = <GetDelegatedStakersWithUnfreezingStakesCountCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::GetDelegatedStakersWithUnfreezingStakesCount(decoded));
            }
            if let Ok(decoded) = <GetEmptyStakeRecordSlotsCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::GetEmptyStakeRecordSlots(decoded));
            }
            if let Ok(decoded) = <GetKeySetCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::GetKeySet(decoded));
            }
            if let Ok(decoded) = <GetKeyTypesCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::GetKeyTypes(decoded));
            }
            if let Ok(decoded) = <GetKickedValidatorsCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::GetKickedValidators(decoded));
            }
            if let Ok(decoded) = <GetLastStakeRecordCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::GetLastStakeRecord(decoded));
            }
            if let Ok(decoded) = <GetLitCircCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::GetLitCirc(decoded));
            }
            if let Ok(decoded) = <GetLowestRewardEpochNumberCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::GetLowestRewardEpochNumber(decoded));
            }
            if let Ok(decoded) = <GetMaxVersionCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::GetMaxVersion(decoded));
            }
            if let Ok(decoded) = <GetMaxVersionStringCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::GetMaxVersionString(decoded));
            }
            if let Ok(decoded) = <GetMaximumStakeCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::GetMaximumStake(decoded));
            }
            if let Ok(decoded) = <GetMinVersionCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::GetMinVersion(decoded));
            }
            if let Ok(decoded) = <GetMinVersionStringCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::GetMinVersionString(decoded));
            }
            if let Ok(decoded) = <GetMinimumSelfStakeCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::GetMinimumSelfStake(decoded));
            }
            if let Ok(decoded) = <GetMinimumStakeCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::GetMinimumStake(decoded));
            }
            if let Ok(decoded) = <GetMostRecentStakeRecordCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::GetMostRecentStakeRecord(decoded));
            }
            if let Ok(decoded) = <GetNodeAttestedPubKeyMappingsCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::GetNodeAttestedPubKeyMappings(decoded));
            }
            if let Ok(decoded) = <GetNodeDemeritsCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::GetNodeDemerits(decoded));
            }
            if let Ok(decoded) = <GetNodeStakerAddressMappingsCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::GetNodeStakerAddressMappings(decoded));
            }
            if let Ok(decoded) = <GetNonShadowValidatorsCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::GetNonShadowValidators(decoded));
            }
            if let Ok(decoded) = <GetNonShadowValidatorsInCurrentEpochLengthCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::GetNonShadowValidatorsInCurrentEpochLength(decoded));
            }
            if let Ok(decoded) = <GetRealmIdForStakerAddressCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::GetRealmIdForStakerAddress(decoded));
            }
            if let Ok(decoded) = <GetRewardEpochCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::GetRewardEpoch(decoded));
            }
            if let Ok(decoded) = <GetRewardEpochGlobalStatsCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::GetRewardEpochGlobalStats(decoded));
            }
            if let Ok(decoded) = <GetRewardEpochNumberCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::GetRewardEpochNumber(decoded));
            }
            if let Ok(decoded) = <GetRewardEpochViewCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::GetRewardEpochView(decoded));
            }
            if let Ok(decoded) = <GetSelfStakeRecordCountCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::GetSelfStakeRecordCount(decoded));
            }
            if let Ok(decoded) = <GetShadowRealmIdForStakerAddressCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::GetShadowRealmIdForStakerAddress(decoded));
            }
            if let Ok(decoded) = <GetShadowValidatorsCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::GetShadowValidators(decoded));
            }
            if let Ok(decoded) = <GetStakeRecordCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::GetStakeRecord(decoded));
            }
            if let Ok(decoded) = <GetStakeRecordCountCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::GetStakeRecordCount(decoded));
            }
            if let Ok(decoded) = <GetStakeRecordsForUserCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::GetStakeRecordsForUser(decoded));
            }
            if let Ok(decoded) = <GetStakeWeightInEpochCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::GetStakeWeightInEpoch(decoded));
            }
            if let Ok(decoded) = <GetThresholdCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::GetThreshold(decoded));
            }
            if let Ok(decoded) = <GetTimelockInEpochCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::GetTimelockInEpoch(decoded));
            }
            if let Ok(decoded) = <GetTokenContractAddressCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::GetTokenContractAddress(decoded));
            }
            if let Ok(decoded) = <GetTokenPriceCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::GetTokenPrice(decoded));
            }
            if let Ok(decoded) = <GetTokensStakedCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::GetTokensStaked(decoded));
            }
            if let Ok(decoded) = <GetTotalStakeCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::GetTotalStake(decoded));
            }
            if let Ok(decoded) = <GetTotalStakeByUserCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::GetTotalStakeByUser(decoded));
            }
            if let Ok(decoded) = <GetTrustedForwarderCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::GetTrustedForwarder(decoded));
            }
            if let Ok(decoded) = <GetUnfrozenStakeCountForUserCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::GetUnfrozenStakeCountForUser(decoded));
            }
            if let Ok(decoded) = <GetValidatorsDelegatedCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::GetValidatorsDelegated(decoded));
            }
            if let Ok(decoded) = <GetValidatorsInCurrentEpochCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::GetValidatorsInCurrentEpoch(decoded));
            }
            if let Ok(decoded) = <GetValidatorsInNextEpochCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::GetValidatorsInNextEpoch(decoded));
            }
            if let Ok(decoded) = <GetValidatorsStructsCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::GetValidatorsStructs(decoded));
            }
            if let Ok(decoded) = <GetValidatorsStructsInCurrentEpochCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::GetValidatorsStructsInCurrentEpoch(decoded));
            }
            if let Ok(decoded) = <GetValidatorsStructsInNextEpochCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::GetValidatorsStructsInNextEpoch(decoded));
            }
            if let Ok(decoded) = <GetVotingStatusToKickValidatorCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::GetVotingStatusToKickValidator(decoded));
            }
            if let Ok(decoded) = <GlobalConfigCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::GlobalConfig(decoded));
            }
            if let Ok(decoded) = <IncreaseRewardPoolCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::IncreaseRewardPool(decoded));
            }
            if let Ok(decoded) = <IncreaseStakeRecordAmountCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::IncreaseStakeRecordAmount(decoded));
            }
            if let Ok(decoded) = <IncreaseStakeRecordTimelockCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::IncreaseStakeRecordTimelock(decoded));
            }
            if let Ok(decoded) = <InitializeRewardEpochCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::InitializeRewardEpoch(decoded));
            }
            if let Ok(decoded) = <IsActiveShadowValidatorCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::IsActiveShadowValidator(decoded));
            }
            if let Ok(decoded) = <IsActiveValidatorCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::IsActiveValidator(decoded));
            }
            if let Ok(decoded) = <IsActiveValidatorByNodeAddressCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::IsActiveValidatorByNodeAddress(decoded));
            }
            if let Ok(decoded) = <IsActiveValidatorByNodeAddressForNextEpochCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::IsActiveValidatorByNodeAddressForNextEpoch(decoded));
            }
            if let Ok(decoded) = <IsActiveValidatorForNextEpochCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::IsActiveValidatorForNextEpoch(decoded));
            }
            if let Ok(decoded) = <IsApprovedForAllCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::IsApprovedForAll(decoded));
            }
            if let Ok(decoded) = <IsReadyForNextEpochCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::IsReadyForNextEpoch(decoded));
            }
            if let Ok(decoded) = <IsRecentValidatorCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::IsRecentValidator(decoded));
            }
            if let Ok(decoded) = <IsRecentValidatorWithRealmIdCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::IsRecentValidatorWithRealmId(decoded));
            }
            if let Ok(decoded) = <IsValidatorBannedCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::IsValidatorBanned(decoded));
            }
            if let Ok(decoded) = <IsValidatorInCurrentEpochCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::IsValidatorInCurrentEpoch(decoded));
            }
            if let Ok(decoded) = <IsValidatorInCurrentOrNextEpochCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::IsValidatorInCurrentOrNextEpoch(decoded));
            }
            if let Ok(decoded) = <IsValidatorInNextEpochCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::IsValidatorInNextEpoch(decoded));
            }
            if let Ok(decoded) = <KeySetsCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::KeySets(decoded));
            }
            if let Ok(decoded) = <KickPenaltyPercentByReasonCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::KickPenaltyPercentByReason(decoded));
            }
            if let Ok(decoded) = <KickValidatorInNextEpochCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::KickValidatorInNextEpoch(decoded));
            }
            if let Ok(decoded) = <LitActionsConfigCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::LitActionsConfig(decoded));
            }
            if let Ok(decoded) = <LockValidatorsForNextEpochCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::LockValidatorsForNextEpoch(decoded));
            }
            if let Ok(decoded) = <MaxStakeCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::MaxStake(decoded));
            }
            if let Ok(decoded) = <MaxTimeLockCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::MaxTimeLock(decoded));
            }
            if let Ok(decoded) = <MigrateStakeRecordCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::MigrateStakeRecord(decoded));
            }
            if let Ok(decoded) = <MinSelfStakeCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::MinSelfStake(decoded));
            }
            if let Ok(decoded) = <MinStakeCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::MinStake(decoded));
            }
            if let Ok(decoded) = <MinTimeLockCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::MinTimeLock(decoded));
            }
            if let Ok(decoded) = <NextValidatorCountForConsensusCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::NextValidatorCountForConsensus(decoded));
            }
            if let Ok(decoded) = <NodeAddressToStakerAddressCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::NodeAddressToStakerAddress(decoded));
            }
            if let Ok(decoded) = <NodeAddressToStakerAddressAcrossRealmsCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::NodeAddressToStakerAddressAcrossRealms(decoded));
            }
            if let Ok(decoded) = <NumRealmsCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::NumRealms(decoded));
            }
            if let Ok(decoded) = <OperatorAddressToStakerAddressCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::OperatorAddressToStakerAddress(decoded));
            }
            if let Ok(decoded) = <OwnerCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::Owner(decoded));
            }
            if let Ok(decoded) = <OwnerOfCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::OwnerOf(decoded));
            }
            if let Ok(decoded) = <OwnershipChangeCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::OwnershipChange(decoded));
            }
            if let Ok(decoded) = <PermittedRealmsForValidatorCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::PermittedRealmsForValidator(decoded));
            }
            if let Ok(decoded) = <PermittedValidatorsCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::PermittedValidators(decoded));
            }
            if let Ok(decoded) = <PowCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::Pow(decoded));
            }
            if let Ok(decoded) = <ReadyForNextEpochCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::ReadyForNextEpoch(decoded));
            }
            if let Ok(decoded) = <RealmConfigCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::RealmConfig(decoded));
            }
            if let Ok(decoded) = <RegisterAttestedWalletCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::RegisterAttestedWallet(decoded));
            }
            if let Ok(decoded) = <RemoveRealmCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::RemoveRealm(decoded));
            }
            if let Ok(decoded) = <RequestToJoinCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::RequestToJoin(decoded));
            }
            if let Ok(decoded) = <RequestToJoinAsAdminCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::RequestToJoinAsAdmin(decoded));
            }
            if let Ok(decoded) = <RequestToJoinAsForShadowSplicingCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::RequestToJoinAsForShadowSplicing(decoded));
            }
            if let Ok(decoded) = <RequestToJoinAsNodeCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::RequestToJoinAsNode(decoded));
            }
            if let Ok(decoded) = <RequestToLeaveCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::RequestToLeave(decoded));
            }
            if let Ok(decoded) = <RequestToLeaveAsNodeCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::RequestToLeaveAsNode(decoded));
            }
            if let Ok(decoded) = <SafeTransferFromCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::SafeTransferFrom(decoded));
            }
            if let Ok(decoded) = <SafeTransferFromWithFromAndToAndDataCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::SafeTransferFromWithFromAndToAndData(decoded));
            }
            if let Ok(decoded) = <SelfStakeBalanceOfCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::SelfStakeBalanceOf(decoded));
            }
            if let Ok(decoded) = <SetApprovalForAllCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::SetApprovalForAll(decoded));
            }
            if let Ok(decoded) = <SetComplaintConfigCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::SetComplaintConfig(decoded));
            }
            if let Ok(decoded) = <SetConfigCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::SetConfig(decoded));
            }
            if let Ok(decoded) = <SetContractResolverCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::SetContractResolver(decoded));
            }
            if let Ok(decoded) = <SetDemeritRejoinThresholdCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::SetDemeritRejoinThreshold(decoded));
            }
            if let Ok(decoded) = <SetDevopsAdminCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::SetDevopsAdmin(decoded));
            }
            if let Ok(decoded) = <SetEpochEndTimeCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::SetEpochEndTime(decoded));
            }
            if let Ok(decoded) = <SetEpochLengthCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::SetEpochLength(decoded));
            }
            if let Ok(decoded) = <SetEpochStateCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::SetEpochState(decoded));
            }
            if let Ok(decoded) = <SetEpochTimeoutCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::SetEpochTimeout(decoded));
            }
            if let Ok(decoded) = <SetIpPortNodeAddressCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::SetIpPortNodeAddress(decoded));
            }
            if let Ok(decoded) = <SetKeySetCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::SetKeySet(decoded));
            }
            if let Ok(decoded) = <SetLitActionConfigCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::SetLitActionConfig(decoded));
            }
            if let Ok(decoded) = <SetMaxVersionCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::SetMaxVersion(decoded));
            }
            if let Ok(decoded) = <SetMinVersionCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::SetMinVersion(decoded));
            }
            if let Ok(decoded) = <SetPendingRejoinTimeoutCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::SetPendingRejoinTimeout(decoded));
            }
            if let Ok(decoded) = <SetPermittedValidatorsCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::SetPermittedValidators(decoded));
            }
            if let Ok(decoded) = <SetPermittedValidatorsOnCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::SetPermittedValidatorsOn(decoded));
            }
            if let Ok(decoded) = <SetRealmConfigCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::SetRealmConfig(decoded));
            }
            if let Ok(decoded) = <SetTokenTotalSupplyStandInCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::SetTokenTotalSupplyStandIn(decoded));
            }
            if let Ok(decoded) = <SetTrustedForwarderCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::SetTrustedForwarder(decoded));
            }
            if let Ok(decoded) = <SetUpCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::SetUp(decoded));
            }
            if let Ok(decoded) = <SetValidatorCommissionRateCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::SetValidatorCommissionRate(decoded));
            }
            if let Ok(decoded) = <ShouldKickValidatorCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::ShouldKickValidator(decoded));
            }
            if let Ok(decoded) = <SignalReadyForNextEpochCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::SignalReadyForNextEpoch(decoded));
            }
            if let Ok(decoded) = <SplitStakeRecordCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::SplitStakeRecord(decoded));
            }
            if let Ok(decoded) = <StakeCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::Stake(decoded));
            }
            if let Ok(decoded) = <StakerToValidatorsTheyStakedToCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::StakerToValidatorsTheyStakedTo(decoded));
            }
            if let Ok(decoded) = <StateCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::State(decoded));
            }
            if let Ok(decoded) = <SupportsInterfaceCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::SupportsInterface(decoded));
            }
            if let Ok(decoded) = <TargetArtifactSelectorsCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::TargetArtifactSelectors(decoded));
            }
            if let Ok(decoded) = <TargetArtifactsCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::TargetArtifacts(decoded));
            }
            if let Ok(decoded) = <TargetContractsCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::TargetContracts(decoded));
            }
            if let Ok(decoded) = <TargetInterfacesCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::TargetInterfaces(decoded));
            }
            if let Ok(decoded) = <TargetSelectorsCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::TargetSelectors(decoded));
            }
            if let Ok(decoded) = <TargetSendersCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::TargetSenders(decoded));
            }
            if let Ok(decoded) = <TestStakeCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::TestStake(decoded));
            }
            if let Ok(decoded) = <TestStakeAndTransferCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::TestStakeAndTransfer(decoded));
            }
            if let Ok(decoded) = <TestStakeAndTransferClaimRewardsCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::TestStakeAndTransferClaimRewards(decoded));
            }
            if let Ok(decoded) = <TestStakeAndTransferReceiverMutatesStakeRecordCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::TestStakeAndTransferReceiverMutatesStakeRecord(decoded));
            }
            if let Ok(decoded) = <TestStakeAndTransferRevertNotOwnerCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::TestStakeAndTransferRevertNotOwner(decoded));
            }
            if let Ok(decoded) = <TestStakeAndTransferTokenOwnerByIndexCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::TestStakeAndTransferTokenOwnerByIndex(decoded));
            }
            if let Ok(decoded) = <TestStakeAndTransferWithdrawCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::TestStakeAndTransferWithdraw(decoded));
            }
            if let Ok(decoded) = <TestStakeApproveAndTransferCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::TestStakeApproveAndTransfer(decoded));
            }
            if let Ok(decoded) = <TestStakeApproveForAllAndTransferCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::TestStakeApproveForAllAndTransfer(decoded));
            }
            if let Ok(decoded) = <TestStakeMaxTransferShouldFailCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::TestStakeMaxTransferShouldFail(decoded));
            }
            if let Ok(decoded) = <TestStakeMutateStakeRecordCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::TestStakeMutateStakeRecord(decoded));
            }
            if let Ok(decoded) = <TokenOfOwnerByIndexCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::TokenOfOwnerByIndex(decoded));
            }
            if let Ok(decoded) = <TokenToStakeRecordCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::TokenToStakeRecord(decoded));
            }
            if let Ok(decoded) = <TotalSupplyCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::TotalSupply(decoded));
            }
            if let Ok(decoded) = <TransferFromCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::TransferFrom(decoded));
            }
            if let Ok(decoded) = <TransferOwnershipCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::TransferOwnership(decoded));
            }
            if let Ok(decoded) = <UnfreezeStakeCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::UnfreezeStake(decoded));
            }
            if let Ok(decoded) = <ValidatorSelfStakeWillExpireCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::ValidatorSelfStakeWillExpire(decoded));
            }
            if let Ok(decoded) = <ValidatorByStakerAddressCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::ValidatorByStakerAddress(decoded));
            }
            if let Ok(decoded) = <ValidatorsCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::Validators(decoded));
            }
            if let Ok(decoded) = <VerifyKeySetCountsCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::VerifyKeySetCounts(decoded));
            }
            if let Ok(decoded) = <WithdrawCall as ::ethers::core::abi::AbiDecode>::decode(
                data,
            ) {
                return Ok(Self::Withdraw(decoded));
            }
            Err(::ethers::core::abi::Error::InvalidData.into())
        }
    }
    impl ::ethers::core::abi::AbiEncode for StakingCalls {
        fn encode(self) -> Vec<u8> {
            match self {
                Self::IsTest(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::GenerateAddresses(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GenerateAddressesWithOffset(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GeneratePubKeys(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GenerateUint256S(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GenerateUint256SWithOffset(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GenerateValidators(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::AddRealm(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::AdminKickValidatorInNextEpoch(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::AdminRejoinValidator(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::AdminSetValidatorRegisterAttestedWalletDisabled(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::AdminSetValidatorsInCurrentEpoch(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::AdminSetValidatorsInNextEpoch(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::AdminSetupShadowSplicing(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::AdminSlashValidator(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::AdminStakeForUser(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::AdminUnfreezeForUser(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::AdvanceEpoch(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::Approve(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::BalanceOf(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::CalculateRewardsPerDay(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::CalculateStakeWeight(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::CheckActiveOrUnlockedOrPausedState(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::CheckStakingAmounts(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::CheckVersion(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::ClaimFixedCostRewards(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::ClaimStakeRewards(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::ClaimValidatorCommission(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::ComplaintConfig(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::ContractResolver(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::CountOfCurrentValidatorsReadyForNextEpoch(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::CountOfNextValidatorsReadyForNextEpoch(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::CurrentValidatorCountForConsensus(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::DecreaseRewardPool(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::DeleteKeySet(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::DiamondCut(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::EmitClearOfflinePhaseData(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::EmitCountOfflinePhaseData(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::Epoch(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::ExcludeArtifacts(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::ExcludeContracts(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::ExcludeSelectors(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::ExcludeSenders(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::Exit(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::FacetAddress(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::FacetAddresses(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::FacetFunctionSelectors(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::Facets(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::Failed(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::GetActiveUnkickedValidatorCount(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GetActiveUnkickedValidatorStructs(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GetActiveUnkickedValidatorStructsAndCounts(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GetActiveUnkickedValidators(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GetAllReserveValidators(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GetAllUnkickedValidators(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GetAllValidators(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GetApproved(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GetAttestedPubKey(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GetCurrentRealmIdForStakerAddress(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GetDelegatedStakersWithUnfreezingStakes(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GetDelegatedStakersWithUnfreezingStakesCount(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GetEmptyStakeRecordSlots(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GetKeySet(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GetKeyTypes(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GetKickedValidators(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GetLastStakeRecord(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GetLitCirc(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GetLowestRewardEpochNumber(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GetMaxVersion(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GetMaxVersionString(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GetMaximumStake(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GetMinVersion(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GetMinVersionString(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GetMinimumSelfStake(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GetMinimumStake(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GetMostRecentStakeRecord(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GetNodeAttestedPubKeyMappings(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GetNodeDemerits(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GetNodeStakerAddressMappings(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GetNonShadowValidators(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GetNonShadowValidatorsInCurrentEpochLength(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GetRealmIdForStakerAddress(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GetRewardEpoch(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GetRewardEpochGlobalStats(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GetRewardEpochNumber(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GetRewardEpochView(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GetSelfStakeRecordCount(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GetShadowRealmIdForStakerAddress(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GetShadowValidators(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GetStakeRecord(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GetStakeRecordCount(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GetStakeRecordsForUser(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GetStakeWeightInEpoch(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GetThreshold(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GetTimelockInEpoch(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GetTokenContractAddress(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GetTokenPrice(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GetTokensStaked(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GetTotalStake(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GetTotalStakeByUser(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GetTrustedForwarder(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GetUnfrozenStakeCountForUser(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GetValidatorsDelegated(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GetValidatorsInCurrentEpoch(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GetValidatorsInNextEpoch(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GetValidatorsStructs(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GetValidatorsStructsInCurrentEpoch(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GetValidatorsStructsInNextEpoch(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GetVotingStatusToKickValidator(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GlobalConfig(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::IncreaseRewardPool(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::IncreaseStakeRecordAmount(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::IncreaseStakeRecordTimelock(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::InitializeRewardEpoch(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::IsActiveShadowValidator(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::IsActiveValidator(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::IsActiveValidatorByNodeAddress(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::IsActiveValidatorByNodeAddressForNextEpoch(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::IsActiveValidatorForNextEpoch(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::IsApprovedForAll(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::IsReadyForNextEpoch(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::IsRecentValidator(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::IsRecentValidatorWithRealmId(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::IsValidatorBanned(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::IsValidatorInCurrentEpoch(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::IsValidatorInCurrentOrNextEpoch(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::IsValidatorInNextEpoch(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::KeySets(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::KickPenaltyPercentByReason(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::KickValidatorInNextEpoch(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::LitActionsConfig(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::LockValidatorsForNextEpoch(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::MaxStake(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::MaxTimeLock(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::MigrateStakeRecord(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::MinSelfStake(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::MinStake(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::MinTimeLock(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::NextValidatorCountForConsensus(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::NodeAddressToStakerAddress(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::NodeAddressToStakerAddressAcrossRealms(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::NumRealms(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::OperatorAddressToStakerAddress(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::Owner(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::OwnerOf(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::OwnershipChange(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::PermittedRealmsForValidator(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::PermittedValidators(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::Pow(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::ReadyForNextEpoch(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::RealmConfig(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::RegisterAttestedWallet(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::RemoveRealm(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::RequestToJoin(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::RequestToJoinAsAdmin(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::RequestToJoinAsForShadowSplicing(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::RequestToJoinAsNode(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::RequestToLeave(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::RequestToLeaveAsNode(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::SafeTransferFrom(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::SafeTransferFromWithFromAndToAndData(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::SelfStakeBalanceOf(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::SetApprovalForAll(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::SetComplaintConfig(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::SetConfig(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::SetContractResolver(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::SetDemeritRejoinThreshold(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::SetDevopsAdmin(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::SetEpochEndTime(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::SetEpochLength(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::SetEpochState(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::SetEpochTimeout(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::SetIpPortNodeAddress(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::SetKeySet(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::SetLitActionConfig(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::SetMaxVersion(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::SetMinVersion(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::SetPendingRejoinTimeout(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::SetPermittedValidators(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::SetPermittedValidatorsOn(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::SetRealmConfig(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::SetTokenTotalSupplyStandIn(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::SetTrustedForwarder(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::SetUp(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::SetValidatorCommissionRate(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::ShouldKickValidator(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::SignalReadyForNextEpoch(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::SplitStakeRecord(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::Stake(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::StakerToValidatorsTheyStakedTo(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::State(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::SupportsInterface(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::TargetArtifactSelectors(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::TargetArtifacts(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::TargetContracts(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::TargetInterfaces(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::TargetSelectors(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::TargetSenders(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::TestStake(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::TestStakeAndTransfer(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::TestStakeAndTransferClaimRewards(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::TestStakeAndTransferReceiverMutatesStakeRecord(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::TestStakeAndTransferRevertNotOwner(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::TestStakeAndTransferTokenOwnerByIndex(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::TestStakeAndTransferWithdraw(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::TestStakeApproveAndTransfer(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::TestStakeApproveForAllAndTransfer(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::TestStakeMaxTransferShouldFail(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::TestStakeMutateStakeRecord(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::TokenOfOwnerByIndex(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::TokenToStakeRecord(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::TotalSupply(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::TransferFrom(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::TransferOwnership(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::UnfreezeStake(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::ValidatorSelfStakeWillExpire(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::ValidatorByStakerAddress(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::Validators(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::VerifyKeySetCounts(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::Withdraw(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
            }
        }
    }
    impl ::core::fmt::Display for StakingCalls {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            match self {
                Self::IsTest(element) => ::core::fmt::Display::fmt(element, f),
                Self::GenerateAddresses(element) => ::core::fmt::Display::fmt(element, f),
                Self::GenerateAddressesWithOffset(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::GeneratePubKeys(element) => ::core::fmt::Display::fmt(element, f),
                Self::GenerateUint256S(element) => ::core::fmt::Display::fmt(element, f),
                Self::GenerateUint256SWithOffset(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::GenerateValidators(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::AddRealm(element) => ::core::fmt::Display::fmt(element, f),
                Self::AdminKickValidatorInNextEpoch(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::AdminRejoinValidator(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::AdminSetValidatorRegisterAttestedWalletDisabled(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::AdminSetValidatorsInCurrentEpoch(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::AdminSetValidatorsInNextEpoch(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::AdminSetupShadowSplicing(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::AdminSlashValidator(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::AdminStakeForUser(element) => ::core::fmt::Display::fmt(element, f),
                Self::AdminUnfreezeForUser(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::AdvanceEpoch(element) => ::core::fmt::Display::fmt(element, f),
                Self::Approve(element) => ::core::fmt::Display::fmt(element, f),
                Self::BalanceOf(element) => ::core::fmt::Display::fmt(element, f),
                Self::CalculateRewardsPerDay(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::CalculateStakeWeight(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::CheckActiveOrUnlockedOrPausedState(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::CheckStakingAmounts(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::CheckVersion(element) => ::core::fmt::Display::fmt(element, f),
                Self::ClaimFixedCostRewards(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::ClaimStakeRewards(element) => ::core::fmt::Display::fmt(element, f),
                Self::ClaimValidatorCommission(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::ComplaintConfig(element) => ::core::fmt::Display::fmt(element, f),
                Self::ContractResolver(element) => ::core::fmt::Display::fmt(element, f),
                Self::CountOfCurrentValidatorsReadyForNextEpoch(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::CountOfNextValidatorsReadyForNextEpoch(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::CurrentValidatorCountForConsensus(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::DecreaseRewardPool(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::DeleteKeySet(element) => ::core::fmt::Display::fmt(element, f),
                Self::DiamondCut(element) => ::core::fmt::Display::fmt(element, f),
                Self::EmitClearOfflinePhaseData(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::EmitCountOfflinePhaseData(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::Epoch(element) => ::core::fmt::Display::fmt(element, f),
                Self::ExcludeArtifacts(element) => ::core::fmt::Display::fmt(element, f),
                Self::ExcludeContracts(element) => ::core::fmt::Display::fmt(element, f),
                Self::ExcludeSelectors(element) => ::core::fmt::Display::fmt(element, f),
                Self::ExcludeSenders(element) => ::core::fmt::Display::fmt(element, f),
                Self::Exit(element) => ::core::fmt::Display::fmt(element, f),
                Self::FacetAddress(element) => ::core::fmt::Display::fmt(element, f),
                Self::FacetAddresses(element) => ::core::fmt::Display::fmt(element, f),
                Self::FacetFunctionSelectors(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::Facets(element) => ::core::fmt::Display::fmt(element, f),
                Self::Failed(element) => ::core::fmt::Display::fmt(element, f),
                Self::GetActiveUnkickedValidatorCount(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::GetActiveUnkickedValidatorStructs(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::GetActiveUnkickedValidatorStructsAndCounts(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::GetActiveUnkickedValidators(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::GetAllReserveValidators(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::GetAllUnkickedValidators(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::GetAllValidators(element) => ::core::fmt::Display::fmt(element, f),
                Self::GetApproved(element) => ::core::fmt::Display::fmt(element, f),
                Self::GetAttestedPubKey(element) => ::core::fmt::Display::fmt(element, f),
                Self::GetCurrentRealmIdForStakerAddress(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::GetDelegatedStakersWithUnfreezingStakes(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::GetDelegatedStakersWithUnfreezingStakesCount(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::GetEmptyStakeRecordSlots(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::GetKeySet(element) => ::core::fmt::Display::fmt(element, f),
                Self::GetKeyTypes(element) => ::core::fmt::Display::fmt(element, f),
                Self::GetKickedValidators(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::GetLastStakeRecord(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::GetLitCirc(element) => ::core::fmt::Display::fmt(element, f),
                Self::GetLowestRewardEpochNumber(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::GetMaxVersion(element) => ::core::fmt::Display::fmt(element, f),
                Self::GetMaxVersionString(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::GetMaximumStake(element) => ::core::fmt::Display::fmt(element, f),
                Self::GetMinVersion(element) => ::core::fmt::Display::fmt(element, f),
                Self::GetMinVersionString(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::GetMinimumSelfStake(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::GetMinimumStake(element) => ::core::fmt::Display::fmt(element, f),
                Self::GetMostRecentStakeRecord(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::GetNodeAttestedPubKeyMappings(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::GetNodeDemerits(element) => ::core::fmt::Display::fmt(element, f),
                Self::GetNodeStakerAddressMappings(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::GetNonShadowValidators(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::GetNonShadowValidatorsInCurrentEpochLength(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::GetRealmIdForStakerAddress(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::GetRewardEpoch(element) => ::core::fmt::Display::fmt(element, f),
                Self::GetRewardEpochGlobalStats(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::GetRewardEpochNumber(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::GetRewardEpochView(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::GetSelfStakeRecordCount(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::GetShadowRealmIdForStakerAddress(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::GetShadowValidators(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::GetStakeRecord(element) => ::core::fmt::Display::fmt(element, f),
                Self::GetStakeRecordCount(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::GetStakeRecordsForUser(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::GetStakeWeightInEpoch(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::GetThreshold(element) => ::core::fmt::Display::fmt(element, f),
                Self::GetTimelockInEpoch(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::GetTokenContractAddress(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::GetTokenPrice(element) => ::core::fmt::Display::fmt(element, f),
                Self::GetTokensStaked(element) => ::core::fmt::Display::fmt(element, f),
                Self::GetTotalStake(element) => ::core::fmt::Display::fmt(element, f),
                Self::GetTotalStakeByUser(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::GetTrustedForwarder(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::GetUnfrozenStakeCountForUser(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::GetValidatorsDelegated(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::GetValidatorsInCurrentEpoch(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::GetValidatorsInNextEpoch(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::GetValidatorsStructs(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::GetValidatorsStructsInCurrentEpoch(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::GetValidatorsStructsInNextEpoch(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::GetVotingStatusToKickValidator(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::GlobalConfig(element) => ::core::fmt::Display::fmt(element, f),
                Self::IncreaseRewardPool(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::IncreaseStakeRecordAmount(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::IncreaseStakeRecordTimelock(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::InitializeRewardEpoch(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::IsActiveShadowValidator(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::IsActiveValidator(element) => ::core::fmt::Display::fmt(element, f),
                Self::IsActiveValidatorByNodeAddress(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::IsActiveValidatorByNodeAddressForNextEpoch(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::IsActiveValidatorForNextEpoch(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::IsApprovedForAll(element) => ::core::fmt::Display::fmt(element, f),
                Self::IsReadyForNextEpoch(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::IsRecentValidator(element) => ::core::fmt::Display::fmt(element, f),
                Self::IsRecentValidatorWithRealmId(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::IsValidatorBanned(element) => ::core::fmt::Display::fmt(element, f),
                Self::IsValidatorInCurrentEpoch(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::IsValidatorInCurrentOrNextEpoch(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::IsValidatorInNextEpoch(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::KeySets(element) => ::core::fmt::Display::fmt(element, f),
                Self::KickPenaltyPercentByReason(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::KickValidatorInNextEpoch(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::LitActionsConfig(element) => ::core::fmt::Display::fmt(element, f),
                Self::LockValidatorsForNextEpoch(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::MaxStake(element) => ::core::fmt::Display::fmt(element, f),
                Self::MaxTimeLock(element) => ::core::fmt::Display::fmt(element, f),
                Self::MigrateStakeRecord(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::MinSelfStake(element) => ::core::fmt::Display::fmt(element, f),
                Self::MinStake(element) => ::core::fmt::Display::fmt(element, f),
                Self::MinTimeLock(element) => ::core::fmt::Display::fmt(element, f),
                Self::NextValidatorCountForConsensus(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::NodeAddressToStakerAddress(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::NodeAddressToStakerAddressAcrossRealms(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::NumRealms(element) => ::core::fmt::Display::fmt(element, f),
                Self::OperatorAddressToStakerAddress(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::Owner(element) => ::core::fmt::Display::fmt(element, f),
                Self::OwnerOf(element) => ::core::fmt::Display::fmt(element, f),
                Self::OwnershipChange(element) => ::core::fmt::Display::fmt(element, f),
                Self::PermittedRealmsForValidator(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::PermittedValidators(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::Pow(element) => ::core::fmt::Display::fmt(element, f),
                Self::ReadyForNextEpoch(element) => ::core::fmt::Display::fmt(element, f),
                Self::RealmConfig(element) => ::core::fmt::Display::fmt(element, f),
                Self::RegisterAttestedWallet(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::RemoveRealm(element) => ::core::fmt::Display::fmt(element, f),
                Self::RequestToJoin(element) => ::core::fmt::Display::fmt(element, f),
                Self::RequestToJoinAsAdmin(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::RequestToJoinAsForShadowSplicing(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::RequestToJoinAsNode(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::RequestToLeave(element) => ::core::fmt::Display::fmt(element, f),
                Self::RequestToLeaveAsNode(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::SafeTransferFrom(element) => ::core::fmt::Display::fmt(element, f),
                Self::SafeTransferFromWithFromAndToAndData(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::SelfStakeBalanceOf(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::SetApprovalForAll(element) => ::core::fmt::Display::fmt(element, f),
                Self::SetComplaintConfig(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::SetConfig(element) => ::core::fmt::Display::fmt(element, f),
                Self::SetContractResolver(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::SetDemeritRejoinThreshold(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::SetDevopsAdmin(element) => ::core::fmt::Display::fmt(element, f),
                Self::SetEpochEndTime(element) => ::core::fmt::Display::fmt(element, f),
                Self::SetEpochLength(element) => ::core::fmt::Display::fmt(element, f),
                Self::SetEpochState(element) => ::core::fmt::Display::fmt(element, f),
                Self::SetEpochTimeout(element) => ::core::fmt::Display::fmt(element, f),
                Self::SetIpPortNodeAddress(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::SetKeySet(element) => ::core::fmt::Display::fmt(element, f),
                Self::SetLitActionConfig(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::SetMaxVersion(element) => ::core::fmt::Display::fmt(element, f),
                Self::SetMinVersion(element) => ::core::fmt::Display::fmt(element, f),
                Self::SetPendingRejoinTimeout(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::SetPermittedValidators(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::SetPermittedValidatorsOn(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::SetRealmConfig(element) => ::core::fmt::Display::fmt(element, f),
                Self::SetTokenTotalSupplyStandIn(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::SetTrustedForwarder(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::SetUp(element) => ::core::fmt::Display::fmt(element, f),
                Self::SetValidatorCommissionRate(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::ShouldKickValidator(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::SignalReadyForNextEpoch(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::SplitStakeRecord(element) => ::core::fmt::Display::fmt(element, f),
                Self::Stake(element) => ::core::fmt::Display::fmt(element, f),
                Self::StakerToValidatorsTheyStakedTo(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::State(element) => ::core::fmt::Display::fmt(element, f),
                Self::SupportsInterface(element) => ::core::fmt::Display::fmt(element, f),
                Self::TargetArtifactSelectors(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::TargetArtifacts(element) => ::core::fmt::Display::fmt(element, f),
                Self::TargetContracts(element) => ::core::fmt::Display::fmt(element, f),
                Self::TargetInterfaces(element) => ::core::fmt::Display::fmt(element, f),
                Self::TargetSelectors(element) => ::core::fmt::Display::fmt(element, f),
                Self::TargetSenders(element) => ::core::fmt::Display::fmt(element, f),
                Self::TestStake(element) => ::core::fmt::Display::fmt(element, f),
                Self::TestStakeAndTransfer(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::TestStakeAndTransferClaimRewards(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::TestStakeAndTransferReceiverMutatesStakeRecord(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::TestStakeAndTransferRevertNotOwner(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::TestStakeAndTransferTokenOwnerByIndex(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::TestStakeAndTransferWithdraw(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::TestStakeApproveAndTransfer(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::TestStakeApproveForAllAndTransfer(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::TestStakeMaxTransferShouldFail(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::TestStakeMutateStakeRecord(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::TokenOfOwnerByIndex(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::TokenToStakeRecord(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::TotalSupply(element) => ::core::fmt::Display::fmt(element, f),
                Self::TransferFrom(element) => ::core::fmt::Display::fmt(element, f),
                Self::TransferOwnership(element) => ::core::fmt::Display::fmt(element, f),
                Self::UnfreezeStake(element) => ::core::fmt::Display::fmt(element, f),
                Self::ValidatorSelfStakeWillExpire(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::ValidatorByStakerAddress(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::Validators(element) => ::core::fmt::Display::fmt(element, f),
                Self::VerifyKeySetCounts(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::Withdraw(element) => ::core::fmt::Display::fmt(element, f),
            }
        }
    }
    impl ::core::convert::From<IsTestCall> for StakingCalls {
        fn from(value: IsTestCall) -> Self {
            Self::IsTest(value)
        }
    }
    impl ::core::convert::From<GenerateAddressesCall> for StakingCalls {
        fn from(value: GenerateAddressesCall) -> Self {
            Self::GenerateAddresses(value)
        }
    }
    impl ::core::convert::From<GenerateAddressesWithOffsetCall> for StakingCalls {
        fn from(value: GenerateAddressesWithOffsetCall) -> Self {
            Self::GenerateAddressesWithOffset(value)
        }
    }
    impl ::core::convert::From<GeneratePubKeysCall> for StakingCalls {
        fn from(value: GeneratePubKeysCall) -> Self {
            Self::GeneratePubKeys(value)
        }
    }
    impl ::core::convert::From<GenerateUint256SCall> for StakingCalls {
        fn from(value: GenerateUint256SCall) -> Self {
            Self::GenerateUint256S(value)
        }
    }
    impl ::core::convert::From<GenerateUint256SWithOffsetCall> for StakingCalls {
        fn from(value: GenerateUint256SWithOffsetCall) -> Self {
            Self::GenerateUint256SWithOffset(value)
        }
    }
    impl ::core::convert::From<GenerateValidatorsCall> for StakingCalls {
        fn from(value: GenerateValidatorsCall) -> Self {
            Self::GenerateValidators(value)
        }
    }
    impl ::core::convert::From<AddRealmCall> for StakingCalls {
        fn from(value: AddRealmCall) -> Self {
            Self::AddRealm(value)
        }
    }
    impl ::core::convert::From<AdminKickValidatorInNextEpochCall> for StakingCalls {
        fn from(value: AdminKickValidatorInNextEpochCall) -> Self {
            Self::AdminKickValidatorInNextEpoch(value)
        }
    }
    impl ::core::convert::From<AdminRejoinValidatorCall> for StakingCalls {
        fn from(value: AdminRejoinValidatorCall) -> Self {
            Self::AdminRejoinValidator(value)
        }
    }
    impl ::core::convert::From<AdminSetValidatorRegisterAttestedWalletDisabledCall>
    for StakingCalls {
        fn from(value: AdminSetValidatorRegisterAttestedWalletDisabledCall) -> Self {
            Self::AdminSetValidatorRegisterAttestedWalletDisabled(value)
        }
    }
    impl ::core::convert::From<AdminSetValidatorsInCurrentEpochCall> for StakingCalls {
        fn from(value: AdminSetValidatorsInCurrentEpochCall) -> Self {
            Self::AdminSetValidatorsInCurrentEpoch(value)
        }
    }
    impl ::core::convert::From<AdminSetValidatorsInNextEpochCall> for StakingCalls {
        fn from(value: AdminSetValidatorsInNextEpochCall) -> Self {
            Self::AdminSetValidatorsInNextEpoch(value)
        }
    }
    impl ::core::convert::From<AdminSetupShadowSplicingCall> for StakingCalls {
        fn from(value: AdminSetupShadowSplicingCall) -> Self {
            Self::AdminSetupShadowSplicing(value)
        }
    }
    impl ::core::convert::From<AdminSlashValidatorCall> for StakingCalls {
        fn from(value: AdminSlashValidatorCall) -> Self {
            Self::AdminSlashValidator(value)
        }
    }
    impl ::core::convert::From<AdminStakeForUserCall> for StakingCalls {
        fn from(value: AdminStakeForUserCall) -> Self {
            Self::AdminStakeForUser(value)
        }
    }
    impl ::core::convert::From<AdminUnfreezeForUserCall> for StakingCalls {
        fn from(value: AdminUnfreezeForUserCall) -> Self {
            Self::AdminUnfreezeForUser(value)
        }
    }
    impl ::core::convert::From<AdvanceEpochCall> for StakingCalls {
        fn from(value: AdvanceEpochCall) -> Self {
            Self::AdvanceEpoch(value)
        }
    }
    impl ::core::convert::From<ApproveCall> for StakingCalls {
        fn from(value: ApproveCall) -> Self {
            Self::Approve(value)
        }
    }
    impl ::core::convert::From<BalanceOfCall> for StakingCalls {
        fn from(value: BalanceOfCall) -> Self {
            Self::BalanceOf(value)
        }
    }
    impl ::core::convert::From<CalculateRewardsPerDayCall> for StakingCalls {
        fn from(value: CalculateRewardsPerDayCall) -> Self {
            Self::CalculateRewardsPerDay(value)
        }
    }
    impl ::core::convert::From<CalculateStakeWeightCall> for StakingCalls {
        fn from(value: CalculateStakeWeightCall) -> Self {
            Self::CalculateStakeWeight(value)
        }
    }
    impl ::core::convert::From<CheckActiveOrUnlockedOrPausedStateCall> for StakingCalls {
        fn from(value: CheckActiveOrUnlockedOrPausedStateCall) -> Self {
            Self::CheckActiveOrUnlockedOrPausedState(value)
        }
    }
    impl ::core::convert::From<CheckStakingAmountsCall> for StakingCalls {
        fn from(value: CheckStakingAmountsCall) -> Self {
            Self::CheckStakingAmounts(value)
        }
    }
    impl ::core::convert::From<CheckVersionCall> for StakingCalls {
        fn from(value: CheckVersionCall) -> Self {
            Self::CheckVersion(value)
        }
    }
    impl ::core::convert::From<ClaimFixedCostRewardsCall> for StakingCalls {
        fn from(value: ClaimFixedCostRewardsCall) -> Self {
            Self::ClaimFixedCostRewards(value)
        }
    }
    impl ::core::convert::From<ClaimStakeRewardsCall> for StakingCalls {
        fn from(value: ClaimStakeRewardsCall) -> Self {
            Self::ClaimStakeRewards(value)
        }
    }
    impl ::core::convert::From<ClaimValidatorCommissionCall> for StakingCalls {
        fn from(value: ClaimValidatorCommissionCall) -> Self {
            Self::ClaimValidatorCommission(value)
        }
    }
    impl ::core::convert::From<ComplaintConfigCall> for StakingCalls {
        fn from(value: ComplaintConfigCall) -> Self {
            Self::ComplaintConfig(value)
        }
    }
    impl ::core::convert::From<ContractResolverCall> for StakingCalls {
        fn from(value: ContractResolverCall) -> Self {
            Self::ContractResolver(value)
        }
    }
    impl ::core::convert::From<CountOfCurrentValidatorsReadyForNextEpochCall>
    for StakingCalls {
        fn from(value: CountOfCurrentValidatorsReadyForNextEpochCall) -> Self {
            Self::CountOfCurrentValidatorsReadyForNextEpoch(value)
        }
    }
    impl ::core::convert::From<CountOfNextValidatorsReadyForNextEpochCall>
    for StakingCalls {
        fn from(value: CountOfNextValidatorsReadyForNextEpochCall) -> Self {
            Self::CountOfNextValidatorsReadyForNextEpoch(value)
        }
    }
    impl ::core::convert::From<CurrentValidatorCountForConsensusCall> for StakingCalls {
        fn from(value: CurrentValidatorCountForConsensusCall) -> Self {
            Self::CurrentValidatorCountForConsensus(value)
        }
    }
    impl ::core::convert::From<DecreaseRewardPoolCall> for StakingCalls {
        fn from(value: DecreaseRewardPoolCall) -> Self {
            Self::DecreaseRewardPool(value)
        }
    }
    impl ::core::convert::From<DeleteKeySetCall> for StakingCalls {
        fn from(value: DeleteKeySetCall) -> Self {
            Self::DeleteKeySet(value)
        }
    }
    impl ::core::convert::From<DiamondCutCall> for StakingCalls {
        fn from(value: DiamondCutCall) -> Self {
            Self::DiamondCut(value)
        }
    }
    impl ::core::convert::From<EmitClearOfflinePhaseDataCall> for StakingCalls {
        fn from(value: EmitClearOfflinePhaseDataCall) -> Self {
            Self::EmitClearOfflinePhaseData(value)
        }
    }
    impl ::core::convert::From<EmitCountOfflinePhaseDataCall> for StakingCalls {
        fn from(value: EmitCountOfflinePhaseDataCall) -> Self {
            Self::EmitCountOfflinePhaseData(value)
        }
    }
    impl ::core::convert::From<EpochCall> for StakingCalls {
        fn from(value: EpochCall) -> Self {
            Self::Epoch(value)
        }
    }
    impl ::core::convert::From<ExcludeArtifactsCall> for StakingCalls {
        fn from(value: ExcludeArtifactsCall) -> Self {
            Self::ExcludeArtifacts(value)
        }
    }
    impl ::core::convert::From<ExcludeContractsCall> for StakingCalls {
        fn from(value: ExcludeContractsCall) -> Self {
            Self::ExcludeContracts(value)
        }
    }
    impl ::core::convert::From<ExcludeSelectorsCall> for StakingCalls {
        fn from(value: ExcludeSelectorsCall) -> Self {
            Self::ExcludeSelectors(value)
        }
    }
    impl ::core::convert::From<ExcludeSendersCall> for StakingCalls {
        fn from(value: ExcludeSendersCall) -> Self {
            Self::ExcludeSenders(value)
        }
    }
    impl ::core::convert::From<ExitCall> for StakingCalls {
        fn from(value: ExitCall) -> Self {
            Self::Exit(value)
        }
    }
    impl ::core::convert::From<FacetAddressCall> for StakingCalls {
        fn from(value: FacetAddressCall) -> Self {
            Self::FacetAddress(value)
        }
    }
    impl ::core::convert::From<FacetAddressesCall> for StakingCalls {
        fn from(value: FacetAddressesCall) -> Self {
            Self::FacetAddresses(value)
        }
    }
    impl ::core::convert::From<FacetFunctionSelectorsCall> for StakingCalls {
        fn from(value: FacetFunctionSelectorsCall) -> Self {
            Self::FacetFunctionSelectors(value)
        }
    }
    impl ::core::convert::From<FacetsCall> for StakingCalls {
        fn from(value: FacetsCall) -> Self {
            Self::Facets(value)
        }
    }
    impl ::core::convert::From<FailedCall> for StakingCalls {
        fn from(value: FailedCall) -> Self {
            Self::Failed(value)
        }
    }
    impl ::core::convert::From<GetActiveUnkickedValidatorCountCall> for StakingCalls {
        fn from(value: GetActiveUnkickedValidatorCountCall) -> Self {
            Self::GetActiveUnkickedValidatorCount(value)
        }
    }
    impl ::core::convert::From<GetActiveUnkickedValidatorStructsCall> for StakingCalls {
        fn from(value: GetActiveUnkickedValidatorStructsCall) -> Self {
            Self::GetActiveUnkickedValidatorStructs(value)
        }
    }
    impl ::core::convert::From<GetActiveUnkickedValidatorStructsAndCountsCall>
    for StakingCalls {
        fn from(value: GetActiveUnkickedValidatorStructsAndCountsCall) -> Self {
            Self::GetActiveUnkickedValidatorStructsAndCounts(value)
        }
    }
    impl ::core::convert::From<GetActiveUnkickedValidatorsCall> for StakingCalls {
        fn from(value: GetActiveUnkickedValidatorsCall) -> Self {
            Self::GetActiveUnkickedValidators(value)
        }
    }
    impl ::core::convert::From<GetAllReserveValidatorsCall> for StakingCalls {
        fn from(value: GetAllReserveValidatorsCall) -> Self {
            Self::GetAllReserveValidators(value)
        }
    }
    impl ::core::convert::From<GetAllUnkickedValidatorsCall> for StakingCalls {
        fn from(value: GetAllUnkickedValidatorsCall) -> Self {
            Self::GetAllUnkickedValidators(value)
        }
    }
    impl ::core::convert::From<GetAllValidatorsCall> for StakingCalls {
        fn from(value: GetAllValidatorsCall) -> Self {
            Self::GetAllValidators(value)
        }
    }
    impl ::core::convert::From<GetApprovedCall> for StakingCalls {
        fn from(value: GetApprovedCall) -> Self {
            Self::GetApproved(value)
        }
    }
    impl ::core::convert::From<GetAttestedPubKeyCall> for StakingCalls {
        fn from(value: GetAttestedPubKeyCall) -> Self {
            Self::GetAttestedPubKey(value)
        }
    }
    impl ::core::convert::From<GetCurrentRealmIdForStakerAddressCall> for StakingCalls {
        fn from(value: GetCurrentRealmIdForStakerAddressCall) -> Self {
            Self::GetCurrentRealmIdForStakerAddress(value)
        }
    }
    impl ::core::convert::From<GetDelegatedStakersWithUnfreezingStakesCall>
    for StakingCalls {
        fn from(value: GetDelegatedStakersWithUnfreezingStakesCall) -> Self {
            Self::GetDelegatedStakersWithUnfreezingStakes(value)
        }
    }
    impl ::core::convert::From<GetDelegatedStakersWithUnfreezingStakesCountCall>
    for StakingCalls {
        fn from(value: GetDelegatedStakersWithUnfreezingStakesCountCall) -> Self {
            Self::GetDelegatedStakersWithUnfreezingStakesCount(value)
        }
    }
    impl ::core::convert::From<GetEmptyStakeRecordSlotsCall> for StakingCalls {
        fn from(value: GetEmptyStakeRecordSlotsCall) -> Self {
            Self::GetEmptyStakeRecordSlots(value)
        }
    }
    impl ::core::convert::From<GetKeySetCall> for StakingCalls {
        fn from(value: GetKeySetCall) -> Self {
            Self::GetKeySet(value)
        }
    }
    impl ::core::convert::From<GetKeyTypesCall> for StakingCalls {
        fn from(value: GetKeyTypesCall) -> Self {
            Self::GetKeyTypes(value)
        }
    }
    impl ::core::convert::From<GetKickedValidatorsCall> for StakingCalls {
        fn from(value: GetKickedValidatorsCall) -> Self {
            Self::GetKickedValidators(value)
        }
    }
    impl ::core::convert::From<GetLastStakeRecordCall> for StakingCalls {
        fn from(value: GetLastStakeRecordCall) -> Self {
            Self::GetLastStakeRecord(value)
        }
    }
    impl ::core::convert::From<GetLitCircCall> for StakingCalls {
        fn from(value: GetLitCircCall) -> Self {
            Self::GetLitCirc(value)
        }
    }
    impl ::core::convert::From<GetLowestRewardEpochNumberCall> for StakingCalls {
        fn from(value: GetLowestRewardEpochNumberCall) -> Self {
            Self::GetLowestRewardEpochNumber(value)
        }
    }
    impl ::core::convert::From<GetMaxVersionCall> for StakingCalls {
        fn from(value: GetMaxVersionCall) -> Self {
            Self::GetMaxVersion(value)
        }
    }
    impl ::core::convert::From<GetMaxVersionStringCall> for StakingCalls {
        fn from(value: GetMaxVersionStringCall) -> Self {
            Self::GetMaxVersionString(value)
        }
    }
    impl ::core::convert::From<GetMaximumStakeCall> for StakingCalls {
        fn from(value: GetMaximumStakeCall) -> Self {
            Self::GetMaximumStake(value)
        }
    }
    impl ::core::convert::From<GetMinVersionCall> for StakingCalls {
        fn from(value: GetMinVersionCall) -> Self {
            Self::GetMinVersion(value)
        }
    }
    impl ::core::convert::From<GetMinVersionStringCall> for StakingCalls {
        fn from(value: GetMinVersionStringCall) -> Self {
            Self::GetMinVersionString(value)
        }
    }
    impl ::core::convert::From<GetMinimumSelfStakeCall> for StakingCalls {
        fn from(value: GetMinimumSelfStakeCall) -> Self {
            Self::GetMinimumSelfStake(value)
        }
    }
    impl ::core::convert::From<GetMinimumStakeCall> for StakingCalls {
        fn from(value: GetMinimumStakeCall) -> Self {
            Self::GetMinimumStake(value)
        }
    }
    impl ::core::convert::From<GetMostRecentStakeRecordCall> for StakingCalls {
        fn from(value: GetMostRecentStakeRecordCall) -> Self {
            Self::GetMostRecentStakeRecord(value)
        }
    }
    impl ::core::convert::From<GetNodeAttestedPubKeyMappingsCall> for StakingCalls {
        fn from(value: GetNodeAttestedPubKeyMappingsCall) -> Self {
            Self::GetNodeAttestedPubKeyMappings(value)
        }
    }
    impl ::core::convert::From<GetNodeDemeritsCall> for StakingCalls {
        fn from(value: GetNodeDemeritsCall) -> Self {
            Self::GetNodeDemerits(value)
        }
    }
    impl ::core::convert::From<GetNodeStakerAddressMappingsCall> for StakingCalls {
        fn from(value: GetNodeStakerAddressMappingsCall) -> Self {
            Self::GetNodeStakerAddressMappings(value)
        }
    }
    impl ::core::convert::From<GetNonShadowValidatorsCall> for StakingCalls {
        fn from(value: GetNonShadowValidatorsCall) -> Self {
            Self::GetNonShadowValidators(value)
        }
    }
    impl ::core::convert::From<GetNonShadowValidatorsInCurrentEpochLengthCall>
    for StakingCalls {
        fn from(value: GetNonShadowValidatorsInCurrentEpochLengthCall) -> Self {
            Self::GetNonShadowValidatorsInCurrentEpochLength(value)
        }
    }
    impl ::core::convert::From<GetRealmIdForStakerAddressCall> for StakingCalls {
        fn from(value: GetRealmIdForStakerAddressCall) -> Self {
            Self::GetRealmIdForStakerAddress(value)
        }
    }
    impl ::core::convert::From<GetRewardEpochCall> for StakingCalls {
        fn from(value: GetRewardEpochCall) -> Self {
            Self::GetRewardEpoch(value)
        }
    }
    impl ::core::convert::From<GetRewardEpochGlobalStatsCall> for StakingCalls {
        fn from(value: GetRewardEpochGlobalStatsCall) -> Self {
            Self::GetRewardEpochGlobalStats(value)
        }
    }
    impl ::core::convert::From<GetRewardEpochNumberCall> for StakingCalls {
        fn from(value: GetRewardEpochNumberCall) -> Self {
            Self::GetRewardEpochNumber(value)
        }
    }
    impl ::core::convert::From<GetRewardEpochViewCall> for StakingCalls {
        fn from(value: GetRewardEpochViewCall) -> Self {
            Self::GetRewardEpochView(value)
        }
    }
    impl ::core::convert::From<GetSelfStakeRecordCountCall> for StakingCalls {
        fn from(value: GetSelfStakeRecordCountCall) -> Self {
            Self::GetSelfStakeRecordCount(value)
        }
    }
    impl ::core::convert::From<GetShadowRealmIdForStakerAddressCall> for StakingCalls {
        fn from(value: GetShadowRealmIdForStakerAddressCall) -> Self {
            Self::GetShadowRealmIdForStakerAddress(value)
        }
    }
    impl ::core::convert::From<GetShadowValidatorsCall> for StakingCalls {
        fn from(value: GetShadowValidatorsCall) -> Self {
            Self::GetShadowValidators(value)
        }
    }
    impl ::core::convert::From<GetStakeRecordCall> for StakingCalls {
        fn from(value: GetStakeRecordCall) -> Self {
            Self::GetStakeRecord(value)
        }
    }
    impl ::core::convert::From<GetStakeRecordCountCall> for StakingCalls {
        fn from(value: GetStakeRecordCountCall) -> Self {
            Self::GetStakeRecordCount(value)
        }
    }
    impl ::core::convert::From<GetStakeRecordsForUserCall> for StakingCalls {
        fn from(value: GetStakeRecordsForUserCall) -> Self {
            Self::GetStakeRecordsForUser(value)
        }
    }
    impl ::core::convert::From<GetStakeWeightInEpochCall> for StakingCalls {
        fn from(value: GetStakeWeightInEpochCall) -> Self {
            Self::GetStakeWeightInEpoch(value)
        }
    }
    impl ::core::convert::From<GetThresholdCall> for StakingCalls {
        fn from(value: GetThresholdCall) -> Self {
            Self::GetThreshold(value)
        }
    }
    impl ::core::convert::From<GetTimelockInEpochCall> for StakingCalls {
        fn from(value: GetTimelockInEpochCall) -> Self {
            Self::GetTimelockInEpoch(value)
        }
    }
    impl ::core::convert::From<GetTokenContractAddressCall> for StakingCalls {
        fn from(value: GetTokenContractAddressCall) -> Self {
            Self::GetTokenContractAddress(value)
        }
    }
    impl ::core::convert::From<GetTokenPriceCall> for StakingCalls {
        fn from(value: GetTokenPriceCall) -> Self {
            Self::GetTokenPrice(value)
        }
    }
    impl ::core::convert::From<GetTokensStakedCall> for StakingCalls {
        fn from(value: GetTokensStakedCall) -> Self {
            Self::GetTokensStaked(value)
        }
    }
    impl ::core::convert::From<GetTotalStakeCall> for StakingCalls {
        fn from(value: GetTotalStakeCall) -> Self {
            Self::GetTotalStake(value)
        }
    }
    impl ::core::convert::From<GetTotalStakeByUserCall> for StakingCalls {
        fn from(value: GetTotalStakeByUserCall) -> Self {
            Self::GetTotalStakeByUser(value)
        }
    }
    impl ::core::convert::From<GetTrustedForwarderCall> for StakingCalls {
        fn from(value: GetTrustedForwarderCall) -> Self {
            Self::GetTrustedForwarder(value)
        }
    }
    impl ::core::convert::From<GetUnfrozenStakeCountForUserCall> for StakingCalls {
        fn from(value: GetUnfrozenStakeCountForUserCall) -> Self {
            Self::GetUnfrozenStakeCountForUser(value)
        }
    }
    impl ::core::convert::From<GetValidatorsDelegatedCall> for StakingCalls {
        fn from(value: GetValidatorsDelegatedCall) -> Self {
            Self::GetValidatorsDelegated(value)
        }
    }
    impl ::core::convert::From<GetValidatorsInCurrentEpochCall> for StakingCalls {
        fn from(value: GetValidatorsInCurrentEpochCall) -> Self {
            Self::GetValidatorsInCurrentEpoch(value)
        }
    }
    impl ::core::convert::From<GetValidatorsInNextEpochCall> for StakingCalls {
        fn from(value: GetValidatorsInNextEpochCall) -> Self {
            Self::GetValidatorsInNextEpoch(value)
        }
    }
    impl ::core::convert::From<GetValidatorsStructsCall> for StakingCalls {
        fn from(value: GetValidatorsStructsCall) -> Self {
            Self::GetValidatorsStructs(value)
        }
    }
    impl ::core::convert::From<GetValidatorsStructsInCurrentEpochCall> for StakingCalls {
        fn from(value: GetValidatorsStructsInCurrentEpochCall) -> Self {
            Self::GetValidatorsStructsInCurrentEpoch(value)
        }
    }
    impl ::core::convert::From<GetValidatorsStructsInNextEpochCall> for StakingCalls {
        fn from(value: GetValidatorsStructsInNextEpochCall) -> Self {
            Self::GetValidatorsStructsInNextEpoch(value)
        }
    }
    impl ::core::convert::From<GetVotingStatusToKickValidatorCall> for StakingCalls {
        fn from(value: GetVotingStatusToKickValidatorCall) -> Self {
            Self::GetVotingStatusToKickValidator(value)
        }
    }
    impl ::core::convert::From<GlobalConfigCall> for StakingCalls {
        fn from(value: GlobalConfigCall) -> Self {
            Self::GlobalConfig(value)
        }
    }
    impl ::core::convert::From<IncreaseRewardPoolCall> for StakingCalls {
        fn from(value: IncreaseRewardPoolCall) -> Self {
            Self::IncreaseRewardPool(value)
        }
    }
    impl ::core::convert::From<IncreaseStakeRecordAmountCall> for StakingCalls {
        fn from(value: IncreaseStakeRecordAmountCall) -> Self {
            Self::IncreaseStakeRecordAmount(value)
        }
    }
    impl ::core::convert::From<IncreaseStakeRecordTimelockCall> for StakingCalls {
        fn from(value: IncreaseStakeRecordTimelockCall) -> Self {
            Self::IncreaseStakeRecordTimelock(value)
        }
    }
    impl ::core::convert::From<InitializeRewardEpochCall> for StakingCalls {
        fn from(value: InitializeRewardEpochCall) -> Self {
            Self::InitializeRewardEpoch(value)
        }
    }
    impl ::core::convert::From<IsActiveShadowValidatorCall> for StakingCalls {
        fn from(value: IsActiveShadowValidatorCall) -> Self {
            Self::IsActiveShadowValidator(value)
        }
    }
    impl ::core::convert::From<IsActiveValidatorCall> for StakingCalls {
        fn from(value: IsActiveValidatorCall) -> Self {
            Self::IsActiveValidator(value)
        }
    }
    impl ::core::convert::From<IsActiveValidatorByNodeAddressCall> for StakingCalls {
        fn from(value: IsActiveValidatorByNodeAddressCall) -> Self {
            Self::IsActiveValidatorByNodeAddress(value)
        }
    }
    impl ::core::convert::From<IsActiveValidatorByNodeAddressForNextEpochCall>
    for StakingCalls {
        fn from(value: IsActiveValidatorByNodeAddressForNextEpochCall) -> Self {
            Self::IsActiveValidatorByNodeAddressForNextEpoch(value)
        }
    }
    impl ::core::convert::From<IsActiveValidatorForNextEpochCall> for StakingCalls {
        fn from(value: IsActiveValidatorForNextEpochCall) -> Self {
            Self::IsActiveValidatorForNextEpoch(value)
        }
    }
    impl ::core::convert::From<IsApprovedForAllCall> for StakingCalls {
        fn from(value: IsApprovedForAllCall) -> Self {
            Self::IsApprovedForAll(value)
        }
    }
    impl ::core::convert::From<IsReadyForNextEpochCall> for StakingCalls {
        fn from(value: IsReadyForNextEpochCall) -> Self {
            Self::IsReadyForNextEpoch(value)
        }
    }
    impl ::core::convert::From<IsRecentValidatorCall> for StakingCalls {
        fn from(value: IsRecentValidatorCall) -> Self {
            Self::IsRecentValidator(value)
        }
    }
    impl ::core::convert::From<IsRecentValidatorWithRealmIdCall> for StakingCalls {
        fn from(value: IsRecentValidatorWithRealmIdCall) -> Self {
            Self::IsRecentValidatorWithRealmId(value)
        }
    }
    impl ::core::convert::From<IsValidatorBannedCall> for StakingCalls {
        fn from(value: IsValidatorBannedCall) -> Self {
            Self::IsValidatorBanned(value)
        }
    }
    impl ::core::convert::From<IsValidatorInCurrentEpochCall> for StakingCalls {
        fn from(value: IsValidatorInCurrentEpochCall) -> Self {
            Self::IsValidatorInCurrentEpoch(value)
        }
    }
    impl ::core::convert::From<IsValidatorInCurrentOrNextEpochCall> for StakingCalls {
        fn from(value: IsValidatorInCurrentOrNextEpochCall) -> Self {
            Self::IsValidatorInCurrentOrNextEpoch(value)
        }
    }
    impl ::core::convert::From<IsValidatorInNextEpochCall> for StakingCalls {
        fn from(value: IsValidatorInNextEpochCall) -> Self {
            Self::IsValidatorInNextEpoch(value)
        }
    }
    impl ::core::convert::From<KeySetsCall> for StakingCalls {
        fn from(value: KeySetsCall) -> Self {
            Self::KeySets(value)
        }
    }
    impl ::core::convert::From<KickPenaltyPercentByReasonCall> for StakingCalls {
        fn from(value: KickPenaltyPercentByReasonCall) -> Self {
            Self::KickPenaltyPercentByReason(value)
        }
    }
    impl ::core::convert::From<KickValidatorInNextEpochCall> for StakingCalls {
        fn from(value: KickValidatorInNextEpochCall) -> Self {
            Self::KickValidatorInNextEpoch(value)
        }
    }
    impl ::core::convert::From<LitActionsConfigCall> for StakingCalls {
        fn from(value: LitActionsConfigCall) -> Self {
            Self::LitActionsConfig(value)
        }
    }
    impl ::core::convert::From<LockValidatorsForNextEpochCall> for StakingCalls {
        fn from(value: LockValidatorsForNextEpochCall) -> Self {
            Self::LockValidatorsForNextEpoch(value)
        }
    }
    impl ::core::convert::From<MaxStakeCall> for StakingCalls {
        fn from(value: MaxStakeCall) -> Self {
            Self::MaxStake(value)
        }
    }
    impl ::core::convert::From<MaxTimeLockCall> for StakingCalls {
        fn from(value: MaxTimeLockCall) -> Self {
            Self::MaxTimeLock(value)
        }
    }
    impl ::core::convert::From<MigrateStakeRecordCall> for StakingCalls {
        fn from(value: MigrateStakeRecordCall) -> Self {
            Self::MigrateStakeRecord(value)
        }
    }
    impl ::core::convert::From<MinSelfStakeCall> for StakingCalls {
        fn from(value: MinSelfStakeCall) -> Self {
            Self::MinSelfStake(value)
        }
    }
    impl ::core::convert::From<MinStakeCall> for StakingCalls {
        fn from(value: MinStakeCall) -> Self {
            Self::MinStake(value)
        }
    }
    impl ::core::convert::From<MinTimeLockCall> for StakingCalls {
        fn from(value: MinTimeLockCall) -> Self {
            Self::MinTimeLock(value)
        }
    }
    impl ::core::convert::From<NextValidatorCountForConsensusCall> for StakingCalls {
        fn from(value: NextValidatorCountForConsensusCall) -> Self {
            Self::NextValidatorCountForConsensus(value)
        }
    }
    impl ::core::convert::From<NodeAddressToStakerAddressCall> for StakingCalls {
        fn from(value: NodeAddressToStakerAddressCall) -> Self {
            Self::NodeAddressToStakerAddress(value)
        }
    }
    impl ::core::convert::From<NodeAddressToStakerAddressAcrossRealmsCall>
    for StakingCalls {
        fn from(value: NodeAddressToStakerAddressAcrossRealmsCall) -> Self {
            Self::NodeAddressToStakerAddressAcrossRealms(value)
        }
    }
    impl ::core::convert::From<NumRealmsCall> for StakingCalls {
        fn from(value: NumRealmsCall) -> Self {
            Self::NumRealms(value)
        }
    }
    impl ::core::convert::From<OperatorAddressToStakerAddressCall> for StakingCalls {
        fn from(value: OperatorAddressToStakerAddressCall) -> Self {
            Self::OperatorAddressToStakerAddress(value)
        }
    }
    impl ::core::convert::From<OwnerCall> for StakingCalls {
        fn from(value: OwnerCall) -> Self {
            Self::Owner(value)
        }
    }
    impl ::core::convert::From<OwnerOfCall> for StakingCalls {
        fn from(value: OwnerOfCall) -> Self {
            Self::OwnerOf(value)
        }
    }
    impl ::core::convert::From<OwnershipChangeCall> for StakingCalls {
        fn from(value: OwnershipChangeCall) -> Self {
            Self::OwnershipChange(value)
        }
    }
    impl ::core::convert::From<PermittedRealmsForValidatorCall> for StakingCalls {
        fn from(value: PermittedRealmsForValidatorCall) -> Self {
            Self::PermittedRealmsForValidator(value)
        }
    }
    impl ::core::convert::From<PermittedValidatorsCall> for StakingCalls {
        fn from(value: PermittedValidatorsCall) -> Self {
            Self::PermittedValidators(value)
        }
    }
    impl ::core::convert::From<PowCall> for StakingCalls {
        fn from(value: PowCall) -> Self {
            Self::Pow(value)
        }
    }
    impl ::core::convert::From<ReadyForNextEpochCall> for StakingCalls {
        fn from(value: ReadyForNextEpochCall) -> Self {
            Self::ReadyForNextEpoch(value)
        }
    }
    impl ::core::convert::From<RealmConfigCall> for StakingCalls {
        fn from(value: RealmConfigCall) -> Self {
            Self::RealmConfig(value)
        }
    }
    impl ::core::convert::From<RegisterAttestedWalletCall> for StakingCalls {
        fn from(value: RegisterAttestedWalletCall) -> Self {
            Self::RegisterAttestedWallet(value)
        }
    }
    impl ::core::convert::From<RemoveRealmCall> for StakingCalls {
        fn from(value: RemoveRealmCall) -> Self {
            Self::RemoveRealm(value)
        }
    }
    impl ::core::convert::From<RequestToJoinCall> for StakingCalls {
        fn from(value: RequestToJoinCall) -> Self {
            Self::RequestToJoin(value)
        }
    }
    impl ::core::convert::From<RequestToJoinAsAdminCall> for StakingCalls {
        fn from(value: RequestToJoinAsAdminCall) -> Self {
            Self::RequestToJoinAsAdmin(value)
        }
    }
    impl ::core::convert::From<RequestToJoinAsForShadowSplicingCall> for StakingCalls {
        fn from(value: RequestToJoinAsForShadowSplicingCall) -> Self {
            Self::RequestToJoinAsForShadowSplicing(value)
        }
    }
    impl ::core::convert::From<RequestToJoinAsNodeCall> for StakingCalls {
        fn from(value: RequestToJoinAsNodeCall) -> Self {
            Self::RequestToJoinAsNode(value)
        }
    }
    impl ::core::convert::From<RequestToLeaveCall> for StakingCalls {
        fn from(value: RequestToLeaveCall) -> Self {
            Self::RequestToLeave(value)
        }
    }
    impl ::core::convert::From<RequestToLeaveAsNodeCall> for StakingCalls {
        fn from(value: RequestToLeaveAsNodeCall) -> Self {
            Self::RequestToLeaveAsNode(value)
        }
    }
    impl ::core::convert::From<SafeTransferFromCall> for StakingCalls {
        fn from(value: SafeTransferFromCall) -> Self {
            Self::SafeTransferFrom(value)
        }
    }
    impl ::core::convert::From<SafeTransferFromWithFromAndToAndDataCall>
    for StakingCalls {
        fn from(value: SafeTransferFromWithFromAndToAndDataCall) -> Self {
            Self::SafeTransferFromWithFromAndToAndData(value)
        }
    }
    impl ::core::convert::From<SelfStakeBalanceOfCall> for StakingCalls {
        fn from(value: SelfStakeBalanceOfCall) -> Self {
            Self::SelfStakeBalanceOf(value)
        }
    }
    impl ::core::convert::From<SetApprovalForAllCall> for StakingCalls {
        fn from(value: SetApprovalForAllCall) -> Self {
            Self::SetApprovalForAll(value)
        }
    }
    impl ::core::convert::From<SetComplaintConfigCall> for StakingCalls {
        fn from(value: SetComplaintConfigCall) -> Self {
            Self::SetComplaintConfig(value)
        }
    }
    impl ::core::convert::From<SetConfigCall> for StakingCalls {
        fn from(value: SetConfigCall) -> Self {
            Self::SetConfig(value)
        }
    }
    impl ::core::convert::From<SetContractResolverCall> for StakingCalls {
        fn from(value: SetContractResolverCall) -> Self {
            Self::SetContractResolver(value)
        }
    }
    impl ::core::convert::From<SetDemeritRejoinThresholdCall> for StakingCalls {
        fn from(value: SetDemeritRejoinThresholdCall) -> Self {
            Self::SetDemeritRejoinThreshold(value)
        }
    }
    impl ::core::convert::From<SetDevopsAdminCall> for StakingCalls {
        fn from(value: SetDevopsAdminCall) -> Self {
            Self::SetDevopsAdmin(value)
        }
    }
    impl ::core::convert::From<SetEpochEndTimeCall> for StakingCalls {
        fn from(value: SetEpochEndTimeCall) -> Self {
            Self::SetEpochEndTime(value)
        }
    }
    impl ::core::convert::From<SetEpochLengthCall> for StakingCalls {
        fn from(value: SetEpochLengthCall) -> Self {
            Self::SetEpochLength(value)
        }
    }
    impl ::core::convert::From<SetEpochStateCall> for StakingCalls {
        fn from(value: SetEpochStateCall) -> Self {
            Self::SetEpochState(value)
        }
    }
    impl ::core::convert::From<SetEpochTimeoutCall> for StakingCalls {
        fn from(value: SetEpochTimeoutCall) -> Self {
            Self::SetEpochTimeout(value)
        }
    }
    impl ::core::convert::From<SetIpPortNodeAddressCall> for StakingCalls {
        fn from(value: SetIpPortNodeAddressCall) -> Self {
            Self::SetIpPortNodeAddress(value)
        }
    }
    impl ::core::convert::From<SetKeySetCall> for StakingCalls {
        fn from(value: SetKeySetCall) -> Self {
            Self::SetKeySet(value)
        }
    }
    impl ::core::convert::From<SetLitActionConfigCall> for StakingCalls {
        fn from(value: SetLitActionConfigCall) -> Self {
            Self::SetLitActionConfig(value)
        }
    }
    impl ::core::convert::From<SetMaxVersionCall> for StakingCalls {
        fn from(value: SetMaxVersionCall) -> Self {
            Self::SetMaxVersion(value)
        }
    }
    impl ::core::convert::From<SetMinVersionCall> for StakingCalls {
        fn from(value: SetMinVersionCall) -> Self {
            Self::SetMinVersion(value)
        }
    }
    impl ::core::convert::From<SetPendingRejoinTimeoutCall> for StakingCalls {
        fn from(value: SetPendingRejoinTimeoutCall) -> Self {
            Self::SetPendingRejoinTimeout(value)
        }
    }
    impl ::core::convert::From<SetPermittedValidatorsCall> for StakingCalls {
        fn from(value: SetPermittedValidatorsCall) -> Self {
            Self::SetPermittedValidators(value)
        }
    }
    impl ::core::convert::From<SetPermittedValidatorsOnCall> for StakingCalls {
        fn from(value: SetPermittedValidatorsOnCall) -> Self {
            Self::SetPermittedValidatorsOn(value)
        }
    }
    impl ::core::convert::From<SetRealmConfigCall> for StakingCalls {
        fn from(value: SetRealmConfigCall) -> Self {
            Self::SetRealmConfig(value)
        }
    }
    impl ::core::convert::From<SetTokenTotalSupplyStandInCall> for StakingCalls {
        fn from(value: SetTokenTotalSupplyStandInCall) -> Self {
            Self::SetTokenTotalSupplyStandIn(value)
        }
    }
    impl ::core::convert::From<SetTrustedForwarderCall> for StakingCalls {
        fn from(value: SetTrustedForwarderCall) -> Self {
            Self::SetTrustedForwarder(value)
        }
    }
    impl ::core::convert::From<SetUpCall> for StakingCalls {
        fn from(value: SetUpCall) -> Self {
            Self::SetUp(value)
        }
    }
    impl ::core::convert::From<SetValidatorCommissionRateCall> for StakingCalls {
        fn from(value: SetValidatorCommissionRateCall) -> Self {
            Self::SetValidatorCommissionRate(value)
        }
    }
    impl ::core::convert::From<ShouldKickValidatorCall> for StakingCalls {
        fn from(value: ShouldKickValidatorCall) -> Self {
            Self::ShouldKickValidator(value)
        }
    }
    impl ::core::convert::From<SignalReadyForNextEpochCall> for StakingCalls {
        fn from(value: SignalReadyForNextEpochCall) -> Self {
            Self::SignalReadyForNextEpoch(value)
        }
    }
    impl ::core::convert::From<SplitStakeRecordCall> for StakingCalls {
        fn from(value: SplitStakeRecordCall) -> Self {
            Self::SplitStakeRecord(value)
        }
    }
    impl ::core::convert::From<StakeCall> for StakingCalls {
        fn from(value: StakeCall) -> Self {
            Self::Stake(value)
        }
    }
    impl ::core::convert::From<StakerToValidatorsTheyStakedToCall> for StakingCalls {
        fn from(value: StakerToValidatorsTheyStakedToCall) -> Self {
            Self::StakerToValidatorsTheyStakedTo(value)
        }
    }
    impl ::core::convert::From<StateCall> for StakingCalls {
        fn from(value: StateCall) -> Self {
            Self::State(value)
        }
    }
    impl ::core::convert::From<SupportsInterfaceCall> for StakingCalls {
        fn from(value: SupportsInterfaceCall) -> Self {
            Self::SupportsInterface(value)
        }
    }
    impl ::core::convert::From<TargetArtifactSelectorsCall> for StakingCalls {
        fn from(value: TargetArtifactSelectorsCall) -> Self {
            Self::TargetArtifactSelectors(value)
        }
    }
    impl ::core::convert::From<TargetArtifactsCall> for StakingCalls {
        fn from(value: TargetArtifactsCall) -> Self {
            Self::TargetArtifacts(value)
        }
    }
    impl ::core::convert::From<TargetContractsCall> for StakingCalls {
        fn from(value: TargetContractsCall) -> Self {
            Self::TargetContracts(value)
        }
    }
    impl ::core::convert::From<TargetInterfacesCall> for StakingCalls {
        fn from(value: TargetInterfacesCall) -> Self {
            Self::TargetInterfaces(value)
        }
    }
    impl ::core::convert::From<TargetSelectorsCall> for StakingCalls {
        fn from(value: TargetSelectorsCall) -> Self {
            Self::TargetSelectors(value)
        }
    }
    impl ::core::convert::From<TargetSendersCall> for StakingCalls {
        fn from(value: TargetSendersCall) -> Self {
            Self::TargetSenders(value)
        }
    }
    impl ::core::convert::From<TestStakeCall> for StakingCalls {
        fn from(value: TestStakeCall) -> Self {
            Self::TestStake(value)
        }
    }
    impl ::core::convert::From<TestStakeAndTransferCall> for StakingCalls {
        fn from(value: TestStakeAndTransferCall) -> Self {
            Self::TestStakeAndTransfer(value)
        }
    }
    impl ::core::convert::From<TestStakeAndTransferClaimRewardsCall> for StakingCalls {
        fn from(value: TestStakeAndTransferClaimRewardsCall) -> Self {
            Self::TestStakeAndTransferClaimRewards(value)
        }
    }
    impl ::core::convert::From<TestStakeAndTransferReceiverMutatesStakeRecordCall>
    for StakingCalls {
        fn from(value: TestStakeAndTransferReceiverMutatesStakeRecordCall) -> Self {
            Self::TestStakeAndTransferReceiverMutatesStakeRecord(value)
        }
    }
    impl ::core::convert::From<TestStakeAndTransferRevertNotOwnerCall> for StakingCalls {
        fn from(value: TestStakeAndTransferRevertNotOwnerCall) -> Self {
            Self::TestStakeAndTransferRevertNotOwner(value)
        }
    }
    impl ::core::convert::From<TestStakeAndTransferTokenOwnerByIndexCall>
    for StakingCalls {
        fn from(value: TestStakeAndTransferTokenOwnerByIndexCall) -> Self {
            Self::TestStakeAndTransferTokenOwnerByIndex(value)
        }
    }
    impl ::core::convert::From<TestStakeAndTransferWithdrawCall> for StakingCalls {
        fn from(value: TestStakeAndTransferWithdrawCall) -> Self {
            Self::TestStakeAndTransferWithdraw(value)
        }
    }
    impl ::core::convert::From<TestStakeApproveAndTransferCall> for StakingCalls {
        fn from(value: TestStakeApproveAndTransferCall) -> Self {
            Self::TestStakeApproveAndTransfer(value)
        }
    }
    impl ::core::convert::From<TestStakeApproveForAllAndTransferCall> for StakingCalls {
        fn from(value: TestStakeApproveForAllAndTransferCall) -> Self {
            Self::TestStakeApproveForAllAndTransfer(value)
        }
    }
    impl ::core::convert::From<TestStakeMaxTransferShouldFailCall> for StakingCalls {
        fn from(value: TestStakeMaxTransferShouldFailCall) -> Self {
            Self::TestStakeMaxTransferShouldFail(value)
        }
    }
    impl ::core::convert::From<TestStakeMutateStakeRecordCall> for StakingCalls {
        fn from(value: TestStakeMutateStakeRecordCall) -> Self {
            Self::TestStakeMutateStakeRecord(value)
        }
    }
    impl ::core::convert::From<TokenOfOwnerByIndexCall> for StakingCalls {
        fn from(value: TokenOfOwnerByIndexCall) -> Self {
            Self::TokenOfOwnerByIndex(value)
        }
    }
    impl ::core::convert::From<TokenToStakeRecordCall> for StakingCalls {
        fn from(value: TokenToStakeRecordCall) -> Self {
            Self::TokenToStakeRecord(value)
        }
    }
    impl ::core::convert::From<TotalSupplyCall> for StakingCalls {
        fn from(value: TotalSupplyCall) -> Self {
            Self::TotalSupply(value)
        }
    }
    impl ::core::convert::From<TransferFromCall> for StakingCalls {
        fn from(value: TransferFromCall) -> Self {
            Self::TransferFrom(value)
        }
    }
    impl ::core::convert::From<TransferOwnershipCall> for StakingCalls {
        fn from(value: TransferOwnershipCall) -> Self {
            Self::TransferOwnership(value)
        }
    }
    impl ::core::convert::From<UnfreezeStakeCall> for StakingCalls {
        fn from(value: UnfreezeStakeCall) -> Self {
            Self::UnfreezeStake(value)
        }
    }
    impl ::core::convert::From<ValidatorSelfStakeWillExpireCall> for StakingCalls {
        fn from(value: ValidatorSelfStakeWillExpireCall) -> Self {
            Self::ValidatorSelfStakeWillExpire(value)
        }
    }
    impl ::core::convert::From<ValidatorByStakerAddressCall> for StakingCalls {
        fn from(value: ValidatorByStakerAddressCall) -> Self {
            Self::ValidatorByStakerAddress(value)
        }
    }
    impl ::core::convert::From<ValidatorsCall> for StakingCalls {
        fn from(value: ValidatorsCall) -> Self {
            Self::Validators(value)
        }
    }
    impl ::core::convert::From<VerifyKeySetCountsCall> for StakingCalls {
        fn from(value: VerifyKeySetCountsCall) -> Self {
            Self::VerifyKeySetCounts(value)
        }
    }
    impl ::core::convert::From<WithdrawCall> for StakingCalls {
        fn from(value: WithdrawCall) -> Self {
            Self::Withdraw(value)
        }
    }
    ///Container type for all return fields from the `IS_TEST` function with signature `IS_TEST()` and selector `0xfa7626d4`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct IsTestReturn(pub bool);
    ///Container type for all return fields from the `_generateAddresses` function with signature `_generateAddresses(uint256)` and selector `0x678ac78a`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct GenerateAddressesReturn(
        pub ::std::vec::Vec<::ethers::core::types::Address>,
    );
    ///Container type for all return fields from the `_generateAddressesWithOffset` function with signature `_generateAddressesWithOffset(uint256,uint256)` and selector `0xa5187b2b`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct GenerateAddressesWithOffsetReturn(
        pub ::std::vec::Vec<::ethers::core::types::Address>,
    );
    ///Container type for all return fields from the `_generatePubKeys` function with signature `_generatePubKeys(uint256)` and selector `0xfed0a77b`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct GeneratePubKeysReturn(pub ::std::vec::Vec<::ethers::core::types::Bytes>);
    ///Container type for all return fields from the `_generateUint256s` function with signature `_generateUint256s(uint256)` and selector `0xae517f4d`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct GenerateUint256SReturn(pub ::std::vec::Vec<::ethers::core::types::U256>);
    ///Container type for all return fields from the `_generateUint256sWithOffset` function with signature `_generateUint256sWithOffset(uint256,uint256)` and selector `0xfb9d55b8`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct GenerateUint256SWithOffsetReturn(
        pub ::std::vec::Vec<::ethers::core::types::U256>,
    );
    ///Container type for all return fields from the `_generateValidators` function with signature `_generateValidators(uint256)` and selector `0xc5344d40`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct GenerateValidatorsReturn(pub ::std::vec::Vec<TestValidator>);
    ///Container type for all return fields from the `addRealm` function with signature `addRealm()` and selector `0x472a7d89`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct AddRealmReturn {
        pub realm_id: ::ethers::core::types::U256,
    }
    ///Container type for all return fields from the `balanceOf` function with signature `balanceOf(address)` and selector `0x70a08231`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct BalanceOfReturn(pub ::ethers::core::types::U256);
    ///Container type for all return fields from the `calculateRewardsPerDay` function with signature `calculateRewardsPerDay((uint256,uint256,address[],uint256))` and selector `0x9be372e0`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct CalculateRewardsPerDayReturn(pub ::ethers::core::types::U256);
    ///Container type for all return fields from the `calculateStakeWeight` function with signature `calculateStakeWeight(uint256,uint256)` and selector `0x2b7c29e3`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct CalculateStakeWeightReturn(pub ::ethers::core::types::U256);
    ///Container type for all return fields from the `checkStakingAmounts` function with signature `checkStakingAmounts(address)` and selector `0x49919966`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct CheckStakingAmountsReturn(pub bool);
    ///Container type for all return fields from the `checkVersion` function with signature `checkVersion(uint256,(uint256,uint256,uint256))` and selector `0xcffbfc20`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct CheckVersionReturn(pub bool);
    ///Container type for all return fields from the `complaintConfig` function with signature `complaintConfig(uint256)` and selector `0x02f6da56`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct ComplaintConfigReturn(pub ComplaintConfig);
    ///Container type for all return fields from the `contractResolver` function with signature `contractResolver()` and selector `0x50d17b5e`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct ContractResolverReturn(pub ::ethers::core::types::Address);
    ///Container type for all return fields from the `countOfCurrentValidatorsReadyForNextEpoch` function with signature `countOfCurrentValidatorsReadyForNextEpoch(uint256)` and selector `0x31232f31`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct CountOfCurrentValidatorsReadyForNextEpochReturn(
        pub ::ethers::core::types::U256,
    );
    ///Container type for all return fields from the `countOfNextValidatorsReadyForNextEpoch` function with signature `countOfNextValidatorsReadyForNextEpoch(uint256)` and selector `0xdce6f078`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct CountOfNextValidatorsReadyForNextEpochReturn(
        pub ::ethers::core::types::U256,
    );
    ///Container type for all return fields from the `currentValidatorCountForConsensus` function with signature `currentValidatorCountForConsensus(uint256)` and selector `0x9423f589`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct CurrentValidatorCountForConsensusReturn(pub ::ethers::core::types::U256);
    ///Container type for all return fields from the `epoch` function with signature `epoch(uint256)` and selector `0x5487c577`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct EpochReturn(pub Epoch);
    ///Container type for all return fields from the `excludeArtifacts` function with signature `excludeArtifacts()` and selector `0xb5508aa9`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct ExcludeArtifactsReturn {
        pub excluded_artifacts: ::std::vec::Vec<::std::string::String>,
    }
    ///Container type for all return fields from the `excludeContracts` function with signature `excludeContracts()` and selector `0xe20c9f71`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct ExcludeContractsReturn {
        pub excluded_contracts: ::std::vec::Vec<::ethers::core::types::Address>,
    }
    ///Container type for all return fields from the `excludeSelectors` function with signature `excludeSelectors()` and selector `0xb0464fdc`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct ExcludeSelectorsReturn {
        pub excluded_selectors: ::std::vec::Vec<FuzzSelector>,
    }
    ///Container type for all return fields from the `excludeSenders` function with signature `excludeSenders()` and selector `0x1ed7831c`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct ExcludeSendersReturn {
        pub excluded_senders: ::std::vec::Vec<::ethers::core::types::Address>,
    }
    ///Container type for all return fields from the `facetAddress` function with signature `facetAddress(bytes4)` and selector `0xcdffacc6`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct FacetAddressReturn {
        pub facet_address: ::ethers::core::types::Address,
    }
    ///Container type for all return fields from the `facetAddresses` function with signature `facetAddresses()` and selector `0x52ef6b2c`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct FacetAddressesReturn {
        pub facet_addresses: ::std::vec::Vec<::ethers::core::types::Address>,
    }
    ///Container type for all return fields from the `facetFunctionSelectors` function with signature `facetFunctionSelectors(address)` and selector `0xadfca15e`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct FacetFunctionSelectorsReturn {
        pub facet_function_selectors: ::std::vec::Vec<[u8; 4]>,
    }
    ///Container type for all return fields from the `facets` function with signature `facets()` and selector `0x7a0ed627`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct FacetsReturn {
        pub facets: ::std::vec::Vec<Facet>,
    }
    ///Container type for all return fields from the `failed` function with signature `failed()` and selector `0xba414fa6`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct FailedReturn(pub bool);
    ///Container type for all return fields from the `getActiveUnkickedValidatorCount` function with signature `getActiveUnkickedValidatorCount(uint256)` and selector `0x7a808c0d`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct GetActiveUnkickedValidatorCountReturn(pub ::ethers::core::types::U256);
    ///Container type for all return fields from the `getActiveUnkickedValidatorStructs` function with signature `getActiveUnkickedValidatorStructs(uint256)` and selector `0xe4ccc020`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
    )]
    pub struct GetActiveUnkickedValidatorStructsReturn(pub ::std::vec::Vec<Validator>);
    ///Container type for all return fields from the `getActiveUnkickedValidatorStructsAndCounts` function with signature `getActiveUnkickedValidatorStructsAndCounts(uint256)` and selector `0xd09cd5a8`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
    )]
    pub struct GetActiveUnkickedValidatorStructsAndCountsReturn(
        pub Epoch,
        pub ::ethers::core::types::U256,
        pub ::std::vec::Vec<Validator>,
    );
    ///Container type for all return fields from the `getActiveUnkickedValidators` function with signature `getActiveUnkickedValidators(uint256)` and selector `0x8b6de0d1`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct GetActiveUnkickedValidatorsReturn(
        pub ::std::vec::Vec<::ethers::core::types::Address>,
    );
    ///Container type for all return fields from the `getAllReserveValidators` function with signature `getAllReserveValidators()` and selector `0xbd8578d6`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct GetAllReserveValidatorsReturn(
        pub ::std::vec::Vec<::ethers::core::types::Address>,
    );
    ///Container type for all return fields from the `getAllUnkickedValidators` function with signature `getAllUnkickedValidators()` and selector `0x0df47a24`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct GetAllUnkickedValidatorsReturn(
        pub ::std::vec::Vec<::ethers::core::types::Address>,
    );
    ///Container type for all return fields from the `getAllValidators` function with signature `getAllValidators()` and selector `0xf3513a37`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct GetAllValidatorsReturn(
        pub ::std::vec::Vec<::ethers::core::types::Address>,
    );
    ///Container type for all return fields from the `getApproved` function with signature `getApproved(uint256)` and selector `0x081812fc`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct GetApprovedReturn(pub ::ethers::core::types::Address);
    ///Container type for all return fields from the `getAttestedPubKey` function with signature `getAttestedPubKey(address)` and selector `0xe9332ea7`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct GetAttestedPubKeyReturn(pub ::ethers::core::types::Bytes);
    ///Container type for all return fields from the `getCurrentRealmIdForStakerAddress` function with signature `getCurrentRealmIdForStakerAddress(address)` and selector `0x88de4e25`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct GetCurrentRealmIdForStakerAddressReturn(pub ::ethers::core::types::U256);
    ///Container type for all return fields from the `getDelegatedStakersWithUnfreezingStakes` function with signature `getDelegatedStakersWithUnfreezingStakes(address,uint256,uint256)` and selector `0x9fe51529`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct GetDelegatedStakersWithUnfreezingStakesReturn(
        pub ::std::vec::Vec<::ethers::core::types::Address>,
    );
    ///Container type for all return fields from the `getDelegatedStakersWithUnfreezingStakesCount` function with signature `getDelegatedStakersWithUnfreezingStakesCount(address)` and selector `0x8c3ccf4c`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct GetDelegatedStakersWithUnfreezingStakesCountReturn(
        pub ::ethers::core::types::U256,
    );
    ///Container type for all return fields from the `getEmptyStakeRecordSlots` function with signature `getEmptyStakeRecordSlots(address,address)` and selector `0xa6f67c51`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct GetEmptyStakeRecordSlotsReturn(pub ::ethers::core::types::U256);
    ///Container type for all return fields from the `getKeySet` function with signature `getKeySet(string)` and selector `0xa305e5fe`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct GetKeySetReturn(pub KeySetConfig);
    ///Container type for all return fields from the `getKeyTypes` function with signature `getKeyTypes()` and selector `0xf1b877a8`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct GetKeyTypesReturn(pub ::std::vec::Vec<::ethers::core::types::U256>);
    ///Container type for all return fields from the `getKickedValidators` function with signature `getKickedValidators(uint256)` and selector `0x4b6afbbb`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct GetKickedValidatorsReturn(
        pub ::std::vec::Vec<::ethers::core::types::Address>,
    );
    ///Container type for all return fields from the `getLastStakeRecord` function with signature `getLastStakeRecord(address,address)` and selector `0xfc73fb85`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct GetLastStakeRecordReturn(pub StakeRecord);
    ///Container type for all return fields from the `getLitCirc` function with signature `getLitCirc()` and selector `0xebc17602`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct GetLitCircReturn(pub ::ethers::core::types::U256);
    ///Container type for all return fields from the `getLowestRewardEpochNumber` function with signature `getLowestRewardEpochNumber()` and selector `0x3866c0ef`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct GetLowestRewardEpochNumberReturn(
        pub ::ethers::core::types::U256,
        pub ::ethers::core::types::U256,
    );
    ///Container type for all return fields from the `getMaxVersion` function with signature `getMaxVersion(uint256)` and selector `0x73dd15ac`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct GetMaxVersionReturn(pub Version);
    ///Container type for all return fields from the `getMaxVersionString` function with signature `getMaxVersionString(uint256)` and selector `0x64a481f5`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct GetMaxVersionStringReturn(pub ::std::string::String);
    ///Container type for all return fields from the `getMaximumStake` function with signature `getMaximumStake()` and selector `0x468a4883`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct GetMaximumStakeReturn(pub ::ethers::core::types::U256);
    ///Container type for all return fields from the `getMinVersion` function with signature `getMinVersion(uint256)` and selector `0x18443e59`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct GetMinVersionReturn(pub Version);
    ///Container type for all return fields from the `getMinVersionString` function with signature `getMinVersionString(uint256)` and selector `0xf57610e3`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct GetMinVersionStringReturn(pub ::std::string::String);
    ///Container type for all return fields from the `getMinimumSelfStake` function with signature `getMinimumSelfStake()` and selector `0x8bc97a37`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct GetMinimumSelfStakeReturn(pub ::ethers::core::types::U256);
    ///Container type for all return fields from the `getMinimumStake` function with signature `getMinimumStake()` and selector `0xd9bbd278`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct GetMinimumStakeReturn(pub ::ethers::core::types::U256);
    ///Container type for all return fields from the `getMostRecentStakeRecord` function with signature `getMostRecentStakeRecord(address,address)` and selector `0x7d0f412f`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct GetMostRecentStakeRecordReturn(pub StakeRecord);
    ///Container type for all return fields from the `getNodeAttestedPubKeyMappings` function with signature `getNodeAttestedPubKeyMappings(address[])` and selector `0x88790aee`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct GetNodeAttestedPubKeyMappingsReturn(pub ::std::vec::Vec<PubKeyMapping>);
    ///Container type for all return fields from the `getNodeDemerits` function with signature `getNodeDemerits(address)` and selector `0xa8d6cedd`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct GetNodeDemeritsReturn(pub ::ethers::core::types::U256);
    ///Container type for all return fields from the `getNodeStakerAddressMappings` function with signature `getNodeStakerAddressMappings(address[])` and selector `0x90fba112`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct GetNodeStakerAddressMappingsReturn(pub ::std::vec::Vec<AddressMapping>);
    ///Container type for all return fields from the `getNonShadowValidators` function with signature `getNonShadowValidators(uint256)` and selector `0x65e3dcf6`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct GetNonShadowValidatorsReturn(
        pub ::std::vec::Vec<::ethers::core::types::Address>,
    );
    ///Container type for all return fields from the `getNonShadowValidatorsInCurrentEpochLength` function with signature `getNonShadowValidatorsInCurrentEpochLength(uint256)` and selector `0x399ebc13`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct GetNonShadowValidatorsInCurrentEpochLengthReturn(
        pub ::ethers::core::types::U256,
    );
    ///Container type for all return fields from the `getRealmIdForStakerAddress` function with signature `getRealmIdForStakerAddress(address)` and selector `0xaa3bed0b`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct GetRealmIdForStakerAddressReturn(pub ::ethers::core::types::U256);
    ///Container type for all return fields from the `getRewardEpoch` function with signature `getRewardEpoch(address,uint256)` and selector `0x7e867f87`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct GetRewardEpochReturn(pub RewardEpoch);
    ///Container type for all return fields from the `getRewardEpochGlobalStats` function with signature `getRewardEpochGlobalStats(uint256)` and selector `0x2c9d1844`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct GetRewardEpochGlobalStatsReturn(pub RewardEpochGlobalStats);
    ///Container type for all return fields from the `getRewardEpochNumber` function with signature `getRewardEpochNumber(uint256)` and selector `0xba1d8fef`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct GetRewardEpochNumberReturn(pub ::ethers::core::types::U256);
    ///Container type for all return fields from the `getRewardEpochView` function with signature `getRewardEpochView(address,uint256)` and selector `0x709fe8a3`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct GetRewardEpochViewReturn(pub RewardEpoch);
    ///Container type for all return fields from the `getSelfStakeRecordCount` function with signature `getSelfStakeRecordCount(address)` and selector `0x01362dc3`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct GetSelfStakeRecordCountReturn(pub ::ethers::core::types::U256);
    ///Container type for all return fields from the `getShadowRealmIdForStakerAddress` function with signature `getShadowRealmIdForStakerAddress(address)` and selector `0x455636de`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct GetShadowRealmIdForStakerAddressReturn(pub ::ethers::core::types::U256);
    ///Container type for all return fields from the `getShadowValidators` function with signature `getShadowValidators(uint256)` and selector `0xcc090c8a`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct GetShadowValidatorsReturn(
        pub ::std::vec::Vec<::ethers::core::types::Address>,
    );
    ///Container type for all return fields from the `getStakeRecord` function with signature `getStakeRecord(address,uint256,address)` and selector `0x114ed11d`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct GetStakeRecordReturn(pub StakeRecord);
    ///Container type for all return fields from the `getStakeRecordCount` function with signature `getStakeRecordCount(address,address)` and selector `0x125fc3d4`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct GetStakeRecordCountReturn(pub ::ethers::core::types::U256);
    ///Container type for all return fields from the `getStakeRecordsForUser` function with signature `getStakeRecordsForUser(address,address)` and selector `0xdc1fab7f`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct GetStakeRecordsForUserReturn(pub ::std::vec::Vec<StakeRecord>);
    ///Container type for all return fields from the `getStakeWeightInEpoch` function with signature `getStakeWeightInEpoch(address,uint256,address,uint256)` and selector `0x580f68db`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct GetStakeWeightInEpochReturn(pub ::ethers::core::types::U256);
    ///Container type for all return fields from the `getThreshold` function with signature `getThreshold(uint256)` and selector `0x4615d5e9`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct GetThresholdReturn(pub ::ethers::core::types::U256);
    ///Container type for all return fields from the `getTimelockInEpoch` function with signature `getTimelockInEpoch(address,(uint256,uint256,uint256,uint256,uint256,uint256,uint256,bool,bool,address,uint256),uint256)` and selector `0x2db912e4`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct GetTimelockInEpochReturn(pub ::ethers::core::types::U256);
    ///Container type for all return fields from the `getTokenContractAddress` function with signature `getTokenContractAddress()` and selector `0x22e45584`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct GetTokenContractAddressReturn(pub ::ethers::core::types::Address);
    ///Container type for all return fields from the `getTokenPrice` function with signature `getTokenPrice()` and selector `0x4b94f50e`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct GetTokenPriceReturn(pub ::ethers::core::types::U256);
    ///Container type for all return fields from the `getTokensStaked` function with signature `getTokensStaked(address,(uint256,uint256,uint256,uint256,uint256,uint256,uint256,bool,bool,address,uint256),uint256)` and selector `0x0fd78304`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct GetTokensStakedReturn(pub ::ethers::core::types::U256);
    ///Container type for all return fields from the `getTotalStake` function with signature `getTotalStake(address)` and selector `0x1e7ff8f6`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct GetTotalStakeReturn(
        pub ::ethers::core::types::U256,
        pub ::ethers::core::types::U256,
    );
    ///Container type for all return fields from the `getTotalStakeByUser` function with signature `getTotalStakeByUser(address,address)` and selector `0xd349660a`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct GetTotalStakeByUserReturn(
        pub ::ethers::core::types::U256,
        pub ::ethers::core::types::U256,
    );
    ///Container type for all return fields from the `getTrustedForwarder` function with signature `getTrustedForwarder()` and selector `0xce1b815f`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct GetTrustedForwarderReturn(pub ::ethers::core::types::Address);
    ///Container type for all return fields from the `getUnfrozenStakeCountForUser` function with signature `getUnfrozenStakeCountForUser(address,address)` and selector `0x5a0909fa`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct GetUnfrozenStakeCountForUserReturn(pub ::ethers::core::types::U256);
    ///Container type for all return fields from the `getValidatorsDelegated` function with signature `getValidatorsDelegated(address)` and selector `0x5b2fcdcf`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct GetValidatorsDelegatedReturn(
        pub ::std::vec::Vec<::ethers::core::types::U256>,
    );
    ///Container type for all return fields from the `getValidatorsInCurrentEpoch` function with signature `getValidatorsInCurrentEpoch(uint256)` and selector `0xeccd9e0e`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct GetValidatorsInCurrentEpochReturn(
        pub ::std::vec::Vec<::ethers::core::types::Address>,
    );
    ///Container type for all return fields from the `getValidatorsInNextEpoch` function with signature `getValidatorsInNextEpoch(uint256)` and selector `0x84bc5324`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct GetValidatorsInNextEpochReturn(
        pub ::std::vec::Vec<::ethers::core::types::Address>,
    );
    ///Container type for all return fields from the `getValidatorsStructs` function with signature `getValidatorsStructs(address[])` and selector `0x533d463e`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
    )]
    pub struct GetValidatorsStructsReturn(pub ::std::vec::Vec<Validator>);
    ///Container type for all return fields from the `getValidatorsStructsInCurrentEpoch` function with signature `getValidatorsStructsInCurrentEpoch(uint256)` and selector `0xb0dee6c6`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
    )]
    pub struct GetValidatorsStructsInCurrentEpochReturn(pub ::std::vec::Vec<Validator>);
    ///Container type for all return fields from the `getValidatorsStructsInNextEpoch` function with signature `getValidatorsStructsInNextEpoch(uint256)` and selector `0x183c5ff0`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
    )]
    pub struct GetValidatorsStructsInNextEpochReturn(pub ::std::vec::Vec<Validator>);
    ///Container type for all return fields from the `getVotingStatusToKickValidator` function with signature `getVotingStatusToKickValidator(uint256,uint256,address,address)` and selector `0x3e1c3693`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct GetVotingStatusToKickValidatorReturn(
        pub ::ethers::core::types::U256,
        pub bool,
    );
    ///Container type for all return fields from the `globalConfig` function with signature `globalConfig()` and selector `0xa7c1abe0`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
    )]
    pub struct GlobalConfigReturn(pub GlobalConfig);
    ///Container type for all return fields from the `isActiveShadowValidator` function with signature `isActiveShadowValidator(uint256,address)` and selector `0x7e7ae34c`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct IsActiveShadowValidatorReturn(pub bool);
    ///Container type for all return fields from the `isActiveValidator` function with signature `isActiveValidator(uint256,address)` and selector `0xff347ae8`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct IsActiveValidatorReturn(pub bool);
    ///Container type for all return fields from the `isActiveValidatorByNodeAddress` function with signature `isActiveValidatorByNodeAddress(uint256,address)` and selector `0x5064c127`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct IsActiveValidatorByNodeAddressReturn(pub bool);
    ///Container type for all return fields from the `isActiveValidatorByNodeAddressForNextEpoch` function with signature `isActiveValidatorByNodeAddressForNextEpoch(uint256,address)` and selector `0xeb8f2f27`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct IsActiveValidatorByNodeAddressForNextEpochReturn(pub bool);
    ///Container type for all return fields from the `isActiveValidatorForNextEpoch` function with signature `isActiveValidatorForNextEpoch(uint256,address)` and selector `0x26fc6f9b`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct IsActiveValidatorForNextEpochReturn(pub bool);
    ///Container type for all return fields from the `isApprovedForAll` function with signature `isApprovedForAll(address,address)` and selector `0xe985e9c5`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct IsApprovedForAllReturn(pub bool);
    ///Container type for all return fields from the `isReadyForNextEpoch` function with signature `isReadyForNextEpoch(uint256)` and selector `0x7fecc451`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct IsReadyForNextEpochReturn(pub bool);
    ///Container type for all return fields from the `isRecentValidator` function with signature `isRecentValidator(address)` and selector `0x3c2ef732`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct IsRecentValidatorReturn(pub bool);
    ///Container type for all return fields from the `isRecentValidator` function with signature `isRecentValidator(uint256,address)` and selector `0xc974c355`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct IsRecentValidatorWithRealmIdReturn(pub bool);
    ///Container type for all return fields from the `isValidatorBanned` function with signature `isValidatorBanned(address)` and selector `0xa92252ae`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct IsValidatorBannedReturn(pub bool);
    ///Container type for all return fields from the `isValidatorInCurrentEpoch` function with signature `isValidatorInCurrentEpoch(address)` and selector `0xdf8a171f`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct IsValidatorInCurrentEpochReturn(pub bool);
    ///Container type for all return fields from the `isValidatorInCurrentOrNextEpoch` function with signature `isValidatorInCurrentOrNextEpoch(address)` and selector `0x81b9beb7`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct IsValidatorInCurrentOrNextEpochReturn(pub bool);
    ///Container type for all return fields from the `isValidatorInNextEpoch` function with signature `isValidatorInNextEpoch(address)` and selector `0xad0466a6`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct IsValidatorInNextEpochReturn(pub bool);
    ///Container type for all return fields from the `keySets` function with signature `keySets()` and selector `0xdce90405`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct KeySetsReturn(pub ::std::vec::Vec<KeySetConfig>);
    ///Container type for all return fields from the `kickPenaltyPercentByReason` function with signature `kickPenaltyPercentByReason(uint256)` and selector `0x3e685266`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct KickPenaltyPercentByReasonReturn(pub ::ethers::core::types::U256);
    ///Container type for all return fields from the `litActionsConfig` function with signature `litActionsConfig(uint256)` and selector `0xe3dfd1f5`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct LitActionsConfigReturn(pub LitActionConfig);
    ///Container type for all return fields from the `maxStake` function with signature `maxStake()` and selector `0xea1b28e0`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct MaxStakeReturn(pub ::ethers::core::types::U256);
    ///Container type for all return fields from the `maxTimeLock` function with signature `maxTimeLock()` and selector `0xe1cf73b9`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct MaxTimeLockReturn(pub ::ethers::core::types::U256);
    ///Container type for all return fields from the `minSelfStake` function with signature `minSelfStake()` and selector `0xc5f530af`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct MinSelfStakeReturn(pub ::ethers::core::types::U256);
    ///Container type for all return fields from the `minStake` function with signature `minStake()` and selector `0x375b3c0a`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct MinStakeReturn(pub ::ethers::core::types::U256);
    ///Container type for all return fields from the `minTimeLock` function with signature `minTimeLock()` and selector `0xd00a818f`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct MinTimeLockReturn(pub ::ethers::core::types::U256);
    ///Container type for all return fields from the `nextValidatorCountForConsensus` function with signature `nextValidatorCountForConsensus(uint256)` and selector `0xa8b89564`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct NextValidatorCountForConsensusReturn(pub ::ethers::core::types::U256);
    ///Container type for all return fields from the `nodeAddressToStakerAddress` function with signature `nodeAddressToStakerAddress(address)` and selector `0x5081f66f`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct NodeAddressToStakerAddressReturn(pub ::ethers::core::types::Address);
    ///Container type for all return fields from the `nodeAddressToStakerAddressAcrossRealms` function with signature `nodeAddressToStakerAddressAcrossRealms(address)` and selector `0x86b01dd6`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct NodeAddressToStakerAddressAcrossRealmsReturn(
        pub ::ethers::core::types::Address,
    );
    ///Container type for all return fields from the `numRealms` function with signature `numRealms()` and selector `0xfc14e3b9`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct NumRealmsReturn(pub ::ethers::core::types::U256);
    ///Container type for all return fields from the `operatorAddressToStakerAddress` function with signature `operatorAddressToStakerAddress(address)` and selector `0xab8ccfbe`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct OperatorAddressToStakerAddressReturn(pub ::ethers::core::types::Address);
    ///Container type for all return fields from the `owner` function with signature `owner()` and selector `0x8da5cb5b`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct OwnerReturn {
        pub owner: ::ethers::core::types::Address,
    }
    ///Container type for all return fields from the `ownerOf` function with signature `ownerOf(uint256)` and selector `0x6352211e`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct OwnerOfReturn(pub ::ethers::core::types::Address);
    ///Container type for all return fields from the `ownershipChange` function with signature `ownershipChange(uint256)` and selector `0x23857d51`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct OwnershipChangeReturn(pub ::ethers::core::types::U256);
    ///Container type for all return fields from the `permittedRealmsForValidator` function with signature `permittedRealmsForValidator(address)` and selector `0xe718ff4c`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct PermittedRealmsForValidatorReturn(
        pub ::std::vec::Vec<::ethers::core::types::U256>,
    );
    ///Container type for all return fields from the `permittedValidators` function with signature `permittedValidators(uint256)` and selector `0x58488c31`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct PermittedValidatorsReturn(
        pub ::std::vec::Vec<::ethers::core::types::Address>,
    );
    ///Container type for all return fields from the `pow` function with signature `pow(uint256,uint256)` and selector `0x2e4c697f`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct PowReturn(pub ::ethers::core::types::U256);
    ///Container type for all return fields from the `readyForNextEpoch` function with signature `readyForNextEpoch(uint256,address)` and selector `0xf2c5b908`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct ReadyForNextEpochReturn(pub bool);
    ///Container type for all return fields from the `realmConfig` function with signature `realmConfig(uint256)` and selector `0xe56cfb79`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct RealmConfigReturn(pub RealmConfig);
    ///Container type for all return fields from the `selfStakeBalanceOf` function with signature `selfStakeBalanceOf(address)` and selector `0xeddf837a`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct SelfStakeBalanceOfReturn(pub ::ethers::core::types::U256);
    ///Container type for all return fields from the `shouldKickValidator` function with signature `shouldKickValidator(uint256,address)` and selector `0x1e966b97`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct ShouldKickValidatorReturn(pub bool);
    ///Container type for all return fields from the `stakerToValidatorsTheyStakedTo` function with signature `stakerToValidatorsTheyStakedTo(address)` and selector `0x6817d36e`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct StakerToValidatorsTheyStakedToReturn(
        pub ::std::vec::Vec<::ethers::core::types::Address>,
    );
    ///Container type for all return fields from the `state` function with signature `state(uint256)` and selector `0x3e4f49e6`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct StateReturn(pub u8);
    ///Container type for all return fields from the `supportsInterface` function with signature `supportsInterface(bytes4)` and selector `0x01ffc9a7`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct SupportsInterfaceReturn(pub bool);
    ///Container type for all return fields from the `targetArtifactSelectors` function with signature `targetArtifactSelectors()` and selector `0x66d9a9a0`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct TargetArtifactSelectorsReturn {
        pub targeted_artifact_selectors: ::std::vec::Vec<FuzzArtifactSelector>,
    }
    ///Container type for all return fields from the `targetArtifacts` function with signature `targetArtifacts()` and selector `0x85226c81`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct TargetArtifactsReturn {
        pub targeted_artifacts: ::std::vec::Vec<::std::string::String>,
    }
    ///Container type for all return fields from the `targetContracts` function with signature `targetContracts()` and selector `0x3f7286f4`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct TargetContractsReturn {
        pub targeted_contracts: ::std::vec::Vec<::ethers::core::types::Address>,
    }
    ///Container type for all return fields from the `targetInterfaces` function with signature `targetInterfaces()` and selector `0x2ade3880`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct TargetInterfacesReturn {
        pub targeted_interfaces: ::std::vec::Vec<FuzzInterface>,
    }
    ///Container type for all return fields from the `targetSelectors` function with signature `targetSelectors()` and selector `0x916a17c6`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct TargetSelectorsReturn {
        pub targeted_selectors: ::std::vec::Vec<FuzzSelector>,
    }
    ///Container type for all return fields from the `targetSenders` function with signature `targetSenders()` and selector `0x3e5e3c23`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct TargetSendersReturn {
        pub targeted_senders: ::std::vec::Vec<::ethers::core::types::Address>,
    }
    ///Container type for all return fields from the `tokenOfOwnerByIndex` function with signature `tokenOfOwnerByIndex(address,uint256)` and selector `0x2f745c59`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct TokenOfOwnerByIndexReturn(pub ::ethers::core::types::U256);
    ///Container type for all return fields from the `tokenToStakeRecord` function with signature `tokenToStakeRecord(uint256)` and selector `0xf0e2d9b5`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct TokenToStakeRecordReturn(pub MappedStakeRecord);
    ///Container type for all return fields from the `totalSupply` function with signature `totalSupply()` and selector `0x18160ddd`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct TotalSupplyReturn(pub ::ethers::core::types::U256);
    ///Container type for all return fields from the `validatorSelfStakeWillExpire` function with signature `validatorSelfStakeWillExpire(uint256,address,bool)` and selector `0xbb8b437f`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct ValidatorSelfStakeWillExpireReturn(pub bool);
    ///Container type for all return fields from the `validator_by_staker_address` function with signature `validator_by_staker_address(address)` and selector `0x794de9b5`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
    )]
    pub struct ValidatorByStakerAddressReturn(pub Validator);
    ///Container type for all return fields from the `validators` function with signature `validators(address)` and selector `0xfa52c7d8`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
    )]
    pub struct ValidatorsReturn(pub Validator);
    ///Container type for all return fields from the `verifyKeySetCounts` function with signature `verifyKeySetCounts(string,(bytes,uint256)[])` and selector `0xf14baa40`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct VerifyKeySetCountsReturn(
        pub ::ethers::core::types::U256,
        pub ::ethers::core::types::U256,
    );
    ///`FacetCut(address,uint8,bytes4[])`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct FacetCut {
        pub facet_address: ::ethers::core::types::Address,
        pub action: u8,
        pub function_selectors: ::std::vec::Vec<[u8; 4]>,
    }
    ///`Facet(address,bytes4[])`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct Facet {
        pub facet_address: ::ethers::core::types::Address,
        pub function_selectors: ::std::vec::Vec<[u8; 4]>,
    }
    ///`RootKey(bytes,uint256)`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct RootKey {
        pub pubkey: ::ethers::core::types::Bytes,
        pub key_type: ::ethers::core::types::U256,
    }
    ///`AddressMapping(address,address)`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct AddressMapping {
        pub node_address: ::ethers::core::types::Address,
        pub staker_address: ::ethers::core::types::Address,
    }
    ///`ComplaintConfig(uint256,uint256,uint256,uint256)`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct ComplaintConfig {
        pub tolerance: ::ethers::core::types::U256,
        pub interval_secs: ::ethers::core::types::U256,
        pub kick_penalty_percent: ::ethers::core::types::U256,
        pub kick_penalty_demerits: ::ethers::core::types::U256,
    }
    ///`Epoch(uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256)`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct Epoch {
        pub epoch_length: ::ethers::core::types::U256,
        pub number: ::ethers::core::types::U256,
        pub reward_epoch_number: ::ethers::core::types::U256,
        pub next_reward_epoch_number: ::ethers::core::types::U256,
        pub end_time: ::ethers::core::types::U256,
        pub retries: ::ethers::core::types::U256,
        pub timeout: ::ethers::core::types::U256,
        pub start_time: ::ethers::core::types::U256,
        pub last_advance_vote_time: ::ethers::core::types::U256,
    }
    ///`GlobalConfig(uint256,uint256[],uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,bool,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256)`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct GlobalConfig {
        pub token_reward_per_token_per_epoch: ::ethers::core::types::U256,
        pub key_types: ::std::vec::Vec<::ethers::core::types::U256>,
        pub minimum_validator_count: ::ethers::core::types::U256,
        pub reward_epoch_duration: ::ethers::core::types::U256,
        pub max_time_lock: ::ethers::core::types::U256,
        pub min_time_lock: ::ethers::core::types::U256,
        pub bmin: ::ethers::core::types::U256,
        pub bmax: ::ethers::core::types::U256,
        pub k: ::ethers::core::types::U256,
        pub p: ::ethers::core::types::U256,
        pub enable_stake_autolock: bool,
        pub token_price: ::ethers::core::types::U256,
        pub profit_multiplier: ::ethers::core::types::U256,
        pub usd_cost_per_month: ::ethers::core::types::U256,
        pub max_emission_rate: ::ethers::core::types::U256,
        pub min_stake_amount: ::ethers::core::types::U256,
        pub max_stake_amount: ::ethers::core::types::U256,
        pub min_self_stake: ::ethers::core::types::U256,
        pub min_self_stake_timelock: ::ethers::core::types::U256,
        pub min_validator_count_to_clamp_minimum_threshold: ::ethers::core::types::U256,
        pub min_threshold_to_clamp_at: ::ethers::core::types::U256,
        pub vote_to_advance_time_out: ::ethers::core::types::U256,
    }
    ///`KeySetConfig(uint32,uint32,bool,string,string,uint256[],uint256[],uint256[],address[])`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct KeySetConfig {
        pub minimum_threshold: u32,
        pub monetary_value: u32,
        pub complete_isolation: bool,
        pub identifier: ::std::string::String,
        pub description: ::std::string::String,
        pub realms: ::std::vec::Vec<::ethers::core::types::U256>,
        pub curves: ::std::vec::Vec<::ethers::core::types::U256>,
        pub counts: ::std::vec::Vec<::ethers::core::types::U256>,
        pub recovery_party_members: ::std::vec::Vec<::ethers::core::types::Address>,
    }
    ///`LitActionConfig(uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,bool)`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct LitActionConfig {
        pub timeout_ms: ::ethers::core::types::U256,
        pub memory_limit_mb: ::ethers::core::types::U256,
        pub max_code_length: ::ethers::core::types::U256,
        pub max_response_length: ::ethers::core::types::U256,
        pub max_console_log_length: ::ethers::core::types::U256,
        pub max_fetch_count: ::ethers::core::types::U256,
        pub max_sign_count: ::ethers::core::types::U256,
        pub max_contract_call_count: ::ethers::core::types::U256,
        pub max_broadcast_and_collect_count: ::ethers::core::types::U256,
        pub max_call_depth: ::ethers::core::types::U256,
        pub max_retries: ::ethers::core::types::U256,
        pub async_actions_enabled: bool,
    }
    ///`MappedStakeRecord(address,uint256)`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct MappedStakeRecord {
        pub operator_staker_address: ::ethers::core::types::Address,
        pub stake_record_id: ::ethers::core::types::U256,
    }
    ///`PubKeyMapping(address,(uint256,uint256))`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct PubKeyMapping {
        pub node_address: ::ethers::core::types::Address,
        pub pub_key: UncompressedK256Key,
    }
    ///`RealmConfig(uint256,uint256,uint256,uint256,uint256,bool,uint256,bool)`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct RealmConfig {
        pub max_concurrent_requests: ::ethers::core::types::U256,
        pub max_presign_count: ::ethers::core::types::U256,
        pub min_presign_count: ::ethers::core::types::U256,
        pub peer_checking_interval_secs: ::ethers::core::types::U256,
        pub max_presign_concurrency: ::ethers::core::types::U256,
        pub rpc_healthcheck_enabled: bool,
        pub min_epoch_for_rewards: ::ethers::core::types::U256,
        pub permitted_validators_on: bool,
    }
    ///`RewardEpoch(uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,bool)`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct RewardEpoch {
        pub epoch_end: ::ethers::core::types::U256,
        pub total_stake_weight: ::ethers::core::types::U256,
        pub total_stake_rewards: ::ethers::core::types::U256,
        pub validator_fixed_cost_rewards: ::ethers::core::types::U256,
        pub validator_commission: ::ethers::core::types::U256,
        pub slope: ::ethers::core::types::U256,
        pub validator_share_price: ::ethers::core::types::U256,
        pub stake_amount: ::ethers::core::types::U256,
        pub validator_share_price_at_last_update: ::ethers::core::types::U256,
        pub initial: bool,
    }
    ///`RewardEpochGlobalStats(uint256,uint256,address[],uint256)`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct RewardEpochGlobalStats {
        pub stake_amount: ::ethers::core::types::U256,
        pub stake_weight: ::ethers::core::types::U256,
        pub validators_in_current_epoch: ::std::vec::Vec<::ethers::core::types::Address>,
        pub actual_epoch_length: ::ethers::core::types::U256,
    }
    ///`StakeRecord(uint256,uint256,uint256,uint256,uint256,uint256,uint256,bool,bool,address,uint256)`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct StakeRecord {
        pub id: ::ethers::core::types::U256,
        pub amount: ::ethers::core::types::U256,
        pub unfreeze_start: ::ethers::core::types::U256,
        pub time_lock: ::ethers::core::types::U256,
        pub last_update_timestamp: ::ethers::core::types::U256,
        pub last_reward_epoch_claimed: ::ethers::core::types::U256,
        pub initial_share_price: ::ethers::core::types::U256,
        pub loaded: bool,
        pub frozen: bool,
        pub attribution_address: ::ethers::core::types::Address,
        pub token_id: ::ethers::core::types::U256,
    }
    ///`UncompressedK256Key(uint256,uint256)`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct UncompressedK256Key {
        pub x: ::ethers::core::types::U256,
        pub y: ::ethers::core::types::U256,
    }
    ///`Validator(uint32,uint128,uint32,address,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,address,uint256,bool)`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct Validator {
        pub ip: u32,
        pub ipv_6: u128,
        pub port: u32,
        pub node_address: ::ethers::core::types::Address,
        pub reward: ::ethers::core::types::U256,
        pub sender_pub_key: ::ethers::core::types::U256,
        pub receiver_pub_key: ::ethers::core::types::U256,
        pub last_active_epoch: ::ethers::core::types::U256,
        pub commission_rate: ::ethers::core::types::U256,
        pub last_reward_epoch: ::ethers::core::types::U256,
        pub last_realm_id: ::ethers::core::types::U256,
        pub delegated_stake_amount: ::ethers::core::types::U256,
        pub delegated_stake_weight: ::ethers::core::types::U256,
        pub last_reward_epoch_claimed_fixed_cost_rewards: ::ethers::core::types::U256,
        pub last_reward_epoch_claimed_commission: ::ethers::core::types::U256,
        pub operator_address: ::ethers::core::types::Address,
        pub unique_delegating_staker_count: ::ethers::core::types::U256,
        pub register_attested_wallet_disabled: bool,
    }
    ///`Version(uint256,uint256,uint256)`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct Version {
        pub major: ::ethers::core::types::U256,
        pub minor: ::ethers::core::types::U256,
        pub patch: ::ethers::core::types::U256,
    }
    ///`TestValidator(address,uint256)`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct TestValidator {
        pub staker_address: ::ethers::core::types::Address,
        pub comms_key: ::ethers::core::types::U256,
    }
    ///`FuzzArtifactSelector(string,bytes4[])`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct FuzzArtifactSelector {
        pub artifact: ::std::string::String,
        pub selectors: ::std::vec::Vec<[u8; 4]>,
    }
    ///`FuzzInterface(address,string[])`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct FuzzInterface {
        pub addr: ::ethers::core::types::Address,
        pub artifacts: ::std::vec::Vec<::std::string::String>,
    }
    ///`FuzzSelector(address,bytes4[])`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        serde::Serialize,
        serde::Deserialize,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash
    )]
    pub struct FuzzSelector {
        pub addr: ::ethers::core::types::Address,
        pub selectors: ::std::vec::Vec<[u8; 4]>,
    }
}
